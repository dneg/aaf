#c *********************************************************************
#c
#c The contents of this file are subject to the AAF SDK Public
#c Source License Agreement (the "License"); You may not use this file
#c except in compliance with the License.  The License is available in
#c AAFSDKPSL.TXT, or you may obtain a copy of the License from the AAF
#c Association or its successor.
#c 
#c Software distributed under the License is distributed on an "AS IS"
#c basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See
#c the License for the specific language governing rights and limitations
#c under the License.
#c 
#c The Original Code of this file is Copyright 1998-2001, Licensor of the
#c AAF Association.
#c 
#c The Initial Developer of the Original Code of this file and the
#c Licensor of the AAF Association is Avid Technology.
#c All rights reserved.
#c
#c *********************************************************************
#startm .this-module 0
AAFModule\
#endm
AD_IDL(\  //***********************************************************
  //
  // Global functions for AAF files:
  // 
  // In addition to the specific error results listed for each function\,
  // all factory functions may also return one of the following
  // values:
  // 
  // AAFRESULT_NOMEMORY
  //   - insufficient system memory is available to perform the
  //     operation.
  //)

AD_MODULE_BEGIN(AAF, API)

AD_CPP_QUOTE(\  //***********************************************************)
AD_CPP_QUOTE(\  // Functions used to dynamically load and unload the AAF dll)
AD_CPP_QUOTE(\  // without statically linking to the dll's export library.)
AD_CPP_QUOTE(\  // To use these functions link to the stub library aaf.lib)
AD_CPP_QUOTE(\  // \(or aafd.lib for the debugging version\). )
AD_CPP_QUOTE(\  // If the client is statically linking to the AAF dll's export)
AD_CPP_QUOTE(\  // library then the following functions will always succeed:)
AD_CPP_QUOTE(\  //***********************************************************)

AD_XFUNCTION1(AAFLoad,

			[in],
			objPass,
			const char *,
			dllname,
       Pointer to the name of AAF dll to load.
    // If this pointer is NULL the function will attempt to load the
    // default AAF dll.,

			Attempts to load the given implementation of AAF into
  // the processes address space. Only one implementation
  // of AAF can be active. Note: once AAFUnload has been
  // called all subsequent access to AAF interfaces will fail
  //
  // To use this function link to the stub library aaf.lib
  // \(or aafd.lib for the debugging version\). 
  // If the client is statically linking to the AAF dll's export
  // library then the function will always succeed.)


AD_FUNCTION0(AAFUnload,

			Attempts to unload the current AAF dll loaded with a
  // previous call to AAFLoad.)


AD_CPP_QUOTE(\  //***********************************************************)
AD_CPP_QUOTE(\  // Factory functions for AAF files:.)
AD_CPP_QUOTE(\  //***********************************************************)

AD_XFUNCTION3(AAFFileOpenExistingRead,

			[in\, string],
			objPass,
			aafCharacter_constptr,
			pFileName,
       Null-terminated string containing name of filesystem file to be
    // opened for reading.  Filename must be in a form that would be
    // acceptable to StgOpenStorage\(\) for this platform.,

			[in],
			objPass,
			aafUInt32,
			modeFlags,
       File open mode flags.  May be any of the following ORed
    // together.  All other bits must be set to zero.
    //
    //  - kAAFFileModeUnbuffered - to indicate buffered mode.  Default
    //    is buffered.,

			[out],
			objOut,
			AAFFile,
			ppFile,
			Pointer to buffer to receive pointer to new file.,


     Creates an object associated with with an existing filesystem
  // file that contains data which is only to be read.
  // Does the following:
  //
  // - Opens the existing named file in the filesystem for reading.
  // - Associates an object with that filesystem file.
  // - Places the object into the Open-read-only state.
  // - This AAFFile object then can be used as the root of the
  //   containment tree representing all AAF objects contained within the file.
  //
  // Succeeds if:
  // - The pFileName argument is valid.
  // - Only valid flags have been specified.
  // - A valid combination of flags has been specified.
  // - The named file exists in the filesystem.
  // - The named filesystem file is readable.
  // - The named file represents itself as a valid AAF file.  Even if
  //   this succeeds\, it is not guaranteed that the named file is in fact a valid AAF file.
  //
  // This function will return the following codes.  If more than one of
  // the listed errors is in effect\, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  \(This is the only code indicating success.\)
  //
  // AAFRESULT_NULL_PARAM
  //   - the pFileName pointer arg is NULL.
  //
  // AAFRESULT_BAD_FLAGS
  //   - one or more illegal flags were specified.
  //
  // AAFRESULT_BAD_FLAG_COMBINATION
  //   - illegal combination of otherwise valid flags was specified.
  //
  // AAFRESULT_FILE_NOT_FOUND
  //   - The named file does not exist in the filesystem.
  //
  // AAFRESULT_NOT_READABLE
  //   - The named file cannot be read.
  //
  // AAFRESULT_NOT_AAF_FILE
  //   - The named file does not claim to be a valid AAF file.)


AD_XFUNCTION4(AAFFileOpenExistingModify,

			[in\, string],
			objPass,
			aafCharacter_constptr,
			pFileName,
			Null-terminated string containing name of filesystem file to be
    // opened for modification.  Filename must be in a form that would
    // be acceptable to StgOpenStorage\(\) for this platform.,

			[in],
			objPass,
			aafUInt32,
			modeFlags,
			File open mode flags.  May be any of the following ORed together.
    // All other bits must be set to zero.
    //
    //  - kAAFFileModeUnbuffered
    //    to indicate unbuffered mode. Default is buffered.
    //  - kAAFFileModeRevertable
    //    to indicate that Revert is possible on this file \(for all changes except those to essence\).,

			[in],
			objPass,
			aafProductIdentification_t *,
			pIdent,
			Identification of the application which is modifying this file.,

			[out],
			objOut,
			AAFFile,
			ppFile,
			Pointer to buffer to receive pointer to new file.,


			Creates an object associated with with an existing
  // filesystem file that contains data which is to be read and
  // written.  Associates the given identification with it.
  // Does the following:
  //
  // - Opens the existing named file in the filesystem for reading and
  //   writing.
  // - Associates an object with that filesystem file.
  // - Places the object into the Open-read-write  state.
  // - This AAFFile object then can be used as the root of the
  //   containment tree representing all AAF objects contained within the file.
  //
  // Succeeds if:
  // - This object is currently Closed.
  // - The pFileName argument is valid.
  // - The pIdent argument is valid.
  // - Only valid flags have been specified.
  // - A valid combination of flags has been specified.
  // - The named file exists in the filesystem.
  // - The named filesystem file is readable.
  // - The named filesystem file is writable.
  // - The named file represents itself as a valid AAF file.  Even if
  //   this succeeds\, it is not guaranteed that the named file is in fact a valid AAF file.
  //
  // This function will return the following codes.  If more than one of
  // the listed errors is in effect\, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  \(This is the only code indicating success.\)
  //
  // AAFRESULT_NULL_PARAM
  //   - either pFileName or pIdent pointer argument is NULL.
  //
  // AAFRESULT_BAD_FLAGS
  //   - one or more illegal flags were specified.
  //
  // AAFRESULT_BAD_FLAG_COMBINATION
  //   - illegal combination of otherwise valid flags was specified.
  //
  // AAFRESULT_FILE_NOT_FOUND
  //   - The named file does not exist in the filesystem.
  //
  // AAFRESULT_NOT_READABLE
  //   - The named file cannot be read.
  //
  // AAFRESULT_NOT_WRITEABLE
  //   - The named file cannot be written.
  //
  // AAFRESULT_NOTAAFFILE
  //   - The named file is not a valid AAF file.)


AD_XFUNCTION4(AAFFileOpenNewModify,

			[in\, string],
			objPass,
			aafCharacter_constptr,
			pFileName,
			Null-terminated string containing name of filesystem file to be
    // opened for modification.  Filename must be in a form that would
    // be acceptable to StgOpenStorage\(\) for this platform.,

			[in],
			objPass,
			aafUInt32,
			modeFlags,
			File open mode flags.  May be any of the following ORed together.
    // All other bits must be set to zero.
    //
    //  - kAAFFileModeUnbuffered
    //    to indicate unbuffered mode. Default is buffered.
    //  - kAAFFileModeRevertable
    //    to indicate that Revert is possible on this file \(for all changes except those to essence\).,

			[in],
			objPass,
			aafProductIdentification_t *,
			pIdent,
			Identification of the application which is creating this file.,

			[out],
			objOut,
			AAFFile,
			ppFile,
			Pointer to buffer to receive pointer to new file.,


			Creates an object associated with with a new
  // filesystem file that contains data which is to be read and
  // written.  Associates the given identification with it.
  // Does the following:
  //
  // - Creates a new file in the filesystem with the given name.
  // - Opens the filesystem file for reading and writing.
  // - Associates this object with that filesystem file.
  // - Places this object into the Open state.
  // - This AAFFile object then can be used as the root of the
  //   containment tree representing all AAF objects contained within the file.
  //
  // Succeeds if:
  // - The pFileName argument is valid.
  // - The pIdent argument is valid.
  // - Only valid flags have been specified.
  // - A valid combination of flags has been specified.
  // - The named file does not exists in the filesystem.
  // - There is sufficient space in the filesystem to create the file.
  //
  // This function will return the following codes.  If more than one of
  // the listed errors is in effect\, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  \(This is the only code indicating success.\)
  //
  // AAFRESULT_NULL_PARAM
  //   - either pFileName or pIdent pointer argument is NULL.
  //
  // AAFRESULT_BAD_FLAGS
  //   - one or more illegal flags were specified.
  //
  // AAFRESULT_BAD_FLAG_COMBINATION
  //   - illegal combination of otherwise valid flags was specified.
  //
  // AAFRESULT_FILE_EXISTS
  //   - The named file already exists in the filesystem.
  //
  // AAFRESULT_INSUFFICIENT_SPACE
  //   - There is insufficient space in the filesystem to create this
  //     file.)


AD_XFUNCTION2(AAFFileOpenTransient,
			[in],
			objPass,
			aafProductIdentification_t *,
			pIdent,
			Identification which is to be associated with this file.,

			[out],
			objOut,
			AAFFile,
			ppFile,
			Pointer to buffer to receive pointer to new file.,


			Creates an object associated with with a transient file\,
  // meaning that it is not associated with any filesystem file but
  // may still be used to contain AAF objects as if it was associated
  // with a filesystem file.  Associates the given identification with
  // this file.
  //
  // Transient files are never considered Revertable.
  //
  // NOTE! Stub only.   Implementation not yet added.
  //
  // Succeeds if:
  // - This object has already been Initialize\(\)d.
  // - The pIdent argument is valid.
  // - This object is currently closed.
  //
  // This function will return the following codes.  If more than one of
  // the listed errors is in effect\, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  \(This is the only code indicating success.\)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize\(\) called on it.
  //
  // AAFRESULT_ALREADY_OPEN
  //   - This object is already open.
  //
  // AAFRESULT_NULL_PARAM
  //   - the pIdent pointer argument is NULL.)


AD_XFUNCTION3(AAFFileIsAAFFile,

			[in\, string],
			objPass,
			aafCharacter_constptr,
			pFileName,
			Null-terminated string containing name of filesystem file.,

			[out],
			objPass,
			aafUID_t *,
			pAAFFileKind,
			Pointer to an AUID indicating the file kind,

			[out\,retval],
			objPass,
			aafBool *,
			pFileIsAAFFile,
			Returns AAFTrue if the given file is an AAF file\, returns AAFFalse otherwise.,

			Is the named file an AAF file ?
  //
  // Note that the function result is returned via the pFileIsAAFFile argument.
  // If this function succeeds it returns AAFRESULT_SUCCESS even if the named
  // file is not an AAF file.
  //
  // This function will return the following codes.  If more than one of
  // the listed errors is in effect\, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  \(This is the only code indicating success.\)
  //
  // AAFRESULT_NULL_PARAM
  //   - at least one of the pointer arguments is NULL.
  //
  // AAFRESULT_FILE_NOT_FOUND
  //   - the file named by pFileName cannot be found.)


AD_XFUNCTION1(AAFGetPluginManager,
			[out],
			objOut,
			AAFPluginManager,
			ppPluginManager,
			Pointer to the interface of the plugin manager.,


     Returns an interface of the plugin manager\, which is used to
  // select plugins for exporting.)


AD_XFUNCTION2(AAFCreateRawStorageMemory,

			  [in],
			  objPass,
			  aafFileAccess_t,
			  access,
			  Governs whether stream may be read from and/or written
    // to.,

			  [out],
			  objOut,
			  AAFRawStorage,
			  ppNewRawStorage,
			  Newly created storage,

     Create a raw storage providing a built-in implementation of
  // IAAFRawStorage on memory.
  //
  // This is considered a value-added function since clients could
  // actually create their own.
  //
  // Succeeds if:
  // - The ppNewRawStorage pointer is valid.
  AD_STD_COMMENT_METH_ERR_HEADER
  AD_STD_COMMENT_METH_ERR_NULL_PARAM\(ppNewRawStorage\))


AD_XFUNCTION4(AAFCreateRawStorageDisk,

			  [in],
			  objPass,
			  aafCharacter_constptr,
			  pFilename,
			  Name of file to be associated with this storage,

			  [in],
			  objPass,
			  aafFileExistence_t,
			  existence,
			  Governs whether storage is on pre-existing data\, or is
    //  newly created.,

			  [in],
			  objPass,
			  aafFileAccess_t,
			  access,
			  Governs whether stream may be read from and/or written
    //  to.,

			  [out],
			  objOut,
			  AAFRawStorage,
			  ppNewRawStorage,
			  Newly created storage,

     Create a raw storage providing a built-in implementation of
  // IAAFRawStorage on a file on disk.
  //
  // Note that it is illegal to specify existence and access as "New"
  // "Read".
  //
  // This is considered a value-added function since clients could
  // actually create their own.
  //
  // Succeeds if:
  // - The pFilename pointer is valid.
  // - The ppNewRawStorage pointer is valid.
  // - If the open mode is one of read\, write\, or modify.
  // - If the file existence is one of new or existing.
  AD_STD_COMMENT_METH_ERR_HEADER
  AD_STD_COMMENT_METH_ERR_NULL_PARAM\(pFilename or ppNewRawStorage\)
  //
  // AAFRESULT_WRONG_OPENMODE
  // - If none of read\, modify\, or write are specified as open
  //   mode\, or if neither new or existing is specified for the
  //   existence.)

AD_XFUNCTION6(AAFCreateRawStorageCachedDisk,

			  [in],
			  objPass,
			  aafCharacter_constptr,
			  pFilename,
			  Name of file to be associated with this storage,

			  [in],
			  objPass,
			  aafFileExistence_t,
			  existence,
			  Governs whether storage is on pre-existing data\, or is
    //  newly created.,

			  [in],
			  objPass,
			  aafFileAccess_t,
			  access,
			  Governs whether stream may be read from and/or written
    //  to.,

			  [in],
			  objPass,
			  aafUInt32,
			  pageCount,
			  Count of cache pages,

			  [in],
			  objPass,
			  aafUInt32,
			  pageSize,
			  Cache page size in bytes,

			  [out],
			  objOut,
			  AAFRawStorage,
			  ppNewRawStorage,
			  Newly created storage,

     Create a raw storage providing a built-in implementation of
  // IAAFRawStorage on a file on disk with caching.
  //
  // Note that it is illegal to specify existence and access as "New"
  // "Read".
  //
  // This is considered a value-added function since clients could
  // actually create their own.
  //
  // Succeeds if:
  // - The pFilename pointer is valid.
  // - The ppNewRawStorage pointer is valid.
  // - If the open mode is one of read\, write\, or modify.
  // - If the file existence is one of new or existing.
  AD_STD_COMMENT_METH_ERR_HEADER
  AD_STD_COMMENT_METH_ERR_NULL_PARAM\(pFilename or ppNewRawStorage\)
  //
  // AAFRESULT_WRONG_OPENMODE
  // - If none of read\, modify\, or write are specified as open
  //   mode\, or if neither new or existing is specified for the
  //   existence.)


AD_XFUNCTION7(AAFCreateAAFFileOnRawStorage,

			  [in],
			  objPass,
			  IAAFRawStorage *,
			  pRawStorage,
			  storage to be associated with this file,

			  [in],
			  objPass,
			  aafFileExistence_t,
			  existence,
			  Governs whether storage is on pre-existing data\, or is
    //  newly created.,

			  [in],
			  objPass,
			  aafFileAccess_t,
			  access,
			  Governs whether stream may be read from and/or written
    //  to.,

			  [in],
			  objPass,
			  aafUID_constptr,
			  pFileKind,
			  kind of file to be created; only used for new files,

			  [in],
			  objPass,
			  aafUInt32,
			  modeFlags,
			  File mode flags,

			  [in],
			  objPass,
			  aafProductIdentification_constptr,
			  pIdent,
			  Identification to be associated with this file; only
    //  used for new files,

			  [out],
			  objOut,
			  AAFFile,
			  ppNewFile,
			  newly-created file,

     Given an IAAFRawStorage\, create an IAAFFile.  If pRawStorage is
  // actually an IAAFRandomRawStorage\, the created file will be an
  // IAAFRandomFile.
  //
  // Note that AAF files based on Binary Structured Storage will
  // require the underlying IAAFRawStorage to be at least readable\,
  // even in the case of write-only AAF files.
  //
  // Note also that only the following combinations of access and
  // existence are legal:
  //
  //          existence   access   Legal?
  //          ---------   ------   ------
  //          existing    read     yes
  //          existing    write    no
  //          existing    modify   yes
  //            new       read     no
  //            new       write    yes
  //            new       modify   yes
  //
  // This method will succeed if the following are true:
  // - The pRawStorage pointer is valid.
  // - The ppNewFile pointer is valid.
  // - The accessibility of the specified raw storage matches that of the desired AAF File; additionally\, if the file kind is
  //   Structured Storage Binary\, the raw storage is also required to be at least readable. 
  // - A legal combination of existence and access flags is given.
  AD_STD_COMMENT_METH_ERR_HEADER
  AD_STD_COMMENT_METH_ERR_NULL_PARAM\(pRawStorage or ppNewFile\)
  //
  // AAFRESULT_NOT_READABLE
  // - The access parameter specifies readability or if this file is
  //   Binary Structured Storage\, but the specified raw storage is
  //   not readable.
  //
  // AAFRESULT_NOT_WRITEABLE
  // - The access parameter specifies writeability but the specified
  //   raw storage is not writeable.
  //
  // AAFRESULT_NULL_PARAM
  // - existence is new\, and pFileKind is NULL.
  //
  // AAFRESULT_INVALID_PARAM
  // - The access or existence parameters are not set to a legal
  //   combination of values.)
AD_MODULE_END
