#c /***********************************************\
#c *                                               *
#c * Advanced Authoring Format                     *
#c *                                               *
#c * Copyright (c) 1998-1999 Avid Technology, Inc. *
#c *                                               *
#c \***********************************************/



#ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
#c
#c AutoDodo macro file for use in generating COM API implementation
#c header files.
#c
#ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


#import macros/base.mac


#ccccccccccccccccccccccccccc
#c
#c Pass through argument if for idl otherwise omit it.
#c 
#c This macro is generally used to specify IDL options that would
#c make since to emit to c++.
#c To allow proper marshalling code generation of a struct: |
#c typedef struct
#c {
#c     aafInt32 length;
#c     AD_IDL([length_is(length)]) aafWchar *str;
#c } aafString_t;
#c
#startm AD_IDL 01
#endm


#ccccccccccccccccccccccccccc
#c
#c Includes another file.
#c
#c Argument: Base filename
#c
#startm AD_INCLUDE 01
#ifndef __%01_h__
#include "%01.h"
#endif
#endm


#ccccccccccccccccccccccccccc
#c
#c Goes at the head of the file.
#c
#c Arguments: none
#c
#startm AD_HEAD 00
//@doc
//@class    .this-module | Implementation class for .this-module
#ifndef __C.this-module_h__
#define __C.this-module_h__

/***********************************************************************
*
*              Copyright (c) 1998-1999 Avid Technology, Inc.
*
* Permission to use, copy and modify this software and accompanying
* documentation, and to distribute and sublicense application software
* incorporating this software for any purpose is hereby granted,
* provided that (i) the above copyright notice and this permission
* notice appear in all copies of the software and related documentation,
* and (ii) the name Avid Technology, Inc. may not be used in any
* advertising or publicity relating to the software without the specific,
*  prior written permission of Avid Technology, Inc.
*
* THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND,
* EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY
* WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.
* IN NO EVENT SHALL AVID TECHNOLOGY, INC. BE LIABLE FOR ANY DIRECT,
* SPECIAL, INCIDENTAL, PUNITIVE, INDIRECT, ECONOMIC, CONSEQUENTIAL OR
* OTHER DAMAGES OF ANY KIND, OR ANY DAMAGES WHATSOEVER ARISING OUT OF
* OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE AND
* ACCOMPANYING DOCUMENTATION, INCLUDING, WITHOUT LIMITATION, DAMAGES
* RESULTING FROM LOSS OF USE, DATA OR PROFITS, AND WHETHER OR NOT
* ADVISED OF THE POSSIBILITY OF DAMAGE, REGARDLESS OF THE THEORY OF
* LIABILITY.
*
************************************************************************/


#ifndef __AAF_h__
#include "AAF.h"
#endif
#endm


#ccccccccccccccccccccccccccc
#c
#c AAFTypes support for IDL
#c
#c Arguments: none
#c
#startm AD_TYPES_HEAD 00
#endm


#ccccccccccccccccccccccccccc
#c
#c Starts a class definition
#c
#c Arguments: none
#c
#startm AD_CLASS_BEGIN 00
#ifndef __C.parent-module_h__
#include "C.parent-module.h"
#endif

//
// Forward declaration
//
class Impl.this-module;


class C.this-module
  : public I.this-module,
    public C.parent-module
{
protected:

  //********
  //
  // Constructor/destructor
  //
  C.this-module (IUnknown * pControllingUnknown, aafBool doInit = AAFTrue);
  virtual ~C.this-module ();

public:
#endm


#ccccccccccccccccccccccccccc
#c
#c Ends a class definition for classes which support more than the
#c primary COM interface.
#c
#c Arguments: additional interface name
#c
#startm AD_COM_EXT_CLASS_BEGIN 01
#ifndef __C.parent-module_h__
#include "C.parent-module.h"
#endif

//
// Forward declaration
//
class Impl.this-module;


class C.this-module
  : public I.this-module,
    %01,
    public C.parent-module
{
protected:

  //********
  //
  // Constructor/destructor
  //
  C.this-module (IUnknown * pControllingUnknown, aafBool doInit = AAFTrue);
  virtual ~C.this-module ();

public:
#endm

#ccccccccccccccccccccccccccc
#c
#c Ends a class definition for classes which support more than the
#c primary COM interface.
#c
#c Arguments: additional interface name
#c
#startm AD_COM_EXT2_CLASS_BEGIN 02
#ifndef __C.parent-module_h__
#include "C.parent-module.h"
#endif

//
// Forward declaration
//
class Impl.this-module;


class C.this-module
  : public I.this-module,
    %01,
	%02,
    public C.parent-module
{
protected:

  //********
  //
  // Constructor/destructor
  //
  C.this-module (IUnknown * pControllingUnknown, aafBool doInit = AAFTrue);
  virtual ~C.this-module ();

public:
#endm



#ccccccccccccccccccccccccccc
#c
#c Starts a class definition with no parent class
#c
#c Arguments: none
#c
#startm AD_ROOT_CLASS_BEGIN 00
#ifndef __CAAFUnknown_h__
#include "CAAFUnknown.h"
#endif

#ifndef __AAFRoot_h__
#include "AAFRoot.h"
#endif

//
// Forward declaration
//
class Impl.this-module;


class C.this-module
  : public I.this-module,
    public CAAFUnknown
{
protected:

  //********
  //
  // Constructor/destructor
  //
  C.this-module (IUnknown * pControllingUnknown, aafBool doInit = AAFTrue);
  virtual ~C.this-module ();

public:
#endm



#ccccccccccccccccccccccccccc
#c
#c Types definitions should only be used by idl and c++ & impl headers
#c 
#c
#c GUID
#c Argument01: hex long  0-3[leading 0's w/o leading 0x]
#c Argument02: hex short 4-5[leading 0's w/o leading 0x]
#c Argument03: hex short 6-7[leading 0's w/o leading 0x]
#c Argument04: hex byte   8 [leading 0's w/o leading 0x]
#c Argument05: hex byte   9 [leading 0's w/o leading 0x]
#c Argument06: hex byte  10 [leading 0's w/o leading 0x]
#c Argument07: hex byte  11 [leading 0's w/o leading 0x]
#c Argument08: hex byte  12 [leading 0's w/o leading 0x]
#c Argument09: hex byte  13 [leading 0's w/o leading 0x]
#c Argument10: hex byte  14 [leading 0's w/o leading 0x]
#c Argument11: hex byte  15 [leading 0's w/o leading 0x]
#c
#c Example:
#c AD_TYPES_BEGIN(b1a21372, 1a7d, 11d2, bf, 78, 00, 10, 4b, c9, 15, 6d)
#c
#c TomR:980716: Added
#c
#startm AD_TYPES_BEGIN 11
#endm


#ccccccccccccccccccccccccccc
#c
#c Ends a types definition
#c
#c Types definitions should only be used by idl and c++ & impl headers
#c
#c Arguments: none
#c
#startm AD_TYPES_END 00
#endif // ! __C.this-module_h__
#endm


#ccccccccccccccccccccccccccc
#c
#c Inserts declaration for a method which takes no arguments.
#c
#c Argument1: method name
#c Argument2: method description
#c
#startm AD_METHOD0 02
  //***********************************************************
  //
  // %01()
  //
  // %02
  //
  STDMETHOD (%01)
     ();
#endm


#ccccccccccccccccccccccccccc
#c
#c Inserts declaration for a method which takes one argument.
#c
#c Macro Arg 01: method name
#c
#c Macro arguments 02+:
#c 
#c meth arg #   arg modfrs   obj style   type    name    arg cmnt
#c ----------   ----------   ---------   ----    ----    --------
#c metharg 1    02           03          04      05      06
#c
#c Macro Arg 07: method description
#c
#startm AD_XMETHOD1 07
  //***********************************************************
  //
  // %01()
  //
  // %07
  //
  STDMETHOD (%01) (
    // %06 
    /*%02*/ .%03-adornment%04 .%03-indirection %05);\
#endm


#ccccccccccccccccccccccccccc
#c
#c Inserts declaration for a method which takes two arguments.
#c
#c Macro Arg 01: method name
#c
#c Macro arguments 02+:
#c 
#c meth arg #   arg modfrs   obj style   type    name    arg cmnt
#c ----------   ----------   ---------   ----    ----    --------
#c metharg 1    02           03          04      05      06
#c metharg 2    07           08          09      10      11
#c
#c Macro Arg 12: method description
#c
#startm AD_XMETHOD2 12
  //***********************************************************
  //
  // %01()
  //
  // %12
  //
  STDMETHOD (%01) (
    // %06
    /*%02*/ .%03-adornment%04 .%03-indirection %05,

    // %11
    /*%07*/ .%08-adornment%09 .%08-indirection %10);\
#endm


#ccccccccccccccccccccccccccc
#c
#c Inserts declaration for a method which takes three arguments.
#c
#c Macro Arg 01: method name
#c
#c Macro arguments 02+:
#c 
#c meth arg #   arg modfrs   obj style   type    name    arg cmnt
#c ----------   ----------   ---------   ----    ----    --------
#c metharg 1    02           03          04      05      06
#c metharg 2    07           08          09      10      11
#c metharg 3    12           13          14      15      16
#c
#c Macro Arg 17: method description
#c
#startm AD_XMETHOD3 17
  //***********************************************************
  //
  // %01()
  //
  // %17
  //
  STDMETHOD (%01) (
    // %06
    /*%02*/ .%03-adornment%04 .%03-indirection %05,

    // %11
    /*%07*/ .%08-adornment%09 .%08-indirection %10,

    // %16
    /*%12*/ .%13-adornment%14 .%13-indirection %15);\
#endm


#ccccccccccccccccccccccccccc
#c
#c Inserts declaration for a method which takes four arguments.
#c
#c Macro Arg 01: method name
#c
#c Macro arguments 02+:
#c 
#c meth arg #   arg modfrs   obj style   type    name    arg cmnt
#c ----------   ----------   ---------   ----    ----    --------
#c metharg 1    02           03          04      05      06
#c metharg 2    07           08          09      10      11
#c metharg 3    12           13          14      15      16
#c metharg 4    17           18          19      20      21
#c
#c Macro Arg 22: method description
#c
#startm AD_XMETHOD4 22
  //***********************************************************
  //
  // %01()
  //
  // %22
  //
  STDMETHOD (%01) (
    // %06
    /*%02*/ .%03-adornment%04 .%03-indirection %05,

    // %11
    /*%07*/ .%08-adornment%09 .%08-indirection %10,

    // %16
    /*%12*/ .%13-adornment%14 .%13-indirection %15,

    // %21
    /*%17*/ .%18-adornment%19 .%18-indirection %20);\
#endm


#ccccccccccccccccccccccccccc
#c
#c Inserts declaration for a method which takes five arguments.
#c
#c Macro Arg 01: method name
#c
#c Macro arguments 02+:
#c 
#c meth arg #   arg modfrs   obj style   type    name    arg cmnt
#c ----------   ----------   ---------   ----    ----    --------
#c metharg 1    02           03          04      05      06
#c metharg 2    07           08          09      10      11
#c metharg 3    12           13          14      15      16
#c metharg 4    17           18          19      20      21
#c metharg 5    22           23          24      25      26
#c
#c Macro Arg 27: method description
#c
#startm AD_XMETHOD5 27
  //***********************************************************
  //
  // %01()
  //
  // %27
  //
  STDMETHOD (%01) (
    // %06
    /*%02*/ .%03-adornment%04 .%03-indirection %05,

    // %11
    /*%07*/ .%08-adornment%09 .%08-indirection %10,

    // %16
    /*%12*/ .%13-adornment%14 .%13-indirection %15,

    // %21
    /*%17*/ .%18-adornment%19 .%18-indirection %20,

    // %26
    /*%22*/ .%23-adornment%24 .%23-indirection %25);\
#endm


#ccccccccccccccccccccccccccc
#c
#c Inserts declaration for a method which takes six arguments.
#c
#c Macro Arg 01: method name
#c
#c Macro arguments 02+:
#c 
#c meth arg #   arg modfrs   obj style   type    name    arg cmnt
#c ----------   ----------   ---------   ----    ----    --------
#c metharg 1    02           03          04      05      06
#c metharg 2    07           08          09      10      11
#c metharg 3    12           13          14      15      16
#c metharg 4    17           18          19      20      21
#c metharg 5    22           23          24      25      26
#c metharg 6    27           28          29      30      31
#c
#c Macro Arg 32: method description
#c
#startm AD_XMETHOD6 32
  //***********************************************************
  //
  // %01()
  //
  // %32
  //
  STDMETHOD (%01) (
    // %06
    /*%02*/ .%03-adornment%04 .%03-indirection %05,

    // %11
    /*%07*/ .%08-adornment%09 .%08-indirection %10,

    // %16
    /*%12*/ .%13-adornment%14 .%13-indirection %15,

    // %21
    /*%17*/ .%18-adornment%19 .%18-indirection %20,

    // %26
    /*%22*/ .%23-adornment%24 .%23-indirection %25,

    // %31
    /*%27*/ .%28-adornment%29 .%28-indirection %30);\
#endm


#ccccccccccccccccccccccccccc
#c
#c Inserts declaration for a method which takes seven arguments.
#c
#c Macro Arg 01: method name
#c
#c Macro arguments 02+:
#c 
#c meth arg #   arg modfrs   obj style   type    name    arg cmnt
#c ----------   ----------   ---------   ----    ----    --------
#c metharg 1    02           03          04      05      06
#c metharg 2    07           08          09      10      11
#c metharg 3    12           13          14      15      16
#c metharg 4    17           18          19      20      21
#c metharg 5    22           23          24      25      26
#c metharg 6    27           28          29      30      31
#c metharg 7    32           33          34      35      36
#c
#c Macro Arg 37: method description
#c
#startm AD_XMETHOD7 37
  //***********************************************************
  //
  // %01()
  //
  // %37
  //
  STDMETHOD (%01) (
    // %06
    /*%02*/ .%03-adornment%04 .%03-indirection %05,

    // %11
    /*%07*/ .%08-adornment%09 .%08-indirection %10,

    // %16
    /*%12*/ .%13-adornment%14 .%13-indirection %15,

    // %21
    /*%17*/ .%18-adornment%19 .%18-indirection %20,

    // %26
    /*%22*/ .%23-adornment%24 .%23-indirection %25,

    // %31
    /*%27*/ .%28-adornment%29 .%28-indirection %30,

    // %36
    /*%32*/ .%33-adornment%34 .%33-indirection %35);\
#endm


#ccccccccccccccccccccccccccc
#c
#c Inserts declaration for a method which takes eight arguments.
#c
#c Macro Arg 01: method name
#c
#c Macro arguments 02+:
#c 
#c meth arg #   arg modfrs   obj style   type    name    arg cmnt
#c ----------   ----------   ---------   ----    ----    --------
#c metharg 1    02           03          04      05      06
#c metharg 2    07           08          09      10      11
#c metharg 3    12           13          14      15      16
#c metharg 4    17           18          19      20      21
#c metharg 5    22           23          24      25      26
#c metharg 6    27           28          29      30      31
#c metharg 7    32           33          34      35      36
#c metharg 8    37           38          39      40      41
#c
#c Macro Arg 42: method description
#c
#startm AD_XMETHOD8 42
  //***********************************************************
  //
  // %01()
  //
  // %42
  //
  STDMETHOD (%01) (
    // %06
    /*%02*/ .%03-adornment%04 .%03-indirection %05,

    // %11
    /*%07*/ .%08-adornment%09 .%08-indirection %10,

    // %16
    /*%12*/ .%13-adornment%14 .%13-indirection %15,

    // %21
    /*%17*/ .%18-adornment%19 .%18-indirection %20,

    // %26
    /*%22*/ .%23-adornment%24 .%23-indirection %25,

    // %31
    /*%27*/ .%28-adornment%29 .%28-indirection %30,

    // %36
    /*%32*/ .%33-adornment%34 .%33-indirection %35,

    // %41
    /*%37*/ .%38-adornment%39 .%38-indirection %40);\
#endm


#ccccccccccccccccccccccccccc
#c
#c Inserts declaration for a method which takes nine arguments.
#c
#c Macro Arg 01: method name
#c
#c Macro arguments 02+:
#c 
#c meth arg #   arg modfrs   obj style   type    name    arg cmnt
#c ----------   ----------   ---------   ----    ----    --------
#c metharg 1    02           03          04      05      06
#c metharg 2    07           08          09      10      11
#c metharg 3    12           13          14      15      16
#c metharg 4    17           18          19      20      21
#c metharg 5    22           23          24      25      26
#c metharg 6    27           28          29      30      31
#c metharg 7    32           33          34      35      36
#c metharg 8    37           38          39      40      41
#c metharg 9    42           43          44      45      46
#c
#c Macro Arg 47: method description
#c
#startm AD_XMETHOD9 47
  //***********************************************************
  //
  // %01()
  //
  // %47
  //
  STDMETHOD (%01) (
    // %06
    /*%02*/ .%03-adornment%04 .%03-indirection %05,

    // %11
    /*%07*/ .%08-adornment%09 .%08-indirection %10,

    // %16
    /*%12*/ .%13-adornment%14 .%13-indirection %15,

    // %21
    /*%17*/ .%18-adornment%19 .%18-indirection %20,

    // %26
    /*%22*/ .%23-adornment%24 .%23-indirection %25,

    // %31
    /*%27*/ .%28-adornment%29 .%28-indirection %30,

    // %36
    /*%32*/ .%33-adornment%34 .%33-indirection %35,

    // %41
    /*%37*/ .%38-adornment%39 .%38-indirection %40,

    // %46
    /*%42*/ .%43-adornment%44 .%43-indirection %45);\
#endm


#ccccccccccccccccccccccccccc
#c
#c Inserts declaration for a method which takes ten arguments.
#c
#c Macro Arg 01: method name
#c
#c Macro arguments 02+:
#c 
#c meth arg #   arg modfrs   obj style   type    name    arg cmnt
#c ----------   ----------   ---------   ----    ----    --------
#c metharg 1    02           03          04      05      06
#c metharg 2    07           08          09      10      11
#c metharg 3    12           13          14      15      16
#c metharg 4    17           18          19      20      21
#c metharg 5    22           23          24      25      26
#c metharg 6    27           28          29      30      31
#c metharg 7    32           33          34      35      36
#c metharg 8    37           38          39      40      41
#c metharg 9    42           43          44      45      46
#c metharg 10   47           48          49      50      51
#c
#c Macro Arg 52: method description
#c
#startm AD_XMETHOD_10 52
  //***********************************************************
  //
  // %01()
  //
  // %52
  //
  STDMETHOD (%01) (
    // %06
    /*%02*/ .%03-adornment%04 .%03-indirection %05,

    // %11
    /*%07*/ .%08-adornment%09 .%08-indirection %10,

    // %16
    /*%12*/ .%13-adornment%14 .%13-indirection %15,

    // %21
    /*%17*/ .%18-adornment%19 .%18-indirection %20,

    // %26
    /*%22*/ .%23-adornment%24 .%23-indirection %25,

    // %31
    /*%27*/ .%28-adornment%29 .%28-indirection %30,

    // %36
    /*%32*/ .%33-adornment%34 .%33-indirection %35,

    // %41
    /*%37*/ .%38-adornment%39 .%38-indirection %40,

    // %46
    /*%42*/ .%43-adornment%44 .%43-indirection %45,

    // %51
    /*%47*/ .%48-adornment%49 .%48-indirection %50);\
#endm


#ccccccccccccccccccccccccccc
#c
#c Inserts declaration for a method which takes eleven arguments.
#c
#c Macro Arg 01: method name
#c
#c Macro arguments 02+:
#c 
#c meth arg #   arg modfrs   obj style   type    name    arg cmnt
#c ----------   ----------   ---------   ----    ----    --------
#c metharg 1    02           03          04      05      06
#c metharg 2    07           08          09      10      11
#c metharg 3    12           13          14      15      16
#c metharg 4    17           18          19      20      21
#c metharg 5    22           23          24      25      26
#c metharg 6    27           28          29      30      31
#c metharg 7    32           33          34      35      36
#c metharg 8    37           38          39      40      41
#c metharg 9    42           43          44      45      46
#c metharg 10   47           48          49      50      51
#c metharg 11   52           53          54      55      56
#c
#c Macro Arg 57: method description
#c
#startm AD_XMETHOD_11 57
  //***********************************************************
  //
  // %01()
  //
  // %57
  //
  STDMETHOD (%01) (
    // %06
    /*%02*/ .%03-adornment%04 .%03-indirection %05,

    // %11
    /*%07*/ .%08-adornment%09 .%08-indirection %10,

    // %16
    /*%12*/ .%13-adornment%14 .%13-indirection %15,

    // %21
    /*%17*/ .%18-adornment%19 .%18-indirection %20,

    // %26
    /*%22*/ .%23-adornment%24 .%23-indirection %25,

    // %31
    /*%27*/ .%28-adornment%29 .%28-indirection %30,

    // %36
    /*%32*/ .%33-adornment%34 .%33-indirection %35,

    // %41
    /*%37*/ .%38-adornment%39 .%38-indirection %40,

    // %46
    /*%42*/ .%43-adornment%44 .%43-indirection %45,

    // %51
    /*%47*/ .%48-adornment%49 .%48-indirection %50,

    // %56
    /*%52*/ .%53-adornment%54 .%53-indirection %55);\
#endm


#ccccccccccccccccccccccccccc
#c
#c Inserts declaration for a method which takes three arguments.
#c Allows an additional macro argument per method argument to let
#c macro caller pass more info.  For example:
#c
#c For type           Arg is
#c     ----           ------
#c     objInArray     array size
#c     objOutArray    array size
#c     objInCustom    custom input "marshal" code
#c     objOutCustom   custom output "marshal" code
#c     all else       ignored
#c
#c Macro Arg 01: method name
#c
#c Macro arguments 02+:
#c 
#c meth arg #   arg modfrs   obj style   type    name    arg cmnt aux
#c ----------   ----------   ---------   ----    ----    -------- --
#c metharg 1    02           03          04      05      06       07
#c metharg 2    08           09          10      11      12       13
#c metharg 3    14           15          16      17      18       19
#c
#c Macro Arg 20: method description
#c
#startm AD_X2METHOD3 20
  //***********************************************************
  //
  // %01()
  //
  // %20
  //
  STDMETHOD (%01) (
    // %06
    /*%02*/ .%03-adornment%04 .%03-indirection %05,

    // %12
    /*%08*/ .%09-adornment%10 .%09-indirection %11,

    // %18
    /*%14*/ .%15-adornment%16 .%15-indirection %17);\
#endm


#ccccccccccccccccccccccccccc
#c
#c Inserts declaration for a method which takes four arguments.
#c Allows an additional macro argument per method argument to let
#c macro caller pass more info.  For example:
#c
#c For type           Arg is
#c     ----           ------
#c     objInArray     array size
#c     objOutArray    array size
#c     objInCustom    custom input "marshal" code
#c     objOutCustom   custom output "marshal" code
#c     all else       ignored
#c
#c Macro Arg 01: method name
#c
#c Macro arguments 02+:
#c 
#c meth arg #   arg modfrs   obj style   type    name    arg cmnt aux
#c ----------   ----------   ---------   ----    ----    -------- --
#c metharg 1    02           03          04      05      06       07
#c metharg 2    08           09          10      11      12       13
#c metharg 3    14           15          16      17      18       19
#c metharg 4    20           21          22      23      24       25
#c
#c Macro Arg 26: method description
#c
#startm AD_X2METHOD4 26
  //***********************************************************
  //
  // %01()
  //
  // %26
  //
  STDMETHOD (%01) (
    // %06
    /*%02*/ .%03-adornment%04 .%03-indirection %05,

    // %12
    /*%08*/ .%09-adornment%10 .%09-indirection %11,

    // %18
    /*%14*/ .%15-adornment%16 .%15-indirection %17,

    // %24
    /*%20*/ .%21-adornment%22 .%21-indirection %23);\
#endm


#ccccccccccccccccccccccccccc
#c
#c Inserts declaration for a method which takes five arguments.
#c Allows an additional macro argument per method argument to let
#c macro caller pass more info.  For example:
#c
#c For type           Arg is
#c     ----           ------
#c     objInArray     array size
#c     objPassArray   array size
#c     objOutArray    array size
#c     objInCustom    custom input "marshal" code
#c     objOutCustom   custom output "marshal" code
#c     all else       ignored
#c
#c Macro Arg 01: method name
#c
#c Macro arguments 02+:
#c 
#c meth arg #   arg modfrs   obj style   type    name    arg cmnt aux
#c ----------   ----------   ---------   ----    ----    -------- --
#c metharg 1    02           03          04      05      06       07
#c metharg 2    08           09          10      11      12       13
#c metharg 3    14           15          16      17      18       19
#c metharg 4    20           21          22      23      24       25
#c metharg 5    26           27          28      29      30       31
#c
#c Macro Arg 32: method description
#c
#startm AD_X2METHOD5 32
  //***********************************************************
  //
  // %01()
  //
  // %32
  //
  STDMETHOD (%01) (
    // %06
    /*%02*/ .%03-adornment%04 .%03-indirection %05,

    // %12
    /*%08*/ .%09-adornment%10 .%09-indirection %11,

    // %18
    /*%14*/ .%15-adornment%16 .%15-indirection %17,

    // %24
    /*%20*/ .%21-adornment%22 .%21-indirection %23,

    // %30
    /*%26*/ .%27-adornment%28 .%27-indirection %29);\
#endm


#ccccccccccccccccccccccccccc
#c
#c Ends a class definition
#c
#c Arguments: none
#c
#startm AD_CLASS_END 00

protected:
  // 
  // Declare the QI that implements for the interfaces
  // for this module. This will be called by CAAFUnknown::QueryInterface().
  // 
  STDMETHOD(InternalQueryInterface)(REFIID riid, void **ppvObjOut);


public:
  //
  // This class as concrete. All AAF objects can be constructed from
  // a CLSID. This will allow subclassing all "base-classes" by
  // aggreggation.
  // 
  AAF_DECLARE_CONCRETE();
  //
  //********
};

#endif // ! __C.this-module_h__
#endm


#ccccccccccccccccccccccccccc
#c
#c Ends a class definition for classes which support 1 more than the
#c primary COM interface.
#c
#c Arguments: additional interface name
#c
#startm AD_COM_EXT_CLASS_END 01
AD_CLASS_END\
#endm


#ccccccccccccccccccccccccccc
#c
#c Ends a class definition for classes which support 2 more than the
#c primary COM interface.
#c
#c Arguments: additional interface name
#c
#startm AD_COM_EXT2_CLASS_END 02
AD_CLASS_END\
#endm


#ccccccccccccccccccccccccccc
#c
#c Ends a class definition for AAFRoot
#c
#c Arguments: none
#c
#startm AD_ROOT_CLASS_END 00

protected:
  // 
  // Declare the QI that implements for the interfaces
  // for this module. This will be called by CAAFUnknown::QueryInterface().
  // 
  STDMETHOD(InternalQueryInterface)(REFIID riid, void **ppvObjOut);


public:
  //
  // This class as concrete. All AAF objects can be constructed from
  // a CLSID. This will allow subclassing all "base-classes" by
  // aggreggation.
  // 
  AAF_DECLARE_CONCRETE();
  //
  //********

  //
  // Return private implementation pointer for delegation.
  // NOTE: This is NOT the pointer to the COM object's implementation
  // object!
  //
  STDMETHOD(GetImplRep)(/*[retval, out]*/ void **);

  //
  // Intialize class extensions. This method is called after the
  // contained Impl object has been completely initialized. This
  // allows the aggregated extension object access to all of the
  // interfaces and property data of its controlling unknown.
  //
  STDMETHOD(InitializeExtension)(REFCLSID clsid);

protected:

  Impl.this-module * GetRepObject ();

  void InitRep (Impl.this-module * pObj);

private:

  Impl.this-module * _rep;

};


#endif // ! __C.this-module_h__
#endm


#ccccccccccccccccccccccccccc
#c
#c Specifies an overridden method
#c
#c Argument: method declaration
#c
#startm AD_OVERRIDE 01
#endm


#ccccccccccccccccccccccccccc
#c
#c Specifies a method in a separate COM interface.
#c
#c Argument: method declaration
#c
#startm AD_COM_METH 01
%01-com-meth-comh
#endm


#ccccccccccccccccccccccccccc
#c
#c Inserts declaration for a constructor which takes one argument.
#c Constructor name is assumed to be .this-module.
#c
#c Macro arguments 01+:
#c 
#c meth arg #   arg modfrs   obj style   type    name    arg cmnt
#c ----------   ----------   ---------   ----    ----    --------
#c metharg 1    01           02          03      04      05
#c
#c Macro Arg 06: method description
#c
#startm AD_XCONSTRUCTOR1 06
    C.this-module (.%02-adornment%03 .%02-indirection %04);\
#endm


#ccccccccccccccccccccccccccc
#c
#c Inserts declaration for a constructor which takes two arguments.
#c Constructor name is assumed to be .this-module.
#c
#c Macro arguments 01+:
#c 
#c meth arg #   arg modfrs   obj style   type    name    arg cmnt
#c ----------   ----------   ---------   ----    ----    --------
#c metharg 1    01           02          03      04      05
#c metharg 2    06           07          08      09      10
#c
#c Macro Arg 11: method description
#c
#startm AD_XCONSTRUCTOR2 11
    C.this-module (.%02-adornment%03 .%02-indirection %04,
        .%07-adornment%08 .%07-indirection %09);\
#endm


#ccccccccccccccccccccccccccc
#c
#c Inserts declaration for a constructor which takes three arguments.
#c Constructor name is assumed to be .this-module.
#c
#c Macro arguments 01+:
#c 
#c meth arg #   arg modfrs   obj style   type    name    arg cmnt
#c ----------   ----------   ---------   ----    ----    --------
#c metharg 1    01           02          03      04      05
#c metharg 2    06           07          08      09      10
#c metharg 3    11           12          13      14      15
#c
#c Macro Arg 16: method description
#c
#startm AD_XCONSTRUCTOR3 16
    C.this-module (.%02-adornment%03 .%02-indirection %04,
        .%07-adornment%08 .%07-indirection %09,
        .%12-adornment%13 .%12-indirection %14);\
#endm


#ccccccccccccccccccccccccccc
#c
#c Inserts declaration for a constructor which takes four arguments.
#c Constructor name is assumed to be .this-module.
#c
#c Macro arguments 01+:
#c 
#c meth arg #   arg modfrs   obj style   type    name    arg cmnt
#c ----------   ----------   ---------   ----    ----    --------
#c metharg 1    01           02          03      04      05
#c metharg 2    06           07          08      09      10
#c metharg 3    11           12          13      14      15
#c metharg 4    16           17          18      19      20
#c
#c Macro Arg 21: method description
#c
#startm AD_XCONSTRUCTOR4 21
    C.this-module (.%02-adornment%03 .%02-indirection %04,
        .%07-adornment%08 .%07-indirection %09,
        .%12-adornment%13 .%12-indirection %14,
        .%17-adornment%18 .%17-indirection %19);\
#endm


#ccccccccccccccccccccccccccc
#c
#c Argument1: text to be quoted.
#c 
#c Just pass through the input. 
#c
#c This should not actually be used since the midl compiler will normally generate
#c the associated com cpp interface file. Included here for completeness and 
#c testing puposes only.
#c
#c TomR:added 980714
#c
#startm AD_CPP_QUOTE 01
%01 \
#endm


#ccccccccccccccccccccccccccc
#c
#c Argument1: base name to be converted to output type.
#c NOTE: The \n is escaped so that the macro can be used
#c in a statement without emitting a new line.
#c
#c This should not actually be used since the midl compiler will normally generate
#c the associated com cpp interface file. Included here for completeness and 
#c testing puposes only.
#c
#c TomR:added 980714
#c
#startm AD_AAFTYPES 01
I%01 \
#endm


#ccccccccccccccccccccccccccc
#c
#c Argument1: base name to be converted to output type.
#c
#c This should not actually be used since the midl compiler will normally generate
#c the associated com cpp interface file. Included here for completeness and 
#c testing puposes only.
#c
#c TomR:added 980714
#c
#startm AD_DECLARE_FORWARD_AAFTYPES 01
#endm

#ccccccccccccccccccccccccccc
#c
#c Argument1: base name to be converted to output type.
#c
#c This is ignored since forward declarations will be created
#c by the midl generated header.
#startm AD_FORWARD_DECLARATION 01
#endm


#ccccccccccccccccccccccccccc
#c
#c Defining the interface UUID.
#c NOTE: Should be placed immediately before AD_CLASS_BEGIN
#c This symbol is generated by the midl compiler.
#c
#startm AD_DEFAULT_UUID 11
#endm


#ccccccccccccccccccccccccccc
#c
#c Defining the Class "Factory" UUID.
#c NOTE: should be placed before AD_DEFAULT_UUID or after
#c AD_CLASS_END
#c This symbol is generated by the midl compiler.
#c
#startm AD_CLASS_UUID 11
#endm


#ccccccccccccccccccccccccccc
#c
#c Inserts declaration for a static method used to bootstrap an AAF
#c session by creating the first session object.
#c
#startm AD_BEGIN_SESSION 00
#endm

#ccccccccccccccccccccccccccc
#c
#c Inserts declaration for a static method used for a container to create
#c its contained objects in the cpp API.
#c
#startm AD_STATIC_CREATE 00
#endm


#ccccccccccccccccccccccccccc
#c
#c The following macros assist in passing arguments to methods of the
#c contained implementation class:
#c
#c The objIn macros are for use with pointers to objects that are
#c passed into the method.  The Type argument is the base type, with
#c no indirection specified.  For example, if you're passing in
#c AObject*, AObject should be specified for the Type argument.#c
#c
#c The objOut macros are for use with pointers to pointers to objects
#c that are passed out of the method.  The Type argument is the base
#c type, with no indirection specified.  For example, if you're
#c passing in AObject**, AObject should be specified for the Type
#c argument.
#c
#c The objPass macros are for use with any kind of data which is
#c passed exactly into or out of the method.
#c


#startm .objIn-adornment 00
I\
#endm


#startm .objInArray-adornment 00
I\
#endm


#startm .objInArrayCustom-adornment 00
#endm


#startm .objPass-adornment 00
#endm


#startm .objOut-adornment 00
I\
#endm


#startm .objOutArray-adornment 00
I\
#endm


#startm .objOutArrayCustom-adornment 00
#endm


#ccccccccccccccccccccccccccc
#c
#c Hack to quote the .this-module macro and keep it out of export
#c files.  Do not define this macro in exp.mac!!!
#c
#startm AD_EXPORT_THIS_MODULE 00
.this-module\
#endm


#ccccccccccccccccccccccccccc
#c
#c Starts a class definition
#c
#c Argument1: Abstract or Concrete
#c Argument2: Transient or StoredObject
#c            special cases:CommonBase and StoredObjectBase
#c
#c Note: Concrete-StoredObject means Persistent. In other words
#c Concrete-StoredObject objects (and derived objects) are the 
#c only types of objects that should ever be found in an AAF
#c file.
#c
#c Valid combiniations:          examples
#c -----------------------       ---------------
#c   Abstract-CommonBase         AAFRoot 
#c   Abstract-Transient          ????
#c   Abstract-StoredObjectBase   AAFObject
#c   Abstract-StoredObject       AAFSourceReference, AAFComponent, ...
#c   Concrete-Transient          EnumAAFMobs, EnumAAFMobSlots, ...
#c   Concrete-StoredObject       AAFSegment, AAFSourceClip, ...
#c
#startm AD_XCLASS_BEGIN 02
.begin-%01-%02
#endm


#ccccccccccccccccccccccccccc
#c
#c Ends a class definition
#c
#c Argument1: Abstract or Concrete
#c Argument2: Transient or StoredObject
#c            special cases:CommonBase and StoredObjectBase
#c
#c Note: Concrete-StoredObject means Persistent. In other words
#c Concrete-StoredObject objects (and derived objects) are the 
#c only types of objects that should ever be found in an AAF
#c file.
#c
#c Valid combiniations:          examples
#c -----------------------       ---------------
#c   Abstract-CommonBase         AAFRoot 
#c   Abstract-Transient          ????
#c   Abstract-StoredObjectBase   AAFObject
#c   Abstract-StoredObject       AAFSourceReference, AAFComponent, ...
#c   Concrete-Transient          EnumAAFMobs, EnumAAFMobSlots, ...
#c   Concrete-StoredObject       AAFSegment, AAFSourceClip, ...
#c
#startm AD_XCLASS_END 02
.end-%01-%02
#endm


#ccccccccccccccccccccccccccc
#c
#c The following macros implement all of the allowable
#c combinations of the AD_XCLASS_BEGIN and AD_XCLASS_END
#c


#ccccccccccccccccccccccccccc
#c Abstract-CommonBase
#c Special case for the common base class for all AAF objects,
#c Transient and StoredObject classes.
#c (first version defined backwords compatibility)

#startm .begin-Abstract-CommonBase 00
AD_ROOT_CLASS_BEGIN\
#endm

#startm .end-Abstract-CommonBase 00
AD_ROOT_CLASS_END\
#endm


#ccccccccccccccccccccccccccc
#c Abstract-StoredObjectBase
#c Special case for the base class for all AAF stored objects
#c (first version defined backwords compatibility)

#startm .begin-Abstract-StoredObjectBase 00
AD_CLASS_BEGIN\
#endm

#startm .end-Abstract-StoredObjectBase 00

private:
  //
  // Private class to encapsulate a list of extensions.
  //
  class Extension
  {
  public:
    Extension(REFCLSID rclsid);
    ~Extension();
    
    // Return the class id of this extension.
    REFCLSID GetCLSID(void) const;

    // Set or get the next extension.
    void SetNext(Extension *next);
    Extension * GetNext(void) const;

    // Attempt to create the given plugin extension.
    HRESULT InitializeExtension(IUnknown *pControllingUnknown);

    // 
    // Declare the QI that delegates to the QI of the pExtensionUnknown.
    // 
    HRESULT QueryInterface(REFIID riid, void **ppvObjOut);

  private:
    // The next extension in the list.
    Extension *pNext;

    // The code class id for this plugin extension. This
    // value is used to make sure that we do not attempt to
    // create duplicate extension objects.
    CLSID clsid;

    // Non-deleting unknown pointer for a plugin class extension.
    IUnknown *pExtensionUnknown;

    // State flag used by this class' associated extension's
    // QueryInterface has been called. (Used to stop a possibly
    // endless QI cycle: Oobject::QI -> Extension::QI -> Object::QI.)
    bool bExtensionQueryInterfaceInProgress;
  };

  // The first extension.
  C.this-module::Extension *pExtension;

public:
  //
  // Intialize class extensions. This method is called after the
  // contained Impl object has been completely initialized. This
  // allows the aggregated extension object access to all of the
  // interfaces and property data of its controlling unknown.
  //
  STDMETHOD(InitializeExtension)(REFCLSID clsid);
AD_CLASS_END\
#endm


#ccccccccccccccccccccccccccc
#c Abstract-Transient
#c (first version defined backwords compatibility)

#startm .begin-Abstract-Transient 00
AD_CLASS_BEGIN\
#endm

#startm .end-Abstract-Transient 00
AD_CLASS_END\
#endm


#ccccccccccccccccccccccccccc
#c Abstract-StoredObject
#c (first version defined backwords compatibility)

#startm .begin-Abstract-StoredObject 00
AD_CLASS_BEGIN\
#endm

#startm .end-Abstract-StoredObject 00
AD_CLASS_END\
#endm


#ccccccccccccccccccccccccccc
#c Concrete-Transient
#c (first version defined backwords compatibility)

#startm .begin-Concrete-Transient 00
AD_CLASS_BEGIN\
#endm

#startm .end-Concrete-Transient 00
AD_CLASS_END\
#endm


#ccccccccccccccccccccccccccc
#c Concrete-StoredObject
#c Note: These are the persistent classes.
#c (first version defined backwords compatibility)

#startm .begin-Concrete-StoredObject 00
AD_CLASS_BEGIN\
#endm

#startm .end-Concrete-StoredObject 00
AD_CLASS_END\
#endm



#ccccccccccccccccccccccccccc
#c
#c COMH 
#c Declaration for the dictionary's factory method.
#c
#startm AD_DICTIONARY_FACTORY 02
  // %02 
  STDMETHOD (%01)
   (// Class definition of the stored object to be created.
    /*[in]*/ IAAFClassDef * pClassDef,

    // Reference to the identifier of the interface
    /*[in, ref]*/ REFIID riid,

    // Address of output variable that receives the 
    // interface pointer requested in riid
    /*[out, iid_is(riid)]*/ IUnknown ** ppvObject);
#endm


#ccccccccccccccccccccccccccc
#c
#c Some standard comment macros for use where APIs are commented
#c
#startm AD_STD_COMMENT_METH_ERR_NULL_PARAM 01
  // AAFRESULT_NULL_PARAM
  //   - %01 arg is NULL.
  //\
#endm

#startm AD_STD_COMMENT_METH_ERR_NO_INIT 00
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //\
#endm

#startm AD_STD_COMMENT_METH_ERR_ALREADY_INIT 00
  // AAFRESULT_ALREADY_INITIALIZED
  //   - This object has already had Initialize() called on it.
  //\
#endm

#startm AD_STD_COMMENT_METH_ERR_HEADER 00
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //\
#endm

#startm AD_STD_COMMENT_IFC_HEADER 00
// In addition to the specific error results listed for each method,
// all methods in this interface may also return one of the following
// values:
// 
// AAFRESULT_NOMEMORY
//   - insufficient system memory is available to perform the
//     operation.
//\
#endm

#startm AD_STD_COMMENT_IFC_INIT 00
// AAFRESULT_NOT_INITIALIZED
//   - This object has not yet had Initialize() called on it through
//     this object's primary interface.  Note that IAAFObject is a
//     primary interface for an abstract class, so it is not
//     appropriate for the Initialize() method to exist in this
//     interface.  The Initialize() method is available through the
//     concrete object's primary interface.
//\
#endm

#startm AD_STD_COMMENT_METH_STUB 00
  // NOTE! Stub only.   Implementation not yet added.
  //
#endm

#startm AD_STD_COMMENT_IFC_STUB 00
/***********************************************\\
*   Stub only.   Implementation not yet added   *
\\***********************************************/\
#endm

#startm AD_STD_COMMENT_METH_ADDREF 01
  // *%01 is AddRef()ed before it is returned.
  //\
#endm


#ccccccccccccccccccccccccccc
#c Begining of the module definitions
#c
#startm AD_MODULE_BEGIN 02
#endm


#ccccccccccccccccccccccccccc
#c End of the module definitions
#c
#startm AD_MODULE_END 00
#endm


#ccccccccccccccccccccccccccc
#c
#c Inserts declaration for a function which takes no arguments.
#c
#c Argument1: function name
#c Argument2: function description
#c
#startm AD_FUNCTION0 02
#endm


#ccccccccccccccccccccccccccc
#c
#c Inserts declaration for a function which takes one argument.
#c
#c Macro Arg 01: function name
#c
#c Macro arguments 02+:
#c 
#c meth arg #   arg modfrs   obj style   type    name    arg cmnt	
#c ----------   ----------   ---------   ----    ----    --------
#c metharg 1    02           03          04      05      06
#c
#c Macro Arg 07: function description
#c
#startm AD_XFUNCTION1 07
#endm


#ccccccccccccccccccccccccccc
#c
#c Inserts declaration for a function which takes two arguments.
#c
#c Macro Arg 01: function name
#c
#c Macro arguments 02+:
#c 
#c meth arg #   arg modfrs   obj style   type    name    arg cmnt
#c ----------   ----------   ---------   ----    ----    --------
#c metharg 1    02           03          04      05      06
#c metharg 2    07           08          09      10      11
#c
#c Macro Arg 12: function description
#c
#startm AD_XFUNCTION2 12
#endm


#ccccccccccccccccccccccccccc
#c
#c Inserts declaration for a function which takes three arguments.
#c
#c Macro Arg 01: function name
#c
#c Macro arguments 02+:
#c 
#c meth arg #   arg modfrs   obj style   type    name    arg cmnt
#c ----------   ----------   ---------   ----    ----    --------
#c metharg 1    02           03          04      05      06
#c metharg 2    07           08          09      10      11
#c metharg 3    12           13          14      15      16
#c
#c Macro Arg 17: function description
#c
#startm AD_XFUNCTION3 17
#endm


#ccccccccccccccccccccccccccc
#c
#c Inserts declaration for a function which takes four arguments.
#c
#c Macro Arg 01: function name
#c
#c Macro arguments 02+:
#c 
#c meth arg #   arg modfrs   obj style   type    name    arg cmnt
#c ----------   ----------   ---------   ----    ----    --------
#c metharg 1    02           03          04      05      06
#c metharg 2    07           08          09      10      11
#c metharg 3    12           13          14      15      16
#c metharg 4    17           18          19      20      21
#c
#c Macro Arg 22: function description
#c
#startm AD_XFUNCTION4 22
#endm


#ccccccccccccccccccccccccccc
#c
#c macro for things which are not to be exported.
#c
#startm AD_NO_EXPORT 01
%01\
#endm
