#c /***********************************************\
#c *                                               *
#c * Advanced Authoring Format                     *
#c *                                               *
#c * Copyright (c) 1998-1999 Avid Technology, Inc. *
#c *                                               *
#c \***********************************************/

#ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
#c
#c AutoDodo macro file for use in generating COM API implementation
#c C++ files.
#c
#ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


#import macros/base.mac


#ccccccccccccccccccccccccccc
#c
#c Pass through argument if for idl otherwise omit it.
#c 
#c This macro is generally used to specify IDL options that would
#c make since to emit to c++.
#c To allow proper marshalling code generation of a struct: |
#c typedef struct
#c {
#c     aafInt32 length;
#c     AD_IDL([length_is(length)]) aafWchar *str;
#c } aafString_t;
#c
#startm AD_IDL 01
#endm


#ccccccccccccccccccccccccccc
#c
#c Includes another file.
#c
#c Argument: Base filename
#c
#c Note: it is not necessary to expand it here, since it was already
#c included in this module's header file.
#c
#startm AD_INCLUDE 01
#endm


#ccccccccccccccccccccccccccc
#c
#c Goes at the head of the file.
#c
#c Arguments: none
#c
#startm AD_HEAD 00
/***********************************************************************
*
*              Copyright (c) 1998-1999 Avid Technology, Inc.
*
* Permission to use, copy and modify this software and accompanying
* documentation, and to distribute and sublicense application software
* incorporating this software for any purpose is hereby granted,
* provided that (i) the above copyright notice and this permission
* notice appear in all copies of the software and related documentation,
* and (ii) the name Avid Technology, Inc. may not be used in any
* advertising or publicity relating to the software without the specific,
*  prior written permission of Avid Technology, Inc.
*
* THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND,
* EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY
* WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.
* IN NO EVENT SHALL AVID TECHNOLOGY, INC. BE LIABLE FOR ANY DIRECT,
* SPECIAL, INCIDENTAL, PUNITIVE, INDIRECT, ECONOMIC, CONSEQUENTIAL OR
* OTHER DAMAGES OF ANY KIND, OR ANY DAMAGES WHATSOEVER ARISING OUT OF
* OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE AND
* ACCOMPANYING DOCUMENTATION, INCLUDING, WITHOUT LIMITATION, DAMAGES
* RESULTING FROM LOSS OF USE, DATA OR PROFITS, AND WHETHER OR NOT
* ADVISED OF THE POSSIBILITY OF DAMAGE, REGARDLESS OF THE THEORY OF
* LIABILITY.
*
************************************************************************/


#include "C.this-module.h"
#include "Impl.this-module.h"
#include "AAFResult.h"
#include "CAAFEnumValidation.h"

class OMAssertionViolation;

#include <assert.h>
#endm


#ccccccccccccccccccccccccccc
#c
#c AAFTypes support for IDL
#c
#c Arguments: none
#c
#startm AD_TYPES_HEAD 00
#endm


#ccccccccccccccccccccccccccc
#c
#c Starts a class definition
#c
#c Arguments: none
#c
#startm AD_CLASS_BEGIN 00


C.this-module::C.this-module (IUnknown * pControllingUnknown, aafBool doInit)
  : C.parent-module (pControllingUnknown, kAAFFalse)
{
  if (doInit)
    {
      Impl.this-module * newRep;
      newRep = new Impl.this-module;
      assert (newRep);
      InitRep (newRep);
    }
}


C.this-module::~C.this-module ()
{
}
#endm


#ccccccccccccccccccccccccccc
#c
#c Starts a class definition for classes which support 1 more than the
#c primary COM interface.
#c
#c Arguments: additional interface name
#c
#startm AD_COM_EXT_CLASS_BEGIN 01
AD_CLASS_BEGIN\
#endm

#ccccccccccccccccccccccccccc
#c
#c Starts a class definition for classes which support 2 more than the
#c primary COM interface.
#c
#c Arguments: additional interface name
#c
#startm AD_COM_EXT2_CLASS_BEGIN 02
AD_CLASS_BEGIN\
#endm


#ccccccccccccccccccccccccccc
#c
#c Starts a class definition with no parent class
#c
#c Arguments: none
#c
#startm AD_ROOT_CLASS_BEGIN 00
C.this-module::C.this-module (IUnknown * pControllingUnknown, aafBool /*doInit*/)
  : CAAFUnknown(pControllingUnknown),
    _rep(NULL)
{}


C.this-module::~C.this-module ()
{
  // The base class destructor of Impl.this-module must be declared as virtual.
  // Eventhough the Impl.this-module is reference counted we call delete 
  // directly since the Impl.this-module::ReleaseReference() delegates its
  // release to C.this-module::Release().
  if (_rep)
  {
    delete _rep;
    _rep = NULL;
  } 
}


void C.this-module::InitRep (Impl.this-module * newRep)
{
  assert (newRep);
  assert (!_rep);
  _rep = newRep;
  newRep->InitContainer (this);
}


Impl.this-module * C.this-module::GetRepObject ()
{
  assert (_rep);
  return _rep;
}
#endm

#ccccccccccccccccccccccccccc
#c
#c Types definitions should only be used by idl and c++ & impl headers
#c 
#c
#c GUID
#c Argument01: hex long  0-3[leading 0's w/o leading 0x]
#c Argument02: hex short 4-5[leading 0's w/o leading 0x]
#c Argument03: hex short 6-7[leading 0's w/o leading 0x]
#c Argument04: hex byte   8 [leading 0's w/o leading 0x]
#c Argument05: hex byte   9 [leading 0's w/o leading 0x]
#c Argument06: hex byte  10 [leading 0's w/o leading 0x]
#c Argument07: hex byte  11 [leading 0's w/o leading 0x]
#c Argument08: hex byte  12 [leading 0's w/o leading 0x]
#c Argument09: hex byte  13 [leading 0's w/o leading 0x]
#c Argument10: hex byte  14 [leading 0's w/o leading 0x]
#c Argument11: hex byte  15 [leading 0's w/o leading 0x]
#c
#c Example:
#c AD_TYPES_BEGIN(b1a21372, 1a7d, 11d2, bf, 78, 00, 10, 4b, c9, 15, 6d)
#c
#c TomR:980716: Added
#c
#startm AD_TYPES_BEGIN 11
#endm


#ccccccccccccccccccccccccccc
#c
#c Ends a types definition
#c
#c Types definitions should only be used by idl and c++ & impl headers
#c
#c Arguments: none
#c
#startm AD_TYPES_END 00
#endm


#ccccccccccccccccccccccccccc
#c
#c Insers code to start a catch handler to pick up uncaught exceptions
#c
#c Types definitions should only be used by idl and c++ & impl headers
#c
#c Arguments: none
#c
#startm AD_CATCH_ASSERTION_BEGIN 00
  try
    {
    \
#endm


#ccccccccccccccccccccccccccc
#c
#c Insers code to end a catch handler to pick up uncaught exceptions
#c
#c Types definitions should only be used by idl and c++ & impl headers
#c
#c Arguments: none
#c
#startm AD_CATCH_ASSERTION_END 00
    }
  catch (OMAssertionViolation &)
    {
      // Control reaches here if there is a programming error in the
      // impl code that was detected by an assertion violation.
      // We must not allow the assertion to reach the client code so
      // here we turn it into a failure status code.
      //
      hr = AAFRESULT_ASSERTION_VIOLATION;
    }
  catch (...)
    {
      // We CANNOT throw an exception out of a COM interface method!
      // Return a reasonable exception code.
      //
      hr = AAFRESULT_UNEXPECTED_EXCEPTION;
    }
#endm


#ccccccccccccccccccccccccccc
#c
#c Inserts declaration for a method which takes no arguments.
#c
#c Argument1: method name
#c Argument2: method description
#c
#startm AD_METHOD0 02
HRESULT STDMETHODCALLTYPE
    C.this-module::%01 ()
{
  Impl.this-module * ptr;
  ImplAAFRoot * pO;
  pO = GetRepObject ();
  assert (pO);
  ptr = static_cast<Impl.this-module*> (pO);
  assert (ptr);
  HRESULT hr;

AD_CATCH_ASSERTION_BEGIN\
  hr = ptr->%01();
AD_CATCH_ASSERTION_END
  return hr;
}
#endm


#ccccccccccccccccccccccccccc
#c
#c Inserts declaration for a method which takes one argument.
#c
#c Macro Arg 01: method name
#c
#c Macro arguments 02+:
#c 
#c meth arg #   arg modfrs   obj style   type    name    arg cmnt	
#c ----------   ----------   ---------   ----    ----    --------
#c metharg 1    02           03          04      05      06
#c
#c Macro Arg 07: method description
#c
#startm AD_XMETHOD1 07
HRESULT STDMETHODCALLTYPE
    C.this-module::%01 (.%03-adornment%04 .%03-indirection %05)
{
  HRESULT hr;

  Impl.this-module * ptr;
  ImplAAFRoot * pO;
  pO = GetRepObject ();
  assert (pO);
  ptr = static_cast<Impl.this-module*> (pO);
  assert (ptr);

.%03-setup(%04, %05, foo, bar)\

AD_CATCH_ASSERTION_BEGIN\
  hr = ptr->%01
       (.%03-internalname(%05));
AD_CATCH_ASSERTION_END
.%03-cleanup(%04, %05, foo, bar)\
  return hr;
}
#endm


#ccccccccccccccccccccccccccc
#c
#c Inserts declaration for a method which takes two arguments.
#c
#c Macro Arg 01: method name
#c
#c Macro arguments 02+:
#c 
#c meth arg #   arg modfrs   obj style   type    name    arg cmnt
#c ----------   ----------   ---------   ----    ----    --------
#c metharg 1    02           03          04      05      06
#c metharg 2    07           08          09      10      11
#c
#c Macro Arg 12: method description
#c
#startm AD_XMETHOD2 12
HRESULT STDMETHODCALLTYPE
    C.this-module::%01 (.%03-adornment%04 .%03-indirection %05,
        .%08-adornment%09 .%08-indirection %10)
{
  HRESULT hr;

  Impl.this-module * ptr;
  ImplAAFRoot * pO;
  pO = GetRepObject ();
  assert (pO);
  ptr = static_cast<Impl.this-module*> (pO);
  assert (ptr);

.%03-setup(%04, %05, foo, bar)\
.%08-setup(%09, %10, foo, bar)\

AD_CATCH_ASSERTION_BEGIN\
  hr = ptr->%01
       (.%03-internalname(%05),
        .%08-internalname(%10));
AD_CATCH_ASSERTION_END
.%03-cleanup(%04, %05, foo, bar)\
.%08-cleanup(%09, %10, foo, bar)\
  return hr;
}
#endm


#ccccccccccccccccccccccccccc
#c
#c Inserts declaration for a method which takes three arguments.
#c
#c Macro Arg 01: method name
#c
#c Macro arguments 02+:
#c 
#c meth arg #   arg modfrs   obj style   type    name    arg cmnt
#c ----------   ----------   ---------   ----    ----    --------
#c metharg 1    02           03          04      05      06
#c metharg 2    07           08          09      10      11
#c metharg 3    12           13          14      15      16
#c
#c Macro Arg 17: method description
#c
#startm AD_XMETHOD3 17
HRESULT STDMETHODCALLTYPE
    C.this-module::%01 (.%03-adornment%04 .%03-indirection %05,
        .%08-adornment%09 .%08-indirection %10,
        .%13-adornment%14 .%13-indirection %15)
{
  HRESULT hr;

  Impl.this-module * ptr;
  ImplAAFRoot * pO;
  pO = GetRepObject ();
  assert (pO);
  ptr = static_cast<Impl.this-module*> (pO);
  assert (ptr);

.%03-setup(%04, %05, foo, bar)\
.%08-setup(%09, %10, foo, bar)\
.%13-setup(%14, %15, foo, bar)\

AD_CATCH_ASSERTION_BEGIN\
  hr = ptr->%01
       (.%03-internalname(%05),
        .%08-internalname(%10),
        .%13-internalname(%15));
AD_CATCH_ASSERTION_END
.%03-cleanup(%04, %05, foo, bar)\
.%08-cleanup(%09, %10, foo, bar)\
.%13-cleanup(%14, %15, foo, bar)\
  return hr;
}
#endm


#ccccccccccccccccccccccccccc
#c
#c Inserts declaration for a method which takes four arguments.
#c
#c Macro Arg 01: method name
#c
#c Macro arguments 02+:
#c 
#c meth arg #   arg modfrs   obj style   type    name    arg cmnt
#c ----------   ----------   ---------   ----    ----    --------
#c metharg 1    02           03          04      05      06
#c metharg 2    07           08          09      10      11
#c metharg 3    12           13          14      15      16
#c metharg 4    17           18          19      20      21
#c
#c Macro Arg 22: method description
#c
#startm AD_XMETHOD4 22
HRESULT STDMETHODCALLTYPE
    C.this-module::%01 (.%03-adornment%04 .%03-indirection %05,
        .%08-adornment%09 .%08-indirection %10,
        .%13-adornment%14 .%13-indirection %15,
        .%18-adornment%19 .%18-indirection %20)
{
  HRESULT hr;

  Impl.this-module * ptr;
  ImplAAFRoot * pO;
  pO = GetRepObject ();
  assert (pO);
  ptr = static_cast<Impl.this-module*> (pO);
  assert (ptr);

.%03-setup(%04, %05, foo, bar)\
.%08-setup(%09, %10, foo, bar)\
.%13-setup(%14, %15, foo, bar)\
.%18-setup(%19, %20, foo, bar)\

AD_CATCH_ASSERTION_BEGIN\
  hr = ptr->%01
       (.%03-internalname(%05),
        .%08-internalname(%10),
        .%13-internalname(%15),
        .%18-internalname(%20));
AD_CATCH_ASSERTION_END
.%03-cleanup(%04, %05, foo, bar)\
.%08-cleanup(%09, %10, foo, bar)\
.%13-cleanup(%14, %15, foo, bar)\
.%18-cleanup(%19, %20, foo, bar)\
  return hr;
}
#endm


#ccccccccccccccccccccccccccc
#c
#c Inserts declaration for a method which takes five arguments.
#c
#c Macro Arg 01: method name
#c
#c Macro arguments 02+:
#c 
#c meth arg #   arg modfrs   obj style   type    name    arg cmnt
#c ----------   ----------   ---------   ----    ----    --------
#c metharg 1    02           03          04      05      06
#c metharg 2    07           08          09      10      11
#c metharg 3    12           13          14      15      16
#c metharg 4    17           18          19      20      21
#c metharg 5    22           23          24      25      26
#c
#c Macro Arg 27: method description
#c
#startm AD_XMETHOD5 27
HRESULT STDMETHODCALLTYPE
    C.this-module::%01 (.%03-adornment%04 .%03-indirection %05,
        .%08-adornment%09 .%08-indirection %10,
        .%13-adornment%14 .%13-indirection %15,
        .%18-adornment%19 .%18-indirection %20,
        .%23-adornment%24 .%23-indirection %25)
{
  HRESULT hr;

  Impl.this-module * ptr;
  ImplAAFRoot * pO;
  pO = GetRepObject ();
  assert (pO);
  ptr = static_cast<Impl.this-module*> (pO);
  assert (ptr);

.%03-setup(%04, %05, foo, bar)\
.%08-setup(%09, %10, foo, bar)\
.%13-setup(%14, %15, foo, bar)\
.%18-setup(%19, %20, foo, bar)\
.%23-setup(%24, %25, foo, bar)\

AD_CATCH_ASSERTION_BEGIN\
  hr = ptr->%01
       (.%03-internalname(%05),
        .%08-internalname(%10),
        .%13-internalname(%15),
        .%18-internalname(%20),
        .%23-internalname(%25));
AD_CATCH_ASSERTION_END
.%03-cleanup(%04, %05, foo, bar)\
.%08-cleanup(%09, %10, foo, bar)\
.%13-cleanup(%14, %15, foo, bar)\
.%18-cleanup(%19, %20, foo, bar)\
.%23-cleanup(%24, %25, foo, bar)\
  return hr;
}
#endm


#ccccccccccccccccccccccccccc
#c
#c Inserts declaration for a method which takes six arguments.
#c
#c Macro Arg 01: method name
#c
#c Macro arguments 02+:
#c 
#c meth arg #   arg modfrs   obj style   type    name    arg cmnt
#c ----------   ----------   ---------   ----    ----    --------
#c metharg 1    02           03          04      05      06
#c metharg 2    07           08          09      10      11
#c metharg 3    12           13          14      15      16
#c metharg 4    17           18          19      20      21
#c metharg 5    22           23          24      25      26
#c metharg 6    27           28          29      30      31
#c
#c Macro Arg 32: method description
#c
#startm AD_XMETHOD6 32
HRESULT STDMETHODCALLTYPE
    C.this-module::%01 (.%03-adornment%04 .%03-indirection %05,
        .%08-adornment%09 .%08-indirection %10,
        .%13-adornment%14 .%13-indirection %15,
        .%18-adornment%19 .%18-indirection %20,
        .%23-adornment%24 .%23-indirection %25,
        .%28-adornment%29 .%28-indirection %30)
{
  HRESULT hr;

  Impl.this-module * ptr;
  ImplAAFRoot * pO;
  pO = GetRepObject ();
  assert (pO);
  ptr = static_cast<Impl.this-module*> (pO);
  assert (ptr);

.%03-setup(%04, %05, foo, bar)\
.%08-setup(%09, %10, foo, bar)\
.%13-setup(%14, %15, foo, bar)\
.%18-setup(%19, %20, foo, bar)\
.%23-setup(%24, %25, foo, bar)\
.%28-setup(%29, %30, foo, bar)\

AD_CATCH_ASSERTION_BEGIN\
  hr = ptr->%01
       (.%03-internalname(%05),
        .%08-internalname(%10),
        .%13-internalname(%15),
        .%18-internalname(%20),
        .%23-internalname(%25),
        .%28-internalname(%30));
AD_CATCH_ASSERTION_END
.%03-cleanup(%04, %05, foo, bar)\
.%08-cleanup(%09, %10, foo, bar)\
.%13-cleanup(%14, %15, foo, bar)\
.%18-cleanup(%19, %20, foo, bar)\
.%23-cleanup(%24, %25, foo, bar)\
.%28-cleanup(%29, %30, foo, bar)\
  return hr;
}
#endm


#ccccccccccccccccccccccccccc
#c
#c Inserts declaration for a method which takes seven arguments.
#c
#c Macro Arg 01: method name
#c
#c Macro arguments 02+:
#c 
#c meth arg #   arg modfrs   obj style   type    name    arg cmnt
#c ----------   ----------   ---------   ----    ----    --------
#c metharg 1    02           03          04      05      06
#c metharg 2    07           08          09      10      11
#c metharg 3    12           13          14      15      16
#c metharg 4    17           18          19      20      21
#c metharg 5    22           23          24      25      26
#c metharg 6    27           28          29      30      31
#c metharg 7    32           33          34      35      36
#c
#c Macro Arg 37: method description
#c
#startm AD_XMETHOD7 37
HRESULT STDMETHODCALLTYPE
    C.this-module::%01 (.%03-adornment%04 .%03-indirection %05,
        .%08-adornment%09 .%08-indirection %10,
        .%13-adornment%14 .%13-indirection %15,
        .%18-adornment%19 .%18-indirection %20,
        .%23-adornment%24 .%23-indirection %25,
        .%28-adornment%29 .%28-indirection %30,
        .%33-adornment%34 .%33-indirection %35)
{
  HRESULT hr;

  Impl.this-module * ptr;
  ImplAAFRoot * pO;
  pO = GetRepObject ();
  assert (pO);
  ptr = static_cast<Impl.this-module*> (pO);
  assert (ptr);

.%03-setup(%04, %05, foo, bar)\
.%08-setup(%09, %10, foo, bar)\
.%13-setup(%14, %15, foo, bar)\
.%18-setup(%19, %20, foo, bar)\
.%23-setup(%24, %25, foo, bar)\
.%28-setup(%29, %30, foo, bar)\
.%33-setup(%34, %35, foo, bar)\

AD_CATCH_ASSERTION_BEGIN\
  hr = ptr->%01
       (.%03-internalname(%05),
        .%08-internalname(%10),
        .%13-internalname(%15),
        .%18-internalname(%20),
        .%23-internalname(%25),
        .%28-internalname(%30),
        .%33-internalname(%35));
AD_CATCH_ASSERTION_END
.%03-cleanup(%04, %05, foo, bar)\
.%08-cleanup(%09, %10, foo, bar)\
.%13-cleanup(%14, %15, foo, bar)\
.%18-cleanup(%19, %20, foo, bar)\
.%23-cleanup(%24, %25, foo, bar)\
.%28-cleanup(%29, %30, foo, bar)\
.%33-cleanup(%34, %35, foo, bar)\
  return hr;
}
#endm


#ccccccccccccccccccccccccccc
#c
#c Inserts declaration for a method which takes eight arguments.
#c
#c Macro Arg 01: method name
#c
#c Macro arguments 02+:
#c 
#c meth arg #   arg modfrs   obj style   type    name    arg cmnt
#c ----------   ----------   ---------   ----    ----    --------
#c metharg 1    02           03          04      05      06
#c metharg 2    07           08          09      10      11
#c metharg 3    12           13          14      15      16
#c metharg 4    17           18          19      20      21
#c metharg 5    22           23          24      25      26
#c metharg 6    27           28          29      30      31
#c metharg 7    32           33          34      35      36
#c metharg 8    37           38          39      40      41
#c
#c Macro Arg 42: method description
#c
#startm AD_XMETHOD8 42
HRESULT STDMETHODCALLTYPE
    C.this-module::%01 (.%03-adornment%04 .%03-indirection %05,
        .%08-adornment%09 .%08-indirection %10,
        .%13-adornment%14 .%13-indirection %15,
        .%18-adornment%19 .%18-indirection %20,
        .%23-adornment%24 .%23-indirection %25,
        .%28-adornment%29 .%28-indirection %30,
        .%33-adornment%34 .%33-indirection %35,
        .%38-adornment%39 .%38-indirection %40)
{
  HRESULT hr;

  Impl.this-module * ptr;
  ImplAAFRoot * pO;
  pO = GetRepObject ();
  assert (pO);
  ptr = static_cast<Impl.this-module*> (pO);
  assert (ptr);

.%03-setup(%04, %05, foo, bar)\
.%08-setup(%09, %10, foo, bar)\
.%13-setup(%14, %15, foo, bar)\
.%18-setup(%19, %20, foo, bar)\
.%23-setup(%24, %25, foo, bar)\
.%28-setup(%29, %30, foo, bar)\
.%33-setup(%34, %35, foo, bar)\
.%38-setup(%39, %40, foo, bar)\

AD_CATCH_ASSERTION_BEGIN\
  hr = ptr->%01
       (.%03-internalname(%05),
        .%08-internalname(%10),
        .%13-internalname(%15),
        .%18-internalname(%20),
        .%23-internalname(%25),
        .%28-internalname(%30),
        .%33-internalname(%35),
        .%38-internalname(%40));
AD_CATCH_ASSERTION_END
.%03-cleanup(%04, %05, foo, bar)\
.%08-cleanup(%09, %10, foo, bar)\
.%13-cleanup(%14, %15, foo, bar)\
.%18-cleanup(%19, %20, foo, bar)\
.%23-cleanup(%24, %25, foo, bar)\
.%28-cleanup(%29, %30, foo, bar)\
.%33-cleanup(%34, %35, foo, bar)\
.%38-cleanup(%39, %40, foo, bar)\
  return hr;
}
#endm


#ccccccccccccccccccccccccccc
#c
#c Inserts declaration for a method which takes nine arguments.
#c
#c Macro Arg 01: method name
#c
#c Macro arguments 02+:
#c 
#c meth arg #   arg modfrs   obj style   type    name    arg cmnt
#c ----------   ----------   ---------   ----    ----    --------
#c metharg 1    02           03          04      05      06
#c metharg 2    07           08          09      10      11
#c metharg 3    12           13          14      15      16
#c metharg 4    17           18          19      20      21
#c metharg 5    22           23          24      25      26
#c metharg 6    27           28          29      30      31
#c metharg 7    32           33          34      35      36
#c metharg 8    37           38          39      40      41
#c metharg 9    42           43          44      45      46
#c
#c Macro Arg 47: method description
#c
#startm AD_XMETHOD9 47
HRESULT STDMETHODCALLTYPE
    C.this-module::%01 (.%03-adornment%04 .%03-indirection %05,
        .%08-adornment%09 .%08-indirection %10,
        .%13-adornment%14 .%13-indirection %15,
        .%18-adornment%19 .%18-indirection %20,
        .%23-adornment%24 .%23-indirection %25,
        .%28-adornment%29 .%28-indirection %30,
        .%33-adornment%34 .%33-indirection %35,
        .%38-adornment%39 .%38-indirection %40,
        .%43-adornment%44 .%43-indirection %45)
{
  HRESULT hr;

  Impl.this-module * ptr;
  ImplAAFRoot * pO;
  pO = GetRepObject ();
  assert (pO);
  ptr = static_cast<Impl.this-module*> (pO);
  assert (ptr);

.%03-setup(%04, %05, foo, bar)\
.%08-setup(%09, %10, foo, bar)\
.%13-setup(%14, %15, foo, bar)\
.%18-setup(%19, %20, foo, bar)\
.%23-setup(%24, %25, foo, bar)\
.%28-setup(%29, %30, foo, bar)\
.%33-setup(%34, %35, foo, bar)\
.%38-setup(%39, %40, foo, bar)\
.%43-setup(%44, %45, foo, bar)\

AD_CATCH_ASSERTION_BEGIN\
  hr = ptr->%01
       (.%03-internalname(%05),
        .%08-internalname(%10),
        .%13-internalname(%15),
        .%18-internalname(%20),
        .%23-internalname(%25),
        .%28-internalname(%30),
        .%33-internalname(%35),
        .%38-internalname(%40),
        .%43-internalname(%45));
AD_CATCH_ASSERTION_END
.%03-cleanup(%04, %05, foo, bar)\
.%08-cleanup(%09, %10, foo, bar)\
.%13-cleanup(%14, %15, foo, bar)\
.%18-cleanup(%19, %20, foo, bar)\
.%23-cleanup(%24, %25, foo, bar)\
.%28-cleanup(%29, %30, foo, bar)\
.%33-cleanup(%34, %35, foo, bar)\
.%38-cleanup(%39, %40, foo, bar)\
.%43-cleanup(%44, %45, foo, bar)\
  return hr;
}
#endm


#ccccccccccccccccccccccccccc
#c
#c Inserts declaration for a method which takes ten arguments.
#c
#c Macro Arg 01: method name
#c
#c Macro arguments 02+:
#c 
#c meth arg #   arg modfrs   obj style   type    name    arg cmnt
#c ----------   ----------   ---------   ----    ----    --------
#c metharg 1    02           03          04      05      06
#c metharg 2    07           08          09      10      11
#c metharg 3    12           13          14      15      16
#c metharg 4    17           18          19      20      21
#c metharg 5    22           23          24      25      26
#c metharg 6    27           28          29      30      31
#c metharg 7    32           33          34      35      36
#c metharg 8    37           38          39      40      41
#c metharg 9    42           43          44      45      46
#c metharg 10   47           48          49      50      51
#c
#c Macro Arg 52: method description
#c
#startm AD_XMETHOD_10 52
HRESULT STDMETHODCALLTYPE
    C.this-module::%01 (.%03-adornment%04 .%03-indirection %05,
        .%08-adornment%09 .%08-indirection %10,
        .%13-adornment%14 .%13-indirection %15,
        .%18-adornment%19 .%18-indirection %20,
        .%23-adornment%24 .%23-indirection %25,
        .%28-adornment%29 .%28-indirection %30,
        .%33-adornment%34 .%33-indirection %35,
        .%38-adornment%39 .%38-indirection %40,
        .%43-adornment%44 .%43-indirection %45,
        .%48-adornment%49 .%48-indirection %50)
{
  HRESULT hr;

  Impl.this-module * ptr;
  ImplAAFRoot * pO;
  pO = GetRepObject ();
  assert (pO);
  ptr = static_cast<Impl.this-module*> (pO);
  assert (ptr);

.%03-setup(%04, %05, foo, bar)\
.%08-setup(%09, %10, foo, bar)\
.%13-setup(%14, %15, foo, bar)\
.%18-setup(%19, %20, foo, bar)\
.%23-setup(%24, %25, foo, bar)\
.%28-setup(%29, %30, foo, bar)\
.%33-setup(%34, %35, foo, bar)\
.%38-setup(%39, %40, foo, bar)\
.%43-setup(%44, %45, foo, bar)\
.%48-setup(%49, %50, foo, bar)\

AD_CATCH_ASSERTION_BEGIN\
  hr = ptr->%01
       (.%03-internalname(%05),
        .%08-internalname(%10),
        .%13-internalname(%15),
        .%18-internalname(%20),
        .%23-internalname(%25),
        .%28-internalname(%30),
        .%33-internalname(%35),
        .%38-internalname(%40),
        .%43-internalname(%45),
        .%48-internalname(%50));
AD_CATCH_ASSERTION_END
.%03-cleanup(%04, %05, foo, bar)\
.%08-cleanup(%09, %10, foo, bar)\
.%13-cleanup(%14, %15, foo, bar)\
.%18-cleanup(%19, %20, foo, bar)\
.%23-cleanup(%24, %25, foo, bar)\
.%28-cleanup(%29, %30, foo, bar)\
.%33-cleanup(%34, %35, foo, bar)\
.%38-cleanup(%39, %40, foo, bar)\
.%43-cleanup(%44, %45, foo, bar)\
.%48-cleanup(%49, %50, foo, bar)\
  return hr;
}
#endm


#ccccccccccccccccccccccccccc
#c
#c Inserts declaration for a method which takes eleven arguments.
#c
#c Macro Arg 01: method name
#c
#c Macro arguments 02+:
#c 
#c meth arg #   arg modfrs   obj style   type    name    arg cmnt
#c ----------   ----------   ---------   ----    ----    --------
#c metharg 1    02           03          04      05      06
#c metharg 2    07           08          09      10      11
#c metharg 3    12           13          14      15      16
#c metharg 4    17           18          19      20      21
#c metharg 5    22           23          24      25      26
#c metharg 6    27           28          29      30      31
#c metharg 7    32           33          34      35      36
#c metharg 8    37           38          39      40      41
#c metharg 9    42           43          44      45      46
#c metharg 10   47           48          49      50      51
#c metharg 11   52           53          54      55      56
#c
#c Macro Arg 57: method description
#c
#startm AD_XMETHOD_11 57
HRESULT STDMETHODCALLTYPE
    C.this-module::%01 (.%03-adornment%04 .%03-indirection %05,
        .%08-adornment%09 .%08-indirection %10,
        .%13-adornment%14 .%13-indirection %15,
        .%18-adornment%19 .%18-indirection %20,
        .%23-adornment%24 .%23-indirection %25,
        .%28-adornment%29 .%28-indirection %30,
        .%33-adornment%34 .%33-indirection %35,
        .%38-adornment%39 .%38-indirection %40,
        .%43-adornment%44 .%43-indirection %45,
        .%48-adornment%49 .%48-indirection %50,
        .%53-adornment%54 .%53-indirection %55)
{
  HRESULT hr;

  Impl.this-module * ptr;
  ImplAAFRoot * pO;
  pO = GetRepObject ();
  assert (pO);
  ptr = static_cast<Impl.this-module*> (pO);
  assert (ptr);

.%03-setup(%04, %05, foo, bar)\
.%08-setup(%09, %10, foo, bar)\
.%13-setup(%14, %15, foo, bar)\
.%18-setup(%19, %20, foo, bar)\
.%23-setup(%24, %25, foo, bar)\
.%28-setup(%29, %30, foo, bar)\
.%33-setup(%34, %35, foo, bar)\
.%38-setup(%39, %40, foo, bar)\
.%43-setup(%44, %45, foo, bar)\
.%48-setup(%49, %50, foo, bar)\
.%53-setup(%54, %55, foo, bar)\

AD_CATCH_ASSERTION_BEGIN\
  hr = ptr->%01
       (.%03-internalname(%05),
        .%08-internalname(%10),
        .%13-internalname(%15),
        .%18-internalname(%20),
        .%23-internalname(%25),
        .%28-internalname(%30),
        .%33-internalname(%35),
        .%38-internalname(%40),
        .%43-internalname(%45),
        .%48-internalname(%50),
        .%53-internalname(%55));
AD_CATCH_ASSERTION_END
.%03-cleanup(%04, %05, foo, bar)\
.%08-cleanup(%09, %10, foo, bar)\
.%13-cleanup(%14, %15, foo, bar)\
.%18-cleanup(%19, %20, foo, bar)\
.%23-cleanup(%24, %25, foo, bar)\
.%28-cleanup(%29, %30, foo, bar)\
.%33-cleanup(%34, %35, foo, bar)\
.%38-cleanup(%39, %40, foo, bar)\
.%43-cleanup(%44, %45, foo, bar)\
.%48-cleanup(%49, %50, foo, bar)\
.%53-cleanup(%54, %55, foo, bar)\
  return hr;
}
#endm


#ccccccccccccccccccccccccccc
#c
#c Inserts declaration for a method which takes three arguments.
#c Allows two additional macro argument per method argument to let
#c macro caller pass more info.  For example:
#c
#c For type           Arg1 is						arg2 is
#c     ----           ------						----
#c     objInArray     array size					-
#c     objOutArray    alloc'd array size			fetched array size
#c     objInCustom    custom input "marshal" code	-
#c     objOutCustom   custom output "marshal" code	-
#c     all else       -								-
#c
#c Macro Arg 01: method name
#c
#c Macro arguments 02+:
#c 
#c meth arg #   arg modfrs   obj style   type    name    arg cmnt aux1	aux2
#c ----------   ----------   ---------   ----    ----    -------- ----  ----
#c metharg 1    02           03          04      05      06       07	08
#c metharg 2    09           10          11      12      13       14	15
#c metharg 3    16           17          18      19      20       21	22
#c
#c Macro Arg 23: method description
#c
#startm AD_X2METHOD3 23
HRESULT STDMETHODCALLTYPE
    C.this-module::%01 (.%03-adornment%04 .%03-indirection %05,
        .%10-adornment%11 .%10-indirection %12,
        .%17-adornment%18 .%17-indirection %19)
{
  HRESULT hr;

  Impl.this-module * ptr;
  ImplAAFRoot * pO;
  pO = GetRepObject ();
  assert (pO);
  ptr = static_cast<Impl.this-module*> (pO);
  assert (ptr);

.%03-setup(%04, %05, %07, %08)\
.%10-setup(%11, %12, %14, %15)\
.%17-setup(%18, %19, %21, %22)\

AD_CATCH_ASSERTION_BEGIN\
  hr = ptr->%01
       (.%03-internalname(%05),
        .%10-internalname(%12),
        .%17-internalname(%19));
AD_CATCH_ASSERTION_END
.%03-cleanup(%04, %05, %07, %08)\
.%10-cleanup(%11, %12, %14, %15)\
.%17-cleanup(%18, %19, %21, %22)\
  return hr;
}
#endm


#ccccccccccccccccccccccccccc
#c
#c Inserts declaration for a method which takes four arguments.
#c Allows two additional macro argument per method argument to let
#c macro caller pass more info.  For example:
#c
#c For type           Arg1 is						arg2 is
#c     ----           ------						----
#c     objInArray     array size					-
#c     objOutArray    alloc'd array size			fetched array size
#c     objInCustom    custom input "marshal" code	-
#c     objOutCustom   custom output "marshal" code	-
#c     all else       -								-
#c
#c Macro Arg 01: method name
#c
#c Macro arguments 02+:
#c 
#c meth arg #   arg modfrs   obj style   type    name    arg cmnt aux1	aux2
#c ----------   ----------   ---------   ----    ----    -------- --
#c metharg 1    02           03          04      05      06       07	08
#c metharg 2    09           10          11      12      13       14	15
#c metharg 3    16           17          18      19      20       21	22
#c metharg 4    23           24          25      26      27       28	29
#c
#c Macro Arg 30: method description
#c
#startm AD_X2METHOD4 30
HRESULT STDMETHODCALLTYPE
    C.this-module::%01 (.%03-adornment%04 .%03-indirection %05,
        .%10-adornment%11 .%10-indirection %12,
        .%17-adornment%18 .%17-indirection %19,
        .%24-adornment%25 .%24-indirection %26)
{
  HRESULT hr;

  Impl.this-module * ptr;
  ImplAAFRoot * pO;
  pO = GetRepObject ();
  assert (pO);
  ptr = static_cast<Impl.this-module*> (pO);
  assert (ptr);

.%03-setup(%04, %05, %07, %08)\
.%10-setup(%11, %12, %14, %15)\
.%17-setup(%18, %19, %21, %22)\
.%24-setup(%25, %26, %28, %29)\

AD_CATCH_ASSERTION_BEGIN\
  hr = ptr->%01
       (.%03-internalname(%05),
        .%10-internalname(%12),
        .%17-internalname(%19),
        .%24-internalname(%26));
AD_CATCH_ASSERTION_END
.%03-cleanup(%04, %05, %07, %08)\
.%10-cleanup(%11, %12, %14, %15)\
.%17-cleanup(%18, %19, %21, %22)\
.%24-cleanup(%25, %26, %28, %29)\
  return hr;
}
#endm


#ccccccccccccccccccccccccccc
#c
#c Inserts declaration for a method which takes five arguments.
#c Allows two additional macro argument per method argument to let
#c macro caller pass more info.  For example:
#c
#c For type           Arg1 is						arg2 is
#c     ----           ------						----
#c     objInArray     array size					-
#c     objOutArray    alloc'd array size			fetched array size
#c     objInCustom    custom input "marshal" code	-
#c     objOutCustom   custom output "marshal" code	-
#c     all else       -								-
#c
#c Macro Arg 01: method name
#c
#c Macro arguments 02+:
#c 
#c meth arg #   arg modfrs   obj style   type    name    arg cmnt aux1	aux2
#c ----------   ----------   ---------   ----    ----    -------- --
#c metharg 1    02           03          04      05      06       07	08
#c metharg 2    09           10          11      12      13       14	15
#c metharg 3    16           17          18      19      20       21	22
#c metharg 4    23           24          25      26      27       28	29
#c metharg 5    30           31          32      33      34       35	36
#c
#c Macro Arg 37: method description
#c
#startm AD_X2METHOD5 37
HRESULT STDMETHODCALLTYPE
    C.this-module::%01 (.%03-adornment%04 .%03-indirection %05,
        .%10-adornment%11 .%10-indirection %12,
        .%17-adornment%18 .%17-indirection %19,
        .%24-adornment%25 .%24-indirection %26,
        .%31-adornment%32 .%31-indirection %33)
{
  HRESULT hr;

  Impl.this-module * ptr;
  ImplAAFRoot * pO;
  pO = GetRepObject ();
  assert (pO);
  ptr = static_cast<Impl.this-module*> (pO);
  assert (ptr);

.%03-setup(%04, %05, %07, %08)\
.%10-setup(%11, %12, %14, %15)\
.%17-setup(%18, %19, %21, %22)\
.%24-setup(%25, %26, %28, %29)\
.%31-setup(%32, %33, %35, %36)\

AD_CATCH_ASSERTION_BEGIN\
  hr = ptr->%01
       (.%03-internalname(%05),
        .%10-internalname(%12),
        .%17-internalname(%19),
        .%24-internalname(%26),
        .%31-internalname(%33));
AD_CATCH_ASSERTION_END
.%03-cleanup(%04, %05, %07, %08)\
.%10-cleanup(%11, %12, %14, %15)\
.%17-cleanup(%18, %19, %21, %22)\
.%24-cleanup(%25, %26, %28, %29)\
.%31-cleanup(%32, %33, %35, %36)\
  return hr;
}
#endm


#ccccccccccccccccccccccccccc
#c
#c Inserts declaration for a method which takes three arguments.
#c
#c Macro Arg 01: method name
#c
#c Macro arguments 02+:
#c 
#c meth arg #   arg modfrs   obj style   type    name    arg cmnt
#c ----------   ----------   ---------   ----    ----    --------
#c metharg 1    02           03          04      05      06
#c metharg 2    07           08          09      10      11
#c metharg 3    12           13          14      15      16
#c
#c Macro Arg 17: method description
#c
#startm AD_GETOBJECT3 17
HRESULT STDMETHODCALLTYPE
    C.this-module::%01 (.%03-adornment%04 .%03-indirection %05,
        .%08-adornment%09 .%08-indirection %10,
        .%13-adornment%14 .%13-indirection %15)
{
  HRESULT hr = S_OK;

AD_CATCH_ASSERTION_BEGIN

  Impl.this-module * ptr;
  ImplAAFRoot * pO;
  pO = GetRepObject ();
  assert (pO);
  ptr = static_cast<Impl.this-module*> (pO);
  assert (ptr);

.%03-setup(%04, %05, foo, bar)
.%13-setup(%14, %15, foo, bar)

  hr = ptr->%01
       (.%03-internalname(%05),
        .%13-internalname(%15));

.%03-cleanup(%04, %05, foo, bar)
.%13-cleanup(%14, %15, %10, bar)

AD_CATCH_ASSERTION_END

  return hr;
}
#endm


#ccccccccccccccccccccccccccc
#c
#c Ends a class definition
#c
#c Arguments: none
#c
#startm AD_CLASS_END 00
//
// 
// 
HRESULT C.this-module::InternalQueryInterface
(
    REFIID riid,
    void **ppvObj)
{
    HRESULT hr = S_OK;

    if (NULL == ppvObj)
        return E_INVALIDARG;

    // We only support the IClassFactory interface 
    if (riid == IID_I.this-module) 
    { 
        *ppvObj = (I.this-module *)this; 
        ((IUnknown *)*ppvObj)->AddRef();
        return S_OK;
    }

    // Always delegate back to base implementation.
    return C.parent-module::InternalQueryInterface(riid, ppvObj);
}

//
// Define the contrete object support implementation.
// 
AAF_DEFINE_FACTORY(.this-module)\
#endm


#ccccccccccccccccccccccccccc
#c
#c Ends a class definition for classes which support 1 more than the
#c primary COM interface.
#c
#c Arguments: additional interface name
#c
#startm AD_COM_EXT_CLASS_END 01
//
// 
// 
HRESULT C.this-module::InternalQueryInterface
(
    REFIID riid,
    void **ppvObj)
{
    HRESULT hr = S_OK;

    if (NULL == ppvObj)
        return E_INVALIDARG;

    // We only support the IClassFactory interface 
    if (riid == IID_I.this-module) 
    { 
        *ppvObj = (I.this-module *)this; 
        ((IUnknown *)*ppvObj)->AddRef();
        return S_OK;
    }

    if (riid == IID_I%01) 
    { 
        *ppvObj = (I%01 *)this; 
        ((IUnknown *)*ppvObj)->AddRef();
        return S_OK;
    }

    // Always delegate back to base implementation.
    return C.parent-module::InternalQueryInterface(riid, ppvObj);
}

//
// Define the contrete object support implementation.
// 
AAF_DEFINE_FACTORY(.this-module)\
#endm

#ccccccccccccccccccccccccccc
#c
#c Ends a class definition for classes which support more than the
#c primary COM interface.
#c
#c Arguments: additional interface name
#c
#startm AD_COM_EXT2_CLASS_END 02
//
// 
// 
HRESULT C.this-module::InternalQueryInterface
(
    REFIID riid,
    void **ppvObj)
{
    HRESULT hr = S_OK;

    if (NULL == ppvObj)
        return E_INVALIDARG;

    // We only support the IClassFactory interface 
    if (riid == IID_I.this-module) 
    { 
        *ppvObj = (I.this-module *)this; 
        ((IUnknown *)*ppvObj)->AddRef();
        return S_OK;
    }

    if (riid == IID_I%01) 
    { 
        *ppvObj = (I%01 *)this; 
        ((IUnknown *)*ppvObj)->AddRef();
        return S_OK;
    }
    if (riid == IID_I%02) 
    { 
        *ppvObj = (I%02 *)this; 
        ((IUnknown *)*ppvObj)->AddRef();
        return S_OK;
    }

    // Always delegate back to base implementation.
    return C.parent-module::InternalQueryInterface(riid, ppvObj);
}

//
// Define the contrete object support implementation.
// 
AAF_DEFINE_FACTORY(.this-module)\
#endm


#ccccccccccccccccccccccccccc
#c
#c Ends a class definition for AAFRoot
#c
#c Arguments: none
#c
#startm AD_ROOT_CLASS_END 00
//
// 
// 
HRESULT C.this-module::InternalQueryInterface
(
    REFIID riid,
    void **ppvObj)
{
    HRESULT hr = S_OK;

    if (NULL == ppvObj)
        return E_INVALIDARG;

    // We only support the IClassFactory interface 
    if (riid == IID_I.this-module) 
    { 
        *ppvObj = (I.this-module *)this; 
        ((IUnknown *)*ppvObj)->AddRef();
        return S_OK;
    }

    // Always delegate back to base implementation.
    return CAAFUnknown::InternalQueryInterface(riid, ppvObj);
}

//
// Return private implementation pointer for delegation.
// NOTE: This is NOT the pointer to the COM object's implementation
// object!
//
HRESULT STDMETHODCALLTYPE
    C.this-module::GetImplRep (void **ppRep)
{
    if (!ppRep)
        return E_INVALIDARG;  
    *ppRep = static_cast<void*>(GetRepObject());
    return S_OK;
}

//
// Intialize class extensions. This method is called after the
// contained Impl object has been completely initialized. This
// allows the aggregated extension object access to all of the
// interfaces and property data of its controlling unknown.
//
HRESULT STDMETHODCALLTYPE
    C.this-module::InitializeExtension(REFCLSID /*clsid*/)
{
  // Extensions are not supported for the shared
  // C.this-module module.
  return AAFRESULT_NOT_IMPLEMENTED;
}

//
// Define the contrete object support implementation.
// 
AAF_DEFINE_FACTORY(.this-module)

#endm


#ccccccccccccccccccccccccccc
#c
#c Specifies an overridden method
#c
#c Argument: method declaration
#c
#startm AD_OVERRIDE 01
#endm


#ccccccccccccccccccccccccccc
#c
#c Specifies a method in a separate COM interface.
#c
#c Argument: method declaration
#c
#startm AD_COM_METH 01
%01-com-meth-comc(.this-module)
#endm


#ccccccccccccccccccccccccccc
#c
#c Inserts declaration for a constructor which takes one argument.
#c Constructor name is assumed to be .this-module.
#c
#c Macro arguments 01+:
#c 
#c meth arg #   arg modfrs   obj style   type    name    arg cmnt
#c ----------   ----------   ---------   ----    ----    --------
#c metharg 1    01           02          03      04      05
#c
#c Macro Arg 06: method description
#c
#startm AD_XCONSTRUCTOR1 06
C.this-module::C.this-module (.%02-adornment%03 .%02-indirection %04)
{
.%02-setup(%03, %04, foo, bar)\
  Impl.this-module * newRep;
  newRep = new Impl.this-module (.%02-internalname(%04));
  assert (newRep);
  InitRep (newRep);
.%02-cleanup(%03, %04, foo, bar)\
}
#endm


#ccccccccccccccccccccccccccc
#c
#c Inserts declaration for a constructor which takes two arguments.
#c Constructor name is assumed to be .this-module.
#c
#c Macro arguments 01+:
#c 
#c meth arg #   arg modfrs   obj style   type    name    arg cmnt
#c ----------   ----------   ---------   ----    ----    --------
#c metharg 1    01           02          03      04      05
#c metharg 2    06           07          08      09      10
#c
#c Macro Arg 11: method description
#c
#startm AD_XCONSTRUCTOR2 11
C.this-module::C.this-module (.%02-adornment%03 .%02-indirection %04,
    .%07-adornment%08 .%07-indirection %09)
{
.%02-setup(%03, %04, foo, bar)\
.%07-setup(%08, %09, foo, bar)\
  Impl.this-module * newRep;
  newRep = new Impl.this-module (.%02-internalname(%04),
    .%07-internalname(%09));
  assert (newRep);
  InitRep (newRep);
.%02-cleanup(%03, %04, foo, bar)\
.%07-cleanup(%08, %09, foo, bar)\
}
#endm


#ccccccccccccccccccccccccccc
#c
#c Inserts declaration for a constructor which takes three arguments.
#c Constructor name is assumed to be .this-module.
#c
#c Macro arguments 01+:
#c 
#c meth arg #   arg modfrs   obj style   type    name    arg cmnt
#c ----------   ----------   ---------   ----    ----    --------
#c metharg 1    01           02          03      04      05
#c metharg 2    06           07          08      09      10
#c metharg 3    11           12          13      14      15
#c
#c Macro Arg 16: method description
#c
#startm AD_XCONSTRUCTOR3 16
C.this-module::C.this-module (.%02-adornment%03 .%02-indirection %04,
    .%07-adornment%08 .%07-indirection %09,
    .%12-adornment%13 .%12-indirection %14)
{
.%02-setup(%03, %04, foo, bar)\
.%07-setup(%08, %09, foo, bar)\
.%12-setup(%13, %14, foo, bar)\
  Impl.this-module * newRep;
  newRep = new Impl.this-module (.%02-internalname(%04),
    .%07-internalname(%09),
    .%12-internalname(%14));
  assert (newRep);
  InitRep (newRep);
.%02-cleanup(%03, %04, foo, bar)\
.%07-cleanup(%08, %09, foo, bar)\
.%12-cleanup(%13, %14, foo, bar)\
}
#endm


#ccccccccccccccccccccccccccc
#c
#c Inserts declaration for a constructor which takes four arguments.
#c Constructor name is assumed to be .this-module.
#c
#c Macro arguments 01+:
#c 
#c meth arg #   arg modfrs   obj style   type    name    arg cmnt
#c ----------   ----------   ---------   ----    ----    --------
#c metharg 1    01           02          03      04      05
#c metharg 2    06           07          08      09      10
#c metharg 3    11           12          13      14      15
#c metharg 4    16           17          18      19      20
#c
#c Macro Arg 21: method description
#c
#startm AD_XCONSTRUCTOR4 21
C.this-module::C.this-module (.%02-adornment%03 .%02-indirection %04,
                              .%07-adornment%08 .%07-indirection %09,
                              .%12-adornment%13 .%12-indirection %14,
                              .%17-adornment%18 .%17-indirection %19)
{
.%02-setup(%03, %04, foo, bar)\
.%07-setup(%08, %09, foo, bar)\
.%12-setup(%13, %14, foo, bar)\
.%17-setup(%18, %19, foo, bar)\
  Impl.this-module * newRep;
  newRep = new Impl.this-module (.%02-internalname(%04),
    .%07-internalname(%09),
    .%12-internalname(%14),
    .%17-internalname(%19));
  assert (newRep);
  InitRep (newRep);
.%02-cleanup(%03, %04, foo, bar)\
.%07-cleanup(%08, %09, foo, bar)\
.%12-cleanup(%13, %14, foo, bar)\
.%17-cleanup(%08, %19, foo, bar)\
}
#endm


#ccccccccccccccccccccccccccc
#c
#c Argument1: text to be quoted.
#c 
#c Ignore the input
#c
#c TomR:added 980714
#c
#startm AD_CPP_QUOTE 01
#endm


#ccccccccccccccccccccccccccc
#c
#c Argument1: base name to be converted to output type.
#c ingnore the input
#c
#startm AD_AAFTYPES 01
I%01\
#endm


#ccccccccccccccccccccccccccc
#c
#c Argument1: base name to be converted to output type.
#c Ignore input
#c
#startm AD_DECLARE_FORWARD_AAFTYPES 01
#endm


#ccccccccccccccccccccccccccc
#c
#c Generate a forward declaration of a class.
#c
#c Argument: class name
#c
#startm AD_FORWARD_DECLARATION 01
#include "C%01.h"
#include "Impl%01.h"
#endm

#ccccccccccccccccccccccccccc
#c
#c Defining the interface UUID.
#c NOTE: Should be placed immediately before AD_CLASS_BEGIN
#c
#c GUID
#c Argument01: hex long  0-3[leading 0's w/o leading 0x]
#c Argument02: hex short 4-5[leading 0's w/o leading 0x]
#c Argument03: hex short 6-7[leading 0's w/o leading 0x]
#c Argument04: hex byte   8 [leading 0's w/o leading 0x]
#c Argument05: hex byte   9 [leading 0's w/o leading 0x]
#c Argument06: hex byte  10 [leading 0's w/o leading 0x]
#c Argument07: hex byte  11 [leading 0's w/o leading 0x]
#c Argument08: hex byte  12 [leading 0's w/o leading 0x]
#c Argument09: hex byte  13 [leading 0's w/o leading 0x]
#c Argument10: hex byte  14 [leading 0's w/o leading 0x]
#c Argument11: hex byte  15 [leading 0's w/o leading 0x]
#c
#c Example:
#c AD_DEFAULT_UUID(b1a21372, 1a7d, 11d2, bf, 78, 00, 10, 4b, c9, 15, 6d)
#c
#c TomR:980713: Added
#c TomR:990304: Removed
#c // Default Interface for .this-module 
#c // {%01-%02-%03-%04%05-%06%07%08%09%10%11}
#c const IID IID_I.this-module = { 0x%01, 0x%02, 0x%03, { 0x%04, 0x%05, 0x%06, 0x%07, 0x%08, 0x%09, 0x%10, 0x%11 } };
#c This information is always in the AAF_i.c file.
#startm AD_DEFAULT_UUID 11
#endm


#ccccccccccccccccccccccccccc
#c
#c Defining the Class "Factory" UUID.
#c NOTE: should be placed before AD_DEFAULT_UUID or after
#c AD_CLASS_END
#c
#c GUID
#c Argument01: hex long  0-3[leading 0's w/o leading 0x]
#c Argument02: hex short 4-5[leading 0's w/o leading 0x]
#c Argument03: hex short 6-7[leading 0's w/o leading 0x]
#c Argument04: hex byte   8 [leading 0's w/o leading 0x]
#c Argument05: hex byte   9 [leading 0's w/o leading 0x]
#c Argument06: hex byte  10 [leading 0's w/o leading 0x]
#c Argument07: hex byte  11 [leading 0's w/o leading 0x]
#c Argument08: hex byte  12 [leading 0's w/o leading 0x]
#c Argument09: hex byte  13 [leading 0's w/o leading 0x]
#c Argument10: hex byte  14 [leading 0's w/o leading 0x]
#c Argument11: hex byte  15 [leading 0's w/o leading 0x]
#c
#c Example:
#c AD_CLASS_UUID(b1a21373, 1a7d, 11d2, bf, 78, 00, 10, 4b, c9, 15, 6d)
#c
#c TomR:980713: Added
#c TomR:990304: Added EXTERN_C
#c
#startm AD_CLASS_UUID 11
// CLSID for .this-module 
// {%01-%02-%03-%04%05-%06%07%08%09%10%11}
EXTERN_C const CLSID CLSID_.this-module = { 0x%01, 0x%02, 0x%03, { 0x%04, 0x%05, 0x%06, 0x%07, 0x%08, 0x%09, 0x%10, 0x%11 } };
#endm


#ccccccccccccccccccccccccccc
#c
#c Inserts declaration for a static method used to bootstrap an AAF
#c session by creating the first session object.
#c
#startm AD_BEGIN_SESSION 00
#endm

#ccccccccccccccccccccccccccc
#c
#c Inserts declaration for a static method used for a container to create
#c its contained objects in the cpp API.
#c
#startm AD_STATIC_CREATE 00
#endm

#ccccccccccccccccccccccccccc
#c
#c The following macros assist in passing arguments to methods of the
#c contained implementation class:
#c
#c The objIn macros are for use with pointers to objects that are
#c passed into the method.  The Type argument is the base type, with
#c no indirection specified.  For example, if you're passing in
#c AObject*, AObject should be specified for the Type argument.#c
#c
#c The objOut macros are for use with pointers to pointers to objects
#c that are passed out of the method.  The Type argument is the base
#c type, with no indirection specified.  For example, if you're
#c passing in AObject**, AObject should be specified for the Type
#c argument.
#c
#c The objPass macros are for use with any kind of data which is
#c passed exactly into or out of the method.
#c


#ccccccccccccccccccccccccccc
#c
#c #define .objIn-setup(T, externArg, aux1, aux2)
#c
#c arg1 = unadorned type
#c arg2 = external arg name
#c arg3 = aux argument
#c arg3 = aux argument
#c
#startm .objIn-setup 04
  //
  // set up for %02
  //
  Impl%01 * internal%02 = NULL;
  if (%02)
    {
      HRESULT hStat;
      IAAFRoot * iObj;
      ImplAAFRoot *arg;
      hStat = %02->QueryInterface (IID_IAAFRoot, (void **)&iObj);
      assert (SUCCEEDED (hStat));
      assert (iObj);
      hStat = iObj->GetImplRep((void **)&arg);
      assert (SUCCEEDED (hStat));
      iObj->Release(); // we are through with this interface pointer.
      internal%02 = static_cast<Impl%01*>(arg);
      assert (internal%02);
    }
#endm


#ccccccccccccccccccccccccccc
#c
#c #define .unkIn-setup(T, externArg, aux1, aux2)
#c
#c arg1 = unadorned type
#c arg2 = external arg name
#c arg3 = aux argument
#c arg4 = aux argument
#c
#c Override map Unknown to Root (IUnknown to ImplAAFRoot)
#c
#startm .unkIn-setup 04
  //
  // set up for %02
  //
  ImplAAFRoot * internal%02 = NULL;
  if (%02)
    {
      HRESULT hStat;
      IAAFRoot * iObj;
      ImplAAFRoot *arg;
      hStat = %02->QueryInterface (IID_IAAFRoot, (void **)&iObj);
      if (FAILED(hStat))
      {
        // If input IUnknown argument MUST supprt our private IAAFRoot interface.
        // If it does not than the argument is not one of our implementation objects!
        assert(E_NOINTERFACE == hStat);
        if (E_NOINTERFACE == hStat)
          return AAFRESULT_INVALID_PARAM;
        else
          return hStat;
      }
      assert (iObj);
      hStat = iObj->GetImplRep((void **)&arg);
      assert (SUCCEEDED (hStat));
      iObj->Release(); // we are through with this interface pointer.
      internal%02 = static_cast<ImplAAFRoot*>(arg);
      assert (internal%02);
    }
#endm


#ccccccccccccccccccccccccccc
#c
#c #define .enumIn-setup(T, externArg, aux1, aux2)
#c
#c arg1 = unadorned type
#c arg2 = external arg name
#c arg3 = aux argument
#c arg4 = aux argument
#c
#startm .enumIn-setup 04
  //
  // set up for %02
  //
  if (! Is_%01_Valid(%02))
    return AAFRESULT_INVALID_ENUM_VALUE;
#endm


#ccccccccccccccccccccccccccc
#c
#c #define .objInArray-setup(T, externArg, aux1, aux2)
#c
#c arg1 = unadorned type
#c arg2 = external arg name
#c arg3 = aux argument
#c arg4 = aux argument
#c
#startm .objInArray-setup 04
  //
  // set up for %02
  //
  Impl%01 ** internal%02 = NULL;
  if (%02)
    {
      aafUInt32 localIdx;
	  assert (%03 >= 0);
	  internal%02 = new Impl%01*[%03];
	  assert (internal%02);

	  for (localIdx = 0; localIdx < %03; localIdx++)
		{
		  HRESULT hStat;
		  IAAFRoot * iObj;
		  ImplAAFRoot *arg;
		  hStat = %02[localIdx]->QueryInterface (IID_IAAFRoot, (void **)&iObj);
		  assert (SUCCEEDED (hStat));
		  assert (iObj);
		  hStat = iObj->GetImplRep((void **)&arg);
		  assert (SUCCEEDED (hStat));
		  iObj->Release(); // we are through with this interface pointer.
		  internal%02[localIdx] = static_cast<Impl%01*>(arg);
		  assert (internal%02[localIdx]);
		}
    }
#endm


#ccccccccccccccccccccccccccc
#c
#c #define .objInArrayCustom-setup(T, externArg, customCode, aux)
#c
#c arg1 = unadorned type
#c arg2 = external arg name
#c arg3 = custom arg translation code
#c arg4 = aux argument
#c
#startm .objInArrayCustom-setup 04
  //
  // set up for %02
  //
  Impl%01 * internal%02 = NULL;
  if (%02)
    {
	  %03
    }
#endm


#ccccccccccccccccccccccccccc
#c
#c #define .objPass-setup(T, externArg, aux1, aux2)
#c
#c arg1 = unadorned type
#c arg2 = external arg name
#c arg3 = aux argument
#c arg4 = aux argument
#c
#startm .objPass-setup 04
\
#endm


#ccccccccccccccccccccccccccc
#c
#c #define .objOut-setup(T, externArg, aux1, aux2)
#c
#c arg1 = unadorned type
#c arg2 = external arg name
#c arg3 = aux argument
#c arg4 = aux argument
#c
#startm .objOut-setup 04
  //
  // set up for %02
  //
  Impl%01 * internal%02 = NULL;
  Impl%01 ** pinternal%02 = NULL;
  if (%02)
    {
      pinternal%02 = &internal%02;
    }
#endm


#ccccccccccccccccccccccccccc
#c
#c #define .unkOut-setup(T, externArg, aux1, aux2)
#c
#c arg1 = unadorned type
#c arg2 = external arg name
#c arg3 = aux argument
#c arg4 = aux argument
#c
#c Override map Unknown to Root (IUnknown to ImplAAFRoot)
#c
#startm .unkOut-setup 04
  //
  // set up for %02
  //
  ImplAAFRoot * internal%02 = NULL;
  ImplAAFRoot ** pinternal%02 = NULL;
  if (%02)
    {
      pinternal%02 = &internal%02;
    }
#endm


#ccccccccccccccccccccccccccc
#c
#c #define .objOutArray-setup(T, externArg, arraySize, aux)
#c
#c arg1 = unadorned type
#c arg2 = external arg name
#c arg3 = size of array
#c arg4 = aux argument
#c
#startm .objOutArray-setup 04
  //
  // set up for %02
  //
  Impl%01 ** internal%02 = NULL;
  assert (%03 >= 0);
  internal%02 = new Impl%01*[%03];
  assert (internal%02);

  Impl%01 ** pinternal%02 = NULL;
  if (%02)
    {
      pinternal%02 = internal%02;
    }
#endm


#ccccccccccccccccccccccccccc
#c
#c #define .objOutCustom-setup(T, externArg, customCode, aux)
#c
#c arg1 = unadorned type
#c arg2 = external arg name
#c arg3 = custom arg translation code
#c arg4 = aux argument
#c
#startm .objOutArray-setup 04
  //
  // set up for %02
  //
  Impl%01 * internal%02 = NULL;
  assert (%03 >= 0);
  internal%02 = new Impl%01*[%03];
  assert (internal%02);

  Impl%01 ** pinternal%02 = NULL;
  if (%02)
    {
      pinternal%02 = &internal%02;
    }
#endm


#ccccccccccccccccccccccccccc
#c
#c #define .objOutArrayCustom-setup(T, externArg, customCode, aux)
#c
#c arg1 = unadorned type
#c arg2 = external arg name
#c arg3 = custom arg translation code
#c arg4 = aux argument
#c
#startm .objOutArrayCustom-setup 04
  //
  // set up for %02
  //
  Impl%01 * internal%02 = NULL;
  assert (%03 >= 0);
  internal%02 = new Impl%01*[%03];
  assert (internal%02);

  Impl%01 ** pinternal%02 = NULL;
  if (%02)
    {
      pinternal%02 = &internal%02;
    }
#endm


#ccccccccccccccccccccccccccc
#c
#c #define .objIn-internalname(externArg)    (internArg)
#c
#c arg1 = external arg name
#c
#startm .objIn-internalname 01
internal%01\
#endm


#ccccccccccccccccccccccccccc
#c
#c #define .unkIn-internalname(externArg)    (internArg)
#c
#c arg1 = external arg name
#c
#startm .unkIn-internalname 01
internal%01\
#endm


#ccccccccccccccccccccccccccc
#c
#c #define .enumIn-internalname(externArg)    (internArg)
#c
#c arg1 = external arg name
#c
#startm .enumIn-internalname 01
%01\
#endm


#ccccccccccccccccccccccccccc
#c
#c #define .objInArray-internalname(externArg)    (internArg)
#c
#c arg1 = external arg name
#c
#startm .objInArray-internalname 01
internal%01\
#endm


#ccccccccccccccccccccccccccc
#c
#c #define .objPass-internalname(externArg)  (internArg)
#c
#c arg1 = external arg name
#c
#startm .objPass-internalname 01
%01\
#endm


#ccccccccccccccccccccccccccc
#c
#c #define .objOut-internalname(externArg)   (internArg)
#c
#c arg1 = external arg name
#c
#startm .objOut-internalname 01
pinternal%01\
#endm


#ccccccccccccccccccccccccccc
#c
#c #define .unkOut-internalname(externArg)   (internArg)
#c
#c arg1 = external arg name
#c
#startm .unkOut-internalname 01
pinternal%01\
#endm


#ccccccccccccccccccccccccccc
#c
#c #define .objOutArray-internalname(externArg)   (internArg)
#c
#c arg1 = external arg name
#c
#startm .objOutArray-internalname 01
pinternal%01\
#endm


#ccccccccccccccccccccccccccc
#c
#c #define .objIn-cleanup(T, externArg, aux1, aux2)
#c
#c arg1 = unadorned type
#c arg2 = external arg name
#c arg3 = aux arg
#c arg4 = aux arg
#c
#startm .objIn-cleanup 04
  //
  // no cleanup necessary for %02
  //
#endm


#ccccccccccccccccccccccccccc
#c
#c #define .unkIn-cleanup(T, externArg, aux1, aux2)
#c
#c arg1 = unadorned type
#c arg2 = external arg name
#c arg3 = aux arg
#c arg4 = aux arg
#c
#startm .unkIn-cleanup 04
  //
  // no cleanup necessary for %02
  //
#endm


#ccccccccccccccccccccccccccc
#c
#c #define .enumIn-cleanup(T, externArg, aux1, aux2)
#c
#c arg1 = unadorned type
#c arg2 = external arg name
#c arg3 = aux arg
#c arg4 = aux arg
#c
#startm .enumIn-cleanup 04
\
#endm


#ccccccccccccccccccccccccccc
#c
#c #define .objInArray-cleanup(T, externArg, aux1, aux2)
#c
#c arg1 = unadorned type
#c arg2 = external arg name
#c arg3 = aux arg
#c arg4 = aux arg
#c
#startm .objInArray-cleanup 04
  //
  // cleanup for %02
  //
  if (internal%02)
    {
      delete[] internal%02;
      internal%02 = 0;
    }
#endm


#ccccccccccccccccccccccccccc
#c
#c #define .objInArrayCustom-cleanup(T, externArg, aux1, aux2)
#c
#c arg1 = unadorned type
#c arg2 = external arg name
#c arg3 = aux arg
#c arg4 = aux arg
#c
#startm .objInArrayCustom-cleanup 04
  //
  // cleanup for %02
  //
  if (internal%02)
    {
      delete[] internal%02;
      internal%02 = 0;
    }
#endm


#ccccccccccccccccccccccccccc
#c
#c #define .objPass-cleanup(T, externArg, aux1, aux2)
#c
#c arg1 = unadorned type
#c arg2 = external arg name
#c arg3 = aux arg
#c arg4 = aux arg
#c
#startm .objPass-cleanup 04
\
#endm


#ccccccccccccccccccccccccccc
#c
#c #define .objOut-cleanup(T, externArg, aux1, aux2)
#c
#c arg1 = unadorned type
#c arg2 = external arg name
#c arg3 = aux arg
#c arg4 = aux arg
#c
#startm .objOut-cleanup 04
  //
  // cleanup for %02
  //
  if (SUCCEEDED(hr))
    {
      IUnknown *pUnknown;
      HRESULT hStat;

      if (internal%02)
        {
          pUnknown = static_cast<IUnknown *> (internal%02->GetContainer());
          hStat = pUnknown->QueryInterface(IID_I%01, (void **)%02);
          assert (SUCCEEDED (hStat));
          //pUnknown->Release();
          internal%02->ReleaseReference(); // We are through with this pointer.
        }
    }
#endm


#ccccccccccccccccccccccccccc
#c
#c #define .unkOut-cleanup(T, externArg, aux1, aux2)
#c
#c arg1 = unadorned type
#c arg2 = external arg name
#c arg3 = IID for QueryInterface
#c arg4 = aux arg
#c
#startm .unkOut-cleanup 04
  //
  // cleanup for %02
  //
  if (internal%02)
    {
      IUnknown *pUnknown = static_cast<IUnknown *> (internal%02->GetContainer());
      HRESULT hStat = pUnknown->QueryInterface(%03, (void **)%02);
      if (SUCCEEDED(hr) && FAILED(hStat))
        hr = hStat;
      internal%02->ReleaseReference(); // We are through with this pointer.
    }
#endm


#ccccccccccccccccccccccccccc
#c
#c #define .objOutArray-cleanup(T, externArg, aux1, aux2)
#c
#c arg1 = unadorned type
#c arg2 = external arg name
#c arg3 = aux arg
#c arg4 = aux arg
#c
#c MattS: added check for AAFRESULT_NO_MORE_OBJECTS 6/19/00
#c
#startm .objOutArray-cleanup 04
  //
  // cleanup for %02
  //
  if (SUCCEEDED(hr)||hr==AAFRESULT_NO_MORE_OBJECTS)
    {
      IUnknown *pUnknown;
      HRESULT hStat;
      aafUInt32 localIdx;
	  assert (%03 >= 0);
	  for (localIdx = 0; localIdx < %04; localIdx++)
		{
		  pUnknown = static_cast<IUnknown *> (internal%02[localIdx]->GetContainer());
		  hStat = pUnknown->QueryInterface(IID_I%01, (void **)(%02+localIdx));
		  assert (SUCCEEDED (hStat));
		  //pUnknown->Release();
		  internal%02[localIdx]->ReleaseReference(); // We are through with this pointer.
		}
    }
  delete[] internal%02;
  internal%02 = 0;
#endm


#ccccccccccccccccccccccccccc
#c
#c #define .objOutArrayCustom-cleanup(T, externArg, customCode, aux)
#c
#c arg1 = unadorned type
#c arg2 = external arg name
#c arg3 = custom arg translation code
#c arg4 = aux arg
#c
#startm .objOutArrayCustom-cleanup 04
  //
  // cleanup for %02
  //
  if (SUCCEEDED(hr))
    {
	  %03
    }
  delete[] internal%02;
  internal%02 = 0;
#endm


#ccccccccccccccccccccccccccc
#c
#c The following macros assist in passing arguments to methods of the
#c contained implementation class:
#c
#c The objIn macros are for use with pointers to objects that are
#c passed into the method.  The Type argument is the base type, with
#c no indirection specified.  For example, if you're passing in
#c AObject*, AObject should be specified for the Type argument.#c
#c
#c The objOut macros are for use with pointers to pointers to objects
#c that are passed out of the method.  The Type argument is the base
#c type, with no indirection specified.  For example, if you're
#c passing in AObject**, AObject should be specified for the Type
#c argument.
#c
#c The objPass macros are for use with any kind of data which is
#c passed exactly into or out of the method.
#c


#startm .objIn-adornment 00
I\
#endm


#startm .objInArray-adornment 00
I\
#endm


#startm .objInArrayCustom-adornment 00
#endm


#startm .objPass-adornment 00
#endm


#startm .objOut-adornment 00
I\
#endm


#startm .objOutArray-adornment 00
I\
#endm


#startm .objOutArrayCustom-adornment 00
#endm

#startm .unkIn-adornment 00
I\
#endm

#startm .unkOut-adornment 00
I\
#endm

#ccccccccccccccccccccccccccc
#c
#c Hack to quote the .this-module macro and keep it out of export
#c files.  Do not define this macro in exp.mac!!!
#c
#startm AD_EXPORT_THIS_MODULE 00
.this-module\
#endm


#ccccccccccccccccccccccccccc
#c
#c Starts a class definition
#c
#c Argument1: Abstract or Concrete
#c Argument2: Transient or StoredObject
#c            special cases:CommonBase and StoredObjectBase
#c
#c Note: Concrete-StoredObject means Persistent. In other words
#c Concrete-StoredObject objects (and derived objects) are the 
#c only types of objects that should ever be found in an AAF
#c file.
#c
#c Valid combiniations:          examples
#c -----------------------       ---------------
#c   Abstract-CommonBase         AAFRoot 
#c   Abstract-Transient          ????
#c   Abstract-StoredObjectBase   AAFObject
#c   Abstract-StoredObject       AAFSourceReference, AAFComponent, ...
#c   Concrete-Transient          EnumAAFMobs, EnumAAFMobSlots, ...
#c   Concrete-StoredObject       AAFSegment, AAFSourceClip, ...
#c
#startm AD_XCLASS_BEGIN 02
.begin-%01-%02
#endm


#ccccccccccccccccccccccccccc
#c
#c Ends a class definition
#c
#c Argument1: Abstract or Concrete
#c Argument2: Transient or StoredObject
#c            special cases:CommonBase and StoredObjectBase
#c
#c Note: Concrete-StoredObject means Persistent. In other words
#c Concrete-StoredObject objects (and derived objects) are the 
#c only types of objects that should ever be found in an AAF
#c file.
#c
#c Valid combiniations:          examples
#c -----------------------       ---------------
#c   Abstract-CommonBase         AAFRoot 
#c   Abstract-Transient          ????
#c   Abstract-StoredObjectBase   AAFObject
#c   Abstract-StoredObject       AAFSourceReference, AAFComponent, ...
#c   Concrete-Transient          EnumAAFMobs, EnumAAFMobSlots, ...
#c   Concrete-StoredObject       AAFSegment, AAFSourceClip, ...
#c
#startm AD_XCLASS_END 02
.end-%01-%02
#endm


#ccccccccccccccccccccccccccc
#c
#c The following macros implement all of the allowable
#c combinations of the AD_XCLASS_BEGIN and AD_XCLASS_END
#c


#ccccccccccccccccccccccccccc
#c Abstract-CommonBase
#c Special case for the common base class for all AAF objects,
#c Transient and StoredObject classes.
#c (first version defined backwords compatibility)

#startm .begin-Abstract-CommonBase 00
AD_ROOT_CLASS_BEGIN\
#endm

#startm .end-Abstract-CommonBase 00
AD_ROOT_CLASS_END\
#endm


#ccccccccccccccccccccccccccc
#c Abstract-StoredObjectBase
#c Special case for the base class for all AAF stored objects
#c (first version defined backwords compatibility)

#startm .begin-Abstract-StoredObjectBase 00

// Private extension wrapper.
C.this-module::Extension::Extension(REFCLSID rclsid) :
  pNext(NULL),
  clsid(rclsid),
  pExtensionUnknown(NULL),
  bExtensionQueryInterfaceInProgress(false)
{
}

C.this-module::Extension::~Extension() 
{
  if (NULL != pExtensionUnknown)
  {
    pExtensionUnknown->Release();
    pExtensionUnknown = NULL;
  }
}

// Return the class id of this extension.
REFCLSID C.this-module::Extension::GetCLSID(void) const
{ 
  return clsid;
}

// Set or get the next extension.
void C.this-module::Extension::SetNext(C.this-module::Extension *next)
{ 
  pNext = next;
}

C.this-module::Extension * C.this-module::Extension::GetNext(void) const
{ 
  return pNext;
}


// Attempt to create the given plugin extension.
HRESULT C.this-module::Extension::InitializeExtension(IUnknown *pControllingUnknown)
{
  assert(NULL == pExtensionUnknown); // precondition.
  HRESULT hr = S_OK;
  IAAFPluginManager *pPluginMgr = NULL;


  try
  {
    // Get the plugin manager to create the plugin instance.
    hr = ::AAFGetPluginManager(&pPluginMgr);
    if (SUCCEEDED(hr))
    {
      hr = pPluginMgr->CreateInstance(clsid, 
                                      pControllingUnknown, 
                                      IID_IUnknown, 
                                      (void **)&pExtensionUnknown);

      if (pPluginMgr)
        pPluginMgr->Release();
    }
  }
  catch (...)
  {
    // cleanup
    if (pPluginMgr)
        pPluginMgr->Release();

    throw;
  }


  return hr;
}

HRESULT C.this-module::Extension::QueryInterface(REFIID riid, void **ppvObjOut)
{
  assert(NULL != pExtensionUnknown); // precondition.
  HRESULT hr = E_NOINTERFACE;

  // We use state variable to prevent the endless cycle
  // that would occur if the extension's QueryInterface
  // called it's controlling IUnknown's QueryInterface
  // (i.e. C.this-module::InternalQueryInterface)
  // for an interface that is not supported for a built-in
  // class.
  // (QI cycle: Object::QI -> Extension::QI -> Object::QI)
  if (NULL != pExtensionUnknown && !bExtensionQueryInterfaceInProgress)
  {
    bExtensionQueryInterfaceInProgress = true;
    hr = pExtensionUnknown->QueryInterface(riid, ppvObjOut);
    bExtensionQueryInterfaceInProgress = false;
  }

  return hr;
}


C.this-module::C.this-module (IUnknown * pControllingUnknown, aafBool doInit)
  : C.parent-module (pControllingUnknown, kAAFFalse),
  pExtension(NULL)
{
  if (doInit)
    {
      Impl.this-module * newRep;
      newRep = new Impl.this-module;
      assert (newRep);
      InitRep (newRep);
    }
}


C.this-module::~C.this-module ()
{
  // Cleanup any extensions
  if (NULL != pExtension)
  {
    C.this-module::Extension *pCurrentExtension = pExtension;
    C.this-module::Extension *pNextExtension;

    // Set the refcount to 1 do avoid destruction when
    // releasing the aggregated extension object.
    InternalAddRef();

    while (NULL != pCurrentExtension)
    {
      pNextExtension = pCurrentExtension->GetNext();
      pCurrentExtension->SetNext(NULL);
      delete pCurrentExtension;
      pCurrentExtension = pNextExtension;
    }

    pExtension = NULL;
  }
}
#endm

#startm .end-Abstract-StoredObjectBase 00
//
// Intialize class extensions. This method is called after the
// contained Impl object has been completely initialized. This
// allows the aggregated extension object access to all of the
// interfaces and property data of its controlling unknown.
//
HRESULT STDMETHODCALLTYPE
    C.this-module::InitializeExtension(REFCLSID rclsid)
{
  HRESULT hr = S_OK;
  C.this-module::Extension *pNextExtension = NULL;
  C.this-module::Extension *pLastExtension = NULL;
  C.this-module::Extension *pNewExtension = NULL;

  // Increment the reference count to keep this object
  // from being inadvertantly deleted by/with the aggregate
  // extension object.
  InternalAddRef();

AD_CATCH_ASSERTION_BEGIN\
      // Make sure that we do not already have an instantiation
      // for the given clsid/plugin. Walk our linked list and 
      // abort if we have already instantiated a plugin with
      // the same code class id.
      //
      pNextExtension = pExtension;
      while (NULL != pNextExtension)
      {
        if (rclsid == pNextExtension->GetCLSID())
        {
          hr = AAFRESULT_EXTENSION_ALREADY_INITIALIZED;
          break;
        }

        // Remember the last extension so that we can add the
        // new extension onto the end of the list.
        pLastExtension = pNextExtension;
        pNextExtension = pLastExtension->GetNext();
      }

      if (SUCCEEDED(hr)) // there were no duplicates...
      {
        pNewExtension = new C.this-module::Extension(rclsid);
        if (NULL == pNewExtension)
        {
          hr = E_OUTOFMEMORY;
        }
        else
        {
          hr = pNewExtension->InitializeExtension(GetPrivateUnknown());
          if (SUCCEEDED(hr))
          {
            // Save the extension in the list.
            if (NULL != pLastExtension)
              pLastExtension->SetNext(pNewExtension); // add to the end
            else
              pExtension = pNewExtension; // this is the first one.
            pNewExtension = NULL; // This pointer is now owned by the list.
          }
        }
      } 
AD_CATCH_ASSERTION_END\

  // Cleanup
  InternalRelease();

  if (pNewExtension)
    delete pNewExtension;

  return hr;
}

//
// 
// 
HRESULT C.this-module::InternalQueryInterface
(
    REFIID riid,
    void **ppvObj)
{
    HRESULT hr = S_OK;

    if (NULL == ppvObj)
        return E_INVALIDARG;

    // We only support the IClassFactory interface 
    if (riid == IID_I.this-module) 
    { 
        *ppvObj = (I.this-module *)this; 
        ((IUnknown *)*ppvObj)->AddRef();
        return S_OK;
    }

    // Always delegate back to base implementation.
    hr = C.parent-module::InternalQueryInterface(riid, ppvObj);

    //
    // If our built-in class did not handle the requested interface
    // then delegate the request to extension objects if they exists.
    //
    C.this-module::Extension *pNextExtension = pExtension;
    while (E_NOINTERFACE == hr && NULL != pNextExtension)
    {
        hr = pNextExtension->QueryInterface(riid, ppvObj);
        pNextExtension = pNextExtension->GetNext();
    }

    return hr;
}

//
// Define the contrete object support implementation.
// 
AAF_DEFINE_FACTORY(.this-module)\
#endm


#ccccccccccccccccccccccccccc
#c Abstract-Transient
#c (first version defined backwords compatibility)

#startm .begin-Abstract-Transient 00
AD_CLASS_BEGIN\
#endm

#startm .end-Abstract-Transient 00
AD_CLASS_END\
#endm


#ccccccccccccccccccccccccccc
#c Abstract-StoredObject
#c (first version defined backwords compatibility)

#startm .begin-Abstract-StoredObject 00
AD_CLASS_BEGIN\
#endm

#startm .end-Abstract-StoredObject 00
AD_CLASS_END\
#endm


#ccccccccccccccccccccccccccc
#c Concrete-Transient
#c (first version defined backwords compatibility)

#startm .begin-Concrete-Transient 00
AD_CLASS_BEGIN\
#endm

#startm .end-Concrete-Transient 00
AD_CLASS_END\
#endm


#ccccccccccccccccccccccccccc
#c Concrete-StoredObject
#c Note: These are the persistent classes.
#c (first version defined backwords compatibility)

#startm .begin-Concrete-StoredObject 00
AD_CLASS_BEGIN\
#endm

#startm .end-Concrete-StoredObject 00
AD_CLASS_END\
#endm



#ccccccccccccccccccccccccccc
#c
#c Declaration for the dictionary's factory method.
#c
#startm AD_DICTIONARY_FACTORY 02
//
// %02
HRESULT C.this-module::%01
   (// Class identifier (AUID) of the stored object. This is the
    // corresponding SMPTE identifier (as a GUID) for all predefined
    // built-in classes.
    /*[in, ref]*/ aafUID_constref id,

    // Reference to the identifier of the interface
    /*[in, ref]*/ REFIID riid,

    // Address of output variable that receives the 
    // interface pointer requested in riid
    /*[out, iid_is(riid)]*/ IUnknown ** ppvObject)
{
  HRESULT hr = S_OK;
  AAFRESULT result = AAFRESULT_SUCCESS;

  // Validate the input arguments.
  if (NULL == ppvObject)
    return E_INVALIDARG;

  // Find the factory on the corresponding impl class.
  ImplAAFRoot * pImplRoot = GetRepObject();
  assert(pImplRoot);
  Impl.this-module * pImpl.this-module =
		 dynamic_cast<Impl.this-module *>(pImplRoot);
  if (NULL == pImpl.this-module)
  { // This should never happen.
    return AAFRESULT_INTERNAL_ERROR;
  }

  // Create the corresponding impl object.
  ImplAAFObject *pObject = NULL;
  result = pImpl.this-module->CreateInstance(id, &pObject);
  if (AAFRESULT_SUCCESS != result)
    return result;

  // Get the COM container for the new Impl object and see if
  // it supports the requested interface pointer.
  IUnknown *pUnknown = static_cast<IUnknown *>(pObject->GetContainer());
  assert(pUnknown);
  hr = pUnknown->QueryInterface(riid, (void **)ppvObject);
  
  // Release the impl object pointer. If the previous QI failed
  // then the object will be deleted.
  pObject->ReleaseReference();

  return hr;
}
#endm



#ccccccccccccccccccccccccccc
#c
#c Declaration for the dictionary's meta factory method.
#c
#startm AD_DICTIONARY_METAFACTORY 02
//
// %02
HRESULT C.this-module::%01
   (// Identifier (id) of a class or type definition. This is the
    // corresponding SMPTE identifier (as a GUID) for all predefined
    // built-in definitions.
    /*[in, ref]*/ aafUID_constref id,

    // Reference to the identifier of the interface
    /*[in, ref]*/ REFIID riid,

    // Address of output variable that receives the 
    // interface pointer requested in riid
    /*[out, iid_is(riid)]*/ IUnknown ** ppMetaDefinition)
{
  HRESULT hr = S_OK;
  AAFRESULT result = AAFRESULT_SUCCESS;

  // Validate the input arguments.
  if (NULL == ppMetaDefinition)
    return E_INVALIDARG;

  // Find the factory on the corresponding impl class.
  ImplAAFRoot * pImplRoot = GetRepObject();
  assert(pImplRoot);
  Impl.this-module * pImpl.this-module =
		 dynamic_cast<Impl.this-module *>(pImplRoot);
  if (NULL == pImpl.this-module)
  { // This should never happen.
    return AAFRESULT_INTERNAL_ERROR;
  }

  // Create the corresponding impl object.
  ImplAAFMetaDefinition *pObject = NULL;
  result = pImpl.this-module->CreateMetaInstance(id, &pObject);
  if (AAFRESULT_SUCCESS != result)
    return result;

  // Get the COM container for the new Impl object and see if
  // it supports the requested interface pointer.
  IUnknown *pUnknown = static_cast<IUnknown *>(pObject->GetContainer());
  assert(pUnknown);
  hr = pUnknown->QueryInterface(riid, (void **)ppMetaDefinition);
  
  // Release the impl object pointer. If the previous QI failed
  // then the object will be deleted.
  pObject->ReleaseReference();

  return hr;
}
#endm


#ccccccccccccccccccccccccccc
#c
#c Declaration for the class definition's factory method.
#c
#startm AD_CLASSDEF_FACTORY 02
//
// %02
HRESULT C.this-module::%01
   (// Reference to the identifier of the interface
    /*[in, ref]*/ REFIID riid,

    // Address of output variable that receives the 
    // interface pointer requested in riid
    /*[out, iid_is(riid)]*/ IUnknown ** ppvObject)
{
  HRESULT hr = S_OK;
  AAFRESULT result = AAFRESULT_SUCCESS;

  // Validate the input arguments.
  if (NULL == ppvObject)
    return E_INVALIDARG;

  // Find the factory on the corresponding impl class.
  ImplAAFRoot * pImplRoot = GetRepObject();
  assert(pImplRoot);
  Impl.this-module * pImpl.this-module = dynamic_cast<Impl.this-module *>(pImplRoot);
  if (NULL == pImpl.this-module)
  { // This should never happen.
    return AAFRESULT_INTERNAL_ERROR;
  }

  // Create the corresponding impl object.
  ImplAAFObject *pObject = NULL;
  result = pImpl.this-module->CreateInstance(&pObject);
  if (AAFRESULT_SUCCESS != result)
    return result;

  // Get the COM container for the new Impl object and see if
  // it supports the requested interface pointer.
  IUnknown *pUnknown = static_cast<IUnknown *>(pObject->GetContainer());
  assert(pUnknown);
  hr = pUnknown->QueryInterface(riid, (void **)ppvObject);
  
  // Release the impl object pointer. If the previous QI failed
  // then the object will be deleted.
  pObject->ReleaseReference();

  return hr;
}
#endm


#ccccccccccccccccccccccccccc
#c Beginning of the module definitions
#c
#startm AD_MODULE_BEGIN 02
/***********************************************************************
*
*              Copyright (c) 1998-1999 Avid Technology, Inc.
*
* Permission to use, copy and modify this software and accompanying
* documentation, and to distribute and sublicense application software
* incorporating this software for any purpose is hereby granted,
* provided that (i) the above copyright notice and this permission
* notice appear in all copies of the software and related documentation,
* and (ii) the name Avid Technology, Inc. may not be used in any
* advertising or publicity relating to the software without the specific,
*  prior written permission of Avid Technology, Inc.
*
* THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND,
* EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY
* WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.
* IN NO EVENT SHALL AVID TECHNOLOGY, INC. BE LIABLE FOR ANY DIRECT,
* SPECIAL, INCIDENTAL, PUNITIVE, INDIRECT, ECONOMIC, CONSEQUENTIAL OR
* OTHER DAMAGES OF ANY KIND, OR ANY DAMAGES WHATSOEVER ARISING OUT OF
* OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE AND
* ACCOMPANYING DOCUMENTATION, INCLUDING, WITHOUT LIMITATION, DAMAGES
* RESULTING FROM LOSS OF USE, DATA OR PROFITS, AND WHETHER OR NOT
* ADVISED OF THE POSSIBILITY OF DAMAGE, REGARDLESS OF THE THEORY OF
* LIABILITY.
*
************************************************************************/

#include "Impl.this-module.h"
#include "AAFResult.h"

class OMAssertionViolation;

#include <assert.h>

#if defined(_MAC)
#pragma export on
#endif // #if defined(_MAC)
#endm


#ccccccccccccccccccccccccccc
#c End of the module definitions
#c
#startm AD_MODULE_END 00
#if defined(_MAC)
#pragma export off
#endif // #if defined(_MAC)
#endm


#ccccccccccccccccccccccccccc
#c
#c Inserts declaration for a function which takes no arguments.
#c
#c Argument1: function name
#c Argument2: function description
#c
#startm AD_FUNCTION0 02
#endm


#ccccccccccccccccccccccccccc
#c
#c Inserts declaration for a function which takes one argument.
#c
#c Macro Arg 01: function name
#c
#c Macro arguments 02+:
#c 
#c meth arg #   arg modfrs   obj style   type    name    arg cmnt	
#c ----------   ----------   ---------   ----    ----    --------
#c metharg 1    02           03          04      05      06
#c
#c Macro Arg 07: function description
#c
#startm AD_XFUNCTION1 07
STDAPI
    %01 (.%03-adornment%04 .%03-indirection %05)
{
  HRESULT hr;

.%03-setup(%04, %05, foo, bar)\

AD_CATCH_ASSERTION_BEGIN\
  hr = Impl%01
       (.%03-internalname(%05));
AD_CATCH_ASSERTION_END
.%03-cleanup(%04, %05, foo, bar)\
  return hr;
}
#endm


#ccccccccccccccccccccccccccc
#c
#c Inserts declaration for a function which takes two arguments.
#c
#c Macro Arg 01: function name
#c
#c Macro arguments 02+:
#c 
#c meth arg #   arg modfrs   obj style   type    name    arg cmnt
#c ----------   ----------   ---------   ----    ----    --------
#c metharg 1    02           03          04      05      06
#c metharg 2    07           08          09      10      11
#c
#c Macro Arg 12: function description
#c
#startm AD_XFUNCTION2 12
STDAPI
    %01 (.%03-adornment%04 .%03-indirection %05,
        .%08-adornment%09 .%08-indirection %10)
{
  HRESULT hr;

.%03-setup(%04, %05, foo, bar)\
.%08-setup(%09, %10, foo, bar)\

AD_CATCH_ASSERTION_BEGIN\
  hr = Impl%01
       (.%03-internalname(%05),
        .%08-internalname(%10));
AD_CATCH_ASSERTION_END
.%03-cleanup(%04, %05, foo, bar)\
.%08-cleanup(%09, %10, foo, bar)\
  return hr;
}
#endm


#ccccccccccccccccccccccccccc
#c
#c Inserts declaration for a function which takes three arguments.
#c
#c Macro Arg 01: function name
#c
#c Macro arguments 02+:
#c 
#c meth arg #   arg modfrs   obj style   type    name    arg cmnt
#c ----------   ----------   ---------   ----    ----    --------
#c metharg 1    02           03          04      05      06
#c metharg 2    07           08          09      10      11
#c metharg 3    12           13          14      15      16
#c
#c Macro Arg 17: function description
#c
#startm AD_XFUNCTION3 17
STDAPI
    %01 (.%03-adornment%04 .%03-indirection %05,
        .%08-adornment%09 .%08-indirection %10,
        .%13-adornment%14 .%13-indirection %15)
{
  HRESULT hr;

.%03-setup(%04, %05, foo, bar)\
.%08-setup(%09, %10, foo, bar)\
.%13-setup(%14, %15, foo, bar)\

AD_CATCH_ASSERTION_BEGIN\
  hr = Impl%01
       (.%03-internalname(%05),
        .%08-internalname(%10),
        .%13-internalname(%15));
AD_CATCH_ASSERTION_END
.%03-cleanup(%04, %05, foo, bar)\
.%08-cleanup(%09, %10, foo, bar)\
.%13-cleanup(%14, %15, foo, bar)\
  return hr;
}
#endm


#ccccccccccccccccccccccccccc
#c
#c Inserts declaration for a function which takes four arguments.
#c
#c Macro Arg 01: function name
#c
#c Macro arguments 02+:
#c 
#c meth arg #   arg modfrs   obj style   type    name    arg cmnt
#c ----------   ----------   ---------   ----    ----    --------
#c metharg 1    02           03          04      05      06
#c metharg 2    07           08          09      10      11
#c metharg 3    12           13          14      15      16
#c metharg 4    17           18          19      20      21
#c
#c Macro Arg 22: function description
#c
#startm AD_XFUNCTION4 22
STDAPI
    %01 (.%03-adornment%04 .%03-indirection %05,
        .%08-adornment%09 .%08-indirection %10,
        .%13-adornment%14 .%13-indirection %15,
        .%18-adornment%19 .%18-indirection %20)
{
  HRESULT hr;

.%03-setup(%04, %05, foo, bar)\
.%08-setup(%09, %10, foo, bar)\
.%13-setup(%14, %15, foo, bar)\
.%18-setup(%19, %20, foo, bar)\

AD_CATCH_ASSERTION_BEGIN\
  hr = Impl%01
       (.%03-internalname(%05),
        .%08-internalname(%10),
        .%13-internalname(%15),
        .%18-internalname(%20));
AD_CATCH_ASSERTION_END
.%03-cleanup(%04, %05, foo, bar)\
.%08-cleanup(%09, %10, foo, bar)\
.%13-cleanup(%14, %15, foo, bar)\
.%18-cleanup(%19, %20, foo, bar)\
  return hr;
}
#endm


#ccccccccccccccccccccccccccc
#c
#c macro for things which are not to be exported.
#c
#startm AD_NO_EXPORT 01
%01\
#endm
