#c /******************************************\
#c *                                          *
#c * Advanced Authoring Format                *
#c *                                          *
#c * Copyright (c) 1998 Avid Technology, Inc. *
#c * Copyright (c) 1998 Microsoft Corporation *
#c *                                          *
#c \******************************************/


#ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
#c
#c AutoDodo macro file for use in generating COM API implementation
#c C++ files.
#c
#ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


#import macros/base.mac


#ccccccccccccccccccccccccccc
#c
#c Pass through argument if for idl otherwise omit it.
#c 
#c This macro is generally used to specify IDL options that would
#c make since to emit to c++.
#c To allow proper marshalling code generation of a struct: |
#c typedef struct
#c {
#c     aafInt32 length;
#c     AD_IDL([length_is(length)]) aafWchar *str;
#c } aafString_t;
#c
#startm AD_IDL 01
#endm


#ccccccccccccccccccccccccccc
#c
#c Includes another file.
#c
#c Argument: Base filename
#c
#c Note: it is not necessary to expand it here, since it was already
#c included in this module's header file.
#c
#startm AD_INCLUDE 01
#endm


#ccccccccccccccccccccccccccc
#c
#c Goes at the head of the file.
#c
#c Arguments: none
#c
#startm AD_HEAD 00
/******************************************\\
*                                          *
* Advanced Authoring Format                *
*                                          *
* Copyright (c) 1998 Avid Technology, Inc. *
* Copyright (c) 1998 Microsoft Corporation *
*                                          *
\\******************************************/

#include "C.this-module.h"
#include "Impl.this-module.h"

#include <assert.h>
#endm


#ccccccccccccccccccccccccccc
#c
#c AAFTypes support for IDL
#c
#c Arguments: none
#c
#startm AD_TYPES_HEAD 00
#endm


#ccccccccccccccccccccccccccc
#c
#c Starts a class definition
#c
#c Arguments: none
#c
#startm AD_CLASS_BEGIN 00


C.this-module::C.this-module (IUnknown * pControllingUnknown, aafBool doInit)
  : C.parent-module (pControllingUnknown, AAFFalse)
{
  if (doInit)
    {
#ifdef BOB_TEST
      Impl.this-module * newRep;
      newRep = new Impl.this-module;
      assert (newRep);
      InitRep (newRep);
#endif
    }
}


C.this-module::~C.this-module ()
{
//  Impl.this-module * rep;
//  rep = GetRepObject ();
//  assert (rep);
//  delete rep;
}
#endm


#ccccccccccccccccccccccccccc
#c
#c Starts a class definition
#c
#c Arguments: none
#c
#startm AD_COM_EXT_CLASS_BEGIN 01
AD_CLASS_BEGIN\
#endm


#ccccccccccccccccccccccccccc
#c
#c Starts a class definition with no parent class
#c
#c Arguments: none
#c
#startm AD_ROOT_CLASS_BEGIN 00
C.this-module::C.this-module (IUnknown * pControllingUnknown, aafBool doInit)
  : CAAFUnknown(pControllingUnknown),
    _rep(NULL)
{}


C.this-module::~C.this-module ()
{
#ifdef BOB_TEST
  // The base class destructor of Impl.this-module must be declared as virtual.
  if (_rep)
    delete _rep; 
#endif 
}


void C.this-module::InitRep (Impl.this-module * newRep)
{
#ifdef BOB_TEST
  assert (newRep);
  _rep = newRep;
  newRep->InitContainer (this);
#endif
}


Impl.this-module * C.this-module::GetRepObject ()
{
#ifdef BOB_TEST
  assert (_rep);
  return _rep;
#else
  return NULL;
#endif
}
#endm

#ccccccccccccccccccccccccccc
#c
#c Types definitions should only be used by idl and c++ & impl headers
#c 
#c
#c GUID
#c Argument01: hex long  0-3[leading 0's w/o leading 0x]
#c Argument02: hex short 4-5[leading 0's w/o leading 0x]
#c Argument03: hex short 6-7[leading 0's w/o leading 0x]
#c Argument04: hex byte   8 [leading 0's w/o leading 0x]
#c Argument05: hex byte   9 [leading 0's w/o leading 0x]
#c Argument06: hex byte  10 [leading 0's w/o leading 0x]
#c Argument07: hex byte  11 [leading 0's w/o leading 0x]
#c Argument08: hex byte  12 [leading 0's w/o leading 0x]
#c Argument09: hex byte  13 [leading 0's w/o leading 0x]
#c Argument10: hex byte  14 [leading 0's w/o leading 0x]
#c Argument11: hex byte  15 [leading 0's w/o leading 0x]
#c
#c Example:
#c AD_TYPES_BEGIN(b1a21372, 1a7d, 11d2, bf, 78, 00, 10, 4b, c9, 15, 6d)
#c
#c TomR:980716: Added
#c
#startm AD_TYPES_BEGIN 11
#endm


#ccccccccccccccccccccccccccc
#c
#c Ends a types definition
#c
#c Types definitions should only be used by idl and c++ & impl headers
#c
#c Arguments: none
#c
#startm AD_TYPES_END 00
#endm


#ccccccccccccccccccccccccccc
#c
#c Inserts declaration for a method which takes no arguments.
#c
#c Argument1: method name
#c Argument2: method description
#c
#startm AD_METHOD0 02
HRESULT STDMETHODCALLTYPE
    C.this-module::%01 ()
{
#ifdef BOB_TEST
  Impl.this-module * ptr;
  ImplAAFRoot * pO;
  pO = GetRepObject ();
  assert (pO);
  ptr = static_cast<Impl.this-module*> (pO);
  assert (ptr);
  return ptr->%01();
#else
  return HRESULT_NOT_IMPLEMENTED;
#endif
}
#endm


#ccccccccccccccccccccccccccc
#c
#c Inserts declaration for a method which takes one argument.
#c
#c Macro Arg 01: method name
#c
#c Macro arguments 02+:
#c 
#c meth arg #   arg modfrs   obj style   type    name    arg cmnt
#c ----------   ----------   ---------   ----    ----    --------
#c metharg 1    02           03          04      05      06
#c
#c Macro Arg 07: method description
#c
#startm AD_XMETHOD1 07
HRESULT STDMETHODCALLTYPE
    C.this-module::%01 (.%03-adornment%04 .%03-indirection %05)
{
#ifdef BOB_TEST
  HRESULT hr;

  Impl.this-module * ptr;
  ImplAAFRoot * pO;
  pO = GetRepObject ();
  assert (pO);
  ptr = static_cast<Impl.this-module*> (pO);
  assert (ptr);

.%03-setup(%04, %05)
  hr = ptr->%01 (.%03-internalname(%05));
.%03-cleanup(%04, %05)
  return hr;
#else
  return HRESULT_NOT_IMPLEMENTED;
#endif
}
#endm


#ccccccccccccccccccccccccccc
#c
#c Inserts declaration for a method which takes two arguments.
#c
#c Macro Arg 01: method name
#c
#c Macro arguments 02+:
#c 
#c meth arg #   arg modfrs   obj style   type    name    arg cmnt
#c ----------   ----------   ---------   ----    ----    --------
#c metharg 1    02           03          04      05      06
#c metharg 2    07           08          09      10      11
#c
#c Macro Arg 12: method description
#c
#startm AD_XMETHOD2 12
HRESULT STDMETHODCALLTYPE
    C.this-module::%01 (.%03-adornment%04 .%03-indirection %05,
		.%08-adornment%09 .%08-indirection %10)
{
#ifdef BOB_TEST
  HRESULT hr;

  Impl.this-module * ptr;
  ImplAAFRoot * pO;
  pO = GetRepObject ();
  assert (pO);
  ptr = static_cast<Impl.this-module*> (pO);
  assert (ptr);

.%03-setup(%04, %05)
.%08-setup(%09, %10)
  hr = ptr->%01 (.%03-internalname(%05),
	.%08-internalname(%10));
.%03-cleanup(%04, %05)
.%08-cleanup(%09, %10)
  return hr;
#else
  return HRESULT_NOT_IMPLEMENTED;
#endif
}
#endm


#ccccccccccccccccccccccccccc
#c
#c Inserts declaration for a method which takes three arguments.
#c
#c Macro Arg 01: method name
#c
#c Macro arguments 02+:
#c 
#c meth arg #   arg modfrs   obj style   type    name    arg cmnt
#c ----------   ----------   ---------   ----    ----    --------
#c metharg 1    02           03          04      05      06
#c metharg 2    07           08          09      10      11
#c metharg 3    12           13          14      15      16
#c
#c Macro Arg 17: method description
#c
#startm AD_XMETHOD3 17
HRESULT STDMETHODCALLTYPE
    C.this-module::%01 (.%03-adornment%04 .%03-indirection %05,
		.%08-adornment%09 .%08-indirection %10,
		.%13-adornment%14 .%13-indirection %15)
{
#ifdef BOB_TEST
  HRESULT hr;

  Impl.this-module * ptr;
  ImplAAFRoot * pO;
  pO = GetRepObject ();
  assert (pO);
  ptr = static_cast<Impl.this-module*> (pO);
  assert (ptr);

.%03-setup(%04, %05)
.%08-setup(%09, %10)
.%13-setup(%14, %15)
  hr = ptr->%01 (.%03-internalname(%05),
	.%08-internalname(%10),
	.%13-internalname(%15));
.%03-cleanup(%04, %05)
.%08-cleanup(%09, %10)
.%13-cleanup(%14, %15)
  return hr;
#else
  return HRESULT_NOT_IMPLEMENTED;
#endif
}
#endm


#ccccccccccccccccccccccccccc
#c
#c Inserts declaration for a method which takes four arguments.
#c
#c Macro Arg 01: method name
#c
#c Macro arguments 02+:
#c 
#c meth arg #   arg modfrs   obj style   type    name    arg cmnt
#c ----------   ----------   ---------   ----    ----    --------
#c metharg 1    02           03          04      05      06
#c metharg 2    07           08          09      10      11
#c metharg 3    12           13          14      15      16
#c metharg 4    17           18          19      20      21
#c
#c Macro Arg 22: method description
#c
#startm AD_XMETHOD4 22
HRESULT STDMETHODCALLTYPE
    C.this-module::%01 (.%03-adornment%04 .%03-indirection %05,
		.%08-adornment%09 .%08-indirection %10,
		.%13-adornment%14 .%13-indirection %15,
		.%18-adornment%19 .%18-indirection %20)
{
#ifdef BOB_TEST
  HRESULT hr;

  Impl.this-module * ptr;
  ImplAAFRoot * pO;
  pO = GetRepObject ();
  assert (pO);
  ptr = static_cast<Impl.this-module*> (pO);
  assert (ptr);

.%03-setup(%04, %05)
.%08-setup(%09, %10)
.%13-setup(%14, %15)
.%18-setup(%19, %20)
  hr = ptr->%01 (.%03-internalname(%05),
	.%08-internalname(%10),
	.%13-internalname(%15),
	.%18-internalname(%20));
.%03-cleanup(%04, %05)
.%08-cleanup(%09, %10)
.%13-cleanup(%14, %15)
.%18-cleanup(%19, %20)
  return hr;
#else
  return HRESULT_NOT_IMPLEMENTED;
#endif
}
#endm


#ccccccccccccccccccccccccccc
#c
#c Inserts declaration for a method which takes five arguments.
#c
#c Macro Arg 01: method name
#c
#c Macro arguments 02+:
#c 
#c meth arg #   arg modfrs   obj style   type    name    arg cmnt
#c ----------   ----------   ---------   ----    ----    --------
#c metharg 1    02           03          04      05      06
#c metharg 2    07           08          09      10      11
#c metharg 3    12           13          14      15      16
#c metharg 4    17           18          19      20      21
#c metharg 5    22           23          24      25      26
#c
#c Macro Arg 27: method description
#c
#startm AD_XMETHOD5 27
HRESULT STDMETHODCALLTYPE
    C.this-module::%01 (.%03-adornment%04 .%03-indirection %05,
		.%08-adornment%09 .%08-indirection %10,
		.%13-adornment%14 .%13-indirection %15,
		.%18-adornment%19 .%18-indirection %20,
		.%23-adornment%24 .%23-indirection %25)
{
#ifdef BOB_TEST
  HRESULT hr;

  Impl.this-module * ptr;
  ImplAAFRoot * pO;
  pO = GetRepObject ();
  assert (pO);
  ptr = static_cast<Impl.this-module*> (pO);
  assert (ptr);

.%03-setup(%04, %05)
.%08-setup(%09, %10)
.%13-setup(%14, %15)
.%18-setup(%19, %20)
.%23-setup(%24, %25)
  hr = ptr->%01 (.%03-internalname(%05),
	.%08-internalname(%10),
	.%13-internalname(%15),
	.%18-internalname(%20),
	.%23-internalname(%25));
.%03-cleanup(%04, %05)
.%08-cleanup(%09, %10)
.%13-cleanup(%14, %15)
.%18-cleanup(%19, %20)
.%23-cleanup(%24, %25)
  return hr;
#else
  return HRESULT_NOT_IMPLEMENTED;
#endif
}
#endm


#ccccccccccccccccccccccccccc
#c
#c Inserts declaration for a method which takes six arguments.
#c
#c Macro Arg 01: method name
#c
#c Macro arguments 02+:
#c 
#c meth arg #   arg modfrs   obj style   type    name    arg cmnt
#c ----------   ----------   ---------   ----    ----    --------
#c metharg 1    02           03          04      05      06
#c metharg 2    07           08          09      10      11
#c metharg 3    12           13          14      15      16
#c metharg 4    17           18          19      20      21
#c metharg 5    22           23          24      25      26
#c metharg 6    27           28          29      30      31
#c
#c Macro Arg 32: method description
#c
#startm AD_XMETHOD6 32
HRESULT STDMETHODCALLTYPE
    C.this-module::%01 (.%03-adornment%04 .%03-indirection %05,
		.%08-adornment%09 .%08-indirection %10,
		.%13-adornment%14 .%13-indirection %15,
		.%18-adornment%19 .%18-indirection %20,
		.%23-adornment%24 .%23-indirection %25,
		.%28-adornment%29 .%28-indirection %30)
{
#ifdef BOB_TEST
  HRESULT hr;

  Impl.this-module * ptr;
  ImplAAFRoot * pO;
  pO = GetRepObject ();
  assert (pO);
  ptr = static_cast<Impl.this-module*> (pO);
  assert (ptr);

.%03-setup(%04, %05)
.%08-setup(%09, %10)
.%13-setup(%14, %15)
.%18-setup(%19, %20)
.%23-setup(%24, %25)
.%28-setup(%29, %30)
  hr = ptr->%01 (.%03-internalname(%05),
	.%08-internalname(%10),
	.%13-internalname(%15),
	.%18-internalname(%20),
	.%23-internalname(%25),
	.%28-internalname(%30));
.%03-cleanup(%04, %05)
.%08-cleanup(%09, %10)
.%13-cleanup(%14, %15)
.%18-cleanup(%19, %20)
.%23-cleanup(%24, %25)
.%28-cleanup(%29, %30)
  return hr;
#else
  return HRESULT_NOT_IMPLEMENTED;
#endif
}
#endm


#ccccccccccccccccccccccccccc
#c
#c Inserts declaration for a method which takes seven arguments.
#c
#c Macro Arg 01: method name
#c
#c Macro arguments 02+:
#c 
#c meth arg #   arg modfrs   obj style   type    name    arg cmnt
#c ----------   ----------   ---------   ----    ----    --------
#c metharg 1    02           03          04      05      06
#c metharg 2    07           08          09      10      11
#c metharg 3    12           13          14      15      16
#c metharg 4    17           18          19      20      21
#c metharg 5    22           23          24      25      26
#c metharg 6    27           28          29      30      31
#c metharg 7    32           33          34      35      36
#c
#c Macro Arg 37: method description
#c
#startm AD_XMETHOD7 37
HRESULT STDMETHODCALLTYPE
    C.this-module::%01 (.%03-adornment%04 .%03-indirection %05,
		.%08-adornment%09 .%08-indirection %10,
		.%13-adornment%14 .%13-indirection %15,
		.%18-adornment%19 .%18-indirection %20,
		.%23-adornment%24 .%23-indirection %25,
		.%28-adornment%29 .%28-indirection %30,
		.%33-adornment%34 .%33-indirection %35)
{
#ifdef BOB_TEST
  HRESULT hr;

  Impl.this-module * ptr;
  ImplAAFRoot * pO;
  pO = GetRepObject ();
  assert (pO);
  ptr = static_cast<Impl.this-module*> (pO);
  assert (ptr);

.%03-setup(%04, %05)
.%08-setup(%09, %10)
.%13-setup(%14, %15)
.%18-setup(%19, %20)
.%23-setup(%24, %25)
.%28-setup(%29, %30)
.%33-setup(%34, %35)
  hr = ptr->%01 (.%03-internalname(%05),
	.%08-internalname(%10),
	.%13-internalname(%15),
	.%18-internalname(%20),
	.%23-internalname(%25),
	.%28-internalname(%30),
	.%33-internalname(%35));
.%03-cleanup(%04, %05)
.%08-cleanup(%09, %10)
.%13-cleanup(%14, %15)
.%18-cleanup(%19, %20)
.%23-cleanup(%24, %25)
.%28-cleanup(%29, %30)
.%33-cleanup(%34, %35)
  return hr;
#else
  return HRESULT_NOT_IMPLEMENTED;
#endif
}
#endm


#ccccccccccccccccccccccccccc
#c
#c Inserts declaration for a method which takes eight arguments.
#c
#c Macro Arg 01: method name
#c
#c Macro arguments 02+:
#c 
#c meth arg #   arg modfrs   obj style   type    name    arg cmnt
#c ----------   ----------   ---------   ----    ----    --------
#c metharg 1    02           03          04      05      06
#c metharg 2    07           08          09      10      11
#c metharg 3    12           13          14      15      16
#c metharg 4    17           18          19      20      21
#c metharg 5    22           23          24      25      26
#c metharg 6    27           28          29      30      31
#c metharg 7    32           33          34      35      36
#c metharg 8    37           38          39      40      41
#c
#c Macro Arg 42: method description
#c
#startm AD_XMETHOD8 42
HRESULT STDMETHODCALLTYPE
    C.this-module::%01 (.%03-adornment%04 .%03-indirection %05,
		.%08-adornment%09 .%08-indirection %10,
		.%13-adornment%14 .%13-indirection %15,
		.%18-adornment%19 .%18-indirection %20,
		.%23-adornment%24 .%23-indirection %25,
		.%28-adornment%29 .%28-indirection %30,
		.%33-adornment%34 .%33-indirection %35,
		.%38-adornment%39 .%38-indirection %40)
{
#ifdef BOB_TEST
  HRESULT hr;

  Impl.this-module * ptr;
  ImplAAFRoot * pO;
  pO = GetRepObject ();
  assert (pO);
  ptr = static_cast<Impl.this-module*> (pO);
  assert (ptr);

.%03-setup(%04, %05)
.%08-setup(%09, %10)
.%13-setup(%14, %15)
.%18-setup(%19, %20)
.%23-setup(%24, %25)
.%28-setup(%29, %30)
.%33-setup(%34, %35)
.%38-setup(%39, %40)
  hr = ptr->%01 (.%03-internalname(%05),
	.%08-internalname(%10),
	.%13-internalname(%15),
	.%18-internalname(%20),
	.%23-internalname(%25),
	.%28-internalname(%30),
	.%33-internalname(%35),
	.%38-internalname(%40));
.%03-cleanup(%04, %05)
.%08-cleanup(%09, %10)
.%13-cleanup(%14, %15)
.%18-cleanup(%19, %20)
.%23-cleanup(%24, %25)
.%28-cleanup(%29, %30)
.%33-cleanup(%34, %35)
.%38-cleanup(%39, %40)
  return hr;
#else
  return HRESULT_NOT_IMPLEMENTED;
#endif
}
#endm


#ccccccccccccccccccccccccccc
#c
#c Inserts declaration for a method which takes nine arguments.
#c
#c Macro Arg 01: method name
#c
#c Macro arguments 02+:
#c 
#c meth arg #   arg modfrs   obj style   type    name    arg cmnt
#c ----------   ----------   ---------   ----    ----    --------
#c metharg 1    02           03          04      05      06
#c metharg 2    07           08          09      10      11
#c metharg 3    12           13          14      15      16
#c metharg 4    17           18          19      20      21
#c metharg 5    22           23          24      25      26
#c metharg 6    27           28          29      30      31
#c metharg 7    32           33          34      35      36
#c metharg 8    37           38          39      40      41
#c metharg 9    42           43          44      45      46
#c
#c Macro Arg 47: method description
#c
#startm AD_XMETHOD9 47
HRESULT STDMETHODCALLTYPE
    C.this-module::%01 (.%03-adornment%04 .%03-indirection %05,
		.%08-adornment%09 .%08-indirection %10,
		.%13-adornment%14 .%13-indirection %15,
		.%18-adornment%19 .%18-indirection %20,
		.%23-adornment%24 .%23-indirection %25,
		.%28-adornment%29 .%28-indirection %30,
		.%33-adornment%34 .%33-indirection %35,
		.%38-adornment%39 .%38-indirection %40,
		.%43-adornment%44 .%43-indirection %45)
{
#ifdef BOB_TEST
  HRESULT hr;

  Impl.this-module * ptr;
  ImplAAFRoot * pO;
  pO = GetRepObject ();
  assert (pO);
  ptr = static_cast<Impl.this-module*> (pO);
  assert (ptr);

.%03-setup(%04, %05)
.%08-setup(%09, %10)
.%13-setup(%14, %15)
.%18-setup(%19, %20)
.%23-setup(%24, %25)
.%28-setup(%29, %30)
.%33-setup(%34, %35)
.%38-setup(%39, %40)
.%43-setup(%44, %45)
  hr = ptr->%01 (.%03-internalname(%05),
	.%08-internalname(%10),
	.%13-internalname(%15),
	.%18-internalname(%20),
	.%23-internalname(%25),
	.%28-internalname(%30),
	.%33-internalname(%35),
	.%38-internalname(%40),
	.%43-internalname(%45));
.%03-cleanup(%04, %05)
.%08-cleanup(%09, %10)
.%13-cleanup(%14, %15)
.%18-cleanup(%19, %20)
.%23-cleanup(%24, %25)
.%28-cleanup(%29, %30)
.%33-cleanup(%34, %35)
.%38-cleanup(%39, %40)
.%43-cleanup(%44, %45)
  return hr;
#else
  return HRESULT_NOT_IMPLEMENTED;
#endif
}
#endm


#ccccccccccccccccccccccccccc
#c
#c Inserts declaration for a method which takes ten arguments.
#c
#c Macro Arg 01: method name
#c
#c Macro arguments 02+:
#c 
#c meth arg #   arg modfrs   obj style   type    name    arg cmnt
#c ----------   ----------   ---------   ----    ----    --------
#c metharg 1    02           03          04      05      06
#c metharg 2    07           08          09      10      11
#c metharg 3    12           13          14      15      16
#c metharg 4    17           18          19      20      21
#c metharg 5    22           23          24      25      26
#c metharg 6    27           28          29      30      31
#c metharg 7    32           33          34      35      36
#c metharg 8    37           38          39      40      41
#c metharg 9    42           43          44      45      46
#c metharg 10   47           48          49      50      51
#c
#c Macro Arg 52: method description
#c
#startm AD_XMETHOD_10 52
HRESULT STDMETHODCALLTYPE
    C.this-module::%01 (.%03-adornment%04 .%03-indirection %05,
		.%08-adornment%09 .%08-indirection %10,
		.%13-adornment%14 .%13-indirection %15,
		.%18-adornment%19 .%18-indirection %20,
		.%23-adornment%24 .%23-indirection %25,
		.%28-adornment%29 .%28-indirection %30,
		.%33-adornment%34 .%33-indirection %35,
		.%38-adornment%39 .%38-indirection %40,
		.%43-adornment%44 .%43-indirection %45,
		.%48-adornment%49 .%48-indirection %50)
{
#ifdef BOB_TEST
  HRESULT hr;

  Impl.this-module * ptr;
  ImplAAFRoot * pO;
  pO = GetRepObject ();
  assert (pO);
  ptr = static_cast<Impl.this-module*> (pO);
  assert (ptr);

.%03-setup(%04, %05)
.%08-setup(%09, %10)
.%13-setup(%14, %15)
.%18-setup(%19, %20)
.%23-setup(%24, %25)
.%28-setup(%29, %30)
.%33-setup(%34, %35)
.%38-setup(%39, %40)
.%43-setup(%44, %45)
.%48-setup(%49, %50)
  hr = ptr->%01 (.%03-internalname(%05),
	.%08-internalname(%10),
	.%13-internalname(%15),
	.%18-internalname(%20),
	.%23-internalname(%25),
	.%28-internalname(%30),
	.%33-internalname(%35),
	.%38-internalname(%40),
	.%43-internalname(%45),
	.%48-internalname(%50));
.%03-cleanup(%04, %05)
.%08-cleanup(%09, %10)
.%13-cleanup(%14, %15)
.%18-cleanup(%19, %20)
.%23-cleanup(%24, %25)
.%28-cleanup(%29, %30)
.%33-cleanup(%34, %35)
.%38-cleanup(%39, %40)
.%43-cleanup(%44, %45)
.%48-cleanup(%49, %50)
  return hr;
#else
  return HRESULT_NOT_IMPLEMENTED;
#endif
}
#endm


#ccccccccccccccccccccccccccc
#c
#c Inserts declaration for a method which takes eleven arguments.
#c
#c Macro Arg 01: method name
#c
#c Macro arguments 02+:
#c 
#c meth arg #   arg modfrs   obj style   type    name    arg cmnt
#c ----------   ----------   ---------   ----    ----    --------
#c metharg 1    02           03          04      05      06
#c metharg 2    07           08          09      10      11
#c metharg 3    12           13          14      15      16
#c metharg 4    17           18          19      20      21
#c metharg 5    22           23          24      25      26
#c metharg 6    27           28          29      30      31
#c metharg 7    32           33          34      35      36
#c metharg 8    37           38          39      40      41
#c metharg 9    42           43          44      45      46
#c metharg 10   47           48          49      50      51
#c metharg 11   52           53          54      55      56
#c
#c Macro Arg 57: method description
#c
#startm AD_XMETHOD_11 57
HRESULT STDMETHODCALLTYPE
    C.this-module::%01 (.%03-adornment%04 .%03-indirection %05,
		.%08-adornment%09 .%08-indirection %10,
		.%13-adornment%14 .%13-indirection %15,
		.%18-adornment%19 .%18-indirection %20,
		.%23-adornment%24 .%23-indirection %25,
		.%28-adornment%29 .%28-indirection %30,
		.%33-adornment%34 .%33-indirection %35,
		.%38-adornment%39 .%38-indirection %40,
		.%43-adornment%44 .%43-indirection %45,
		.%48-adornment%49 .%48-indirection %50,
		.%53-adornment%54 .%53-indirection %55)
{
#ifdef BOB_TEST
  HRESULT hr;

  Impl.this-module * ptr;
  ImplAAFRoot * pO;
  pO = GetRepObject ();
  assert (pO);
  ptr = static_cast<Impl.this-module*> (pO);
  assert (ptr);

.%03-setup(%04, %05)
.%08-setup(%09, %10)
.%13-setup(%14, %15)
.%18-setup(%19, %20)
.%23-setup(%24, %25)
.%28-setup(%29, %30)
.%33-setup(%34, %35)
.%38-setup(%39, %40)
.%43-setup(%44, %45)
.%48-setup(%49, %50)
.%53-setup(%54, %55)
  hr = ptr->%01 (.%03-internalname(%05),
	.%08-internalname(%10),
	.%13-internalname(%15),
	.%18-internalname(%20),
	.%23-internalname(%25),
	.%28-internalname(%30),
	.%33-internalname(%35),
	.%38-internalname(%40),
	.%43-internalname(%45),
	.%48-internalname(%50),
	.%53-internalname(%55));
.%03-cleanup(%04, %05)
.%08-cleanup(%09, %10)
.%13-cleanup(%14, %15)
.%18-cleanup(%19, %20)
.%23-cleanup(%24, %25)
.%28-cleanup(%29, %30)
.%33-cleanup(%34, %35)
.%38-cleanup(%39, %40)
.%43-cleanup(%44, %45)
.%48-cleanup(%49, %50)
.%53-cleanup(%54, %55)
  return hr;
#else
  return HRESULT_NOT_IMPLEMENTED;
#endif
}
#endm


#ccccccccccccccccccccccccccc
#c
#c Ends a class definition
#c
#c Arguments: none
#c
#startm AD_CLASS_END 00
//
// 
// 
HRESULT C.this-module::InternalQueryInterface
(
	REFIID riid,
	void **ppvObj)
{
	HRESULT hr = S_OK;

	if (NULL == ppvObj)
		return E_INVALIDARG;

    // We only support the IClassFactory interface 
    if (riid == IID_I.this-module) 
    { 
        *ppvObj = (I.this-module *)this; 
        ((IUnknown *)*ppvObj)->AddRef();
		return S_OK;
    }

	// Always delegate back to base implementation.
	return C.parent-module::InternalQueryInterface(riid, ppvObj);
}

//
// Return private implementation pointer for delegation.
// NOTE: This is NOT the pointer to the COM object's implementation
// object!
//
HRESULT STDMETHODCALLTYPE
    C.this-module::GetImplRep(void **ppRep)
{
#ifdef BOB_TEST
    if (!ppRep)
        return E_INVALIDARG;
	*ppRep = static_cast<void *>(GetRepObject());
	return S_OK;
#else
    return HRESULT_NOT_IMPLEMENTED;
#endif
}

//
// Define the contrete object support implementation.
// 
AAF_DEFINE_FACTORY(.this-module)\
#endm


#ccccccccccccccccccccccccccc
#c
#c Ends a class definition for AAFRoot
#c
#c Arguments: none
#c
#startm AD_ROOT_CLASS_END 00
//
// 
// 
HRESULT C.this-module::InternalQueryInterface
(
	REFIID riid,
	void **ppvObj)
{
	HRESULT hr = S_OK;

	if (NULL == ppvObj)
		return E_INVALIDARG;

    // We only support the IClassFactory interface 
    if (riid == IID_I.this-module) 
    { 
        *ppvObj = (I.this-module *)this; 
        ((IUnknown *)*ppvObj)->AddRef();
		return S_OK;
    }

	// Always delegate back to base implementation.
	return CAAFUnknown::InternalQueryInterface(riid, ppvObj);
}

//
// Return private implementation pointer for delegation.
// NOTE: This is NOT the pointer to the COM object's implementation
// object!
//
HRESULT STDMETHODCALLTYPE
    C.this-module::GetImplRep (void **ppRep)
{
#ifdef BOB_TEST
	if (!ppRep)
		return E_INVALIDARG;  
	*ppRep = static_cast<void*>(GetRepObject());
	return S_OK;
#else
	return HRESULT_NOT_IMPLEMENTED;
#endif
}

//
// Define the contrete object support implementation.
// 
AAF_DEFINE_FACTORY(.this-module)

#endm


#ccccccccccccccccccccccccccc
#c
#c Specifies an overridden method
#c
#c Argument: method declaration
#c
#startm AD_OVERRIDE 01
#endm


#ccccccccccccccccccccccccccc
#c
#c Specifies a method in a separate COM interface.
#c
#c Argument: method declaration
#c
#startm AD_COM_METH 01
%01-com-meth-comc(.this-module)
#endm


#ccccccccccccccccccccccccccc
#c
#c Inserts declaration for a constructor which takes one argument.
#c Constructor name is assumed to be .this-module.
#c
#c Macro arguments 01+:
#c 
#c meth arg #   arg modfrs   obj style   type    name    arg cmnt
#c ----------   ----------   ---------   ----    ----    --------
#c metharg 1    01           02          03      04      05
#c
#c Macro Arg 06: method description
#c
#startm AD_XCONSTRUCTOR1 06
C.this-module::C.this-module (.%02-adornment%03 .%02-indirection %04)
{
.%02-setup(%03, %04)
  Impl.this-module * newRep;
  newRep = new Impl.this-module (.%02-internalname(%04));
  assert (newRep);
  InitRep (newRep);
.%02-cleanup(%03, %04)
}
#endm


#ccccccccccccccccccccccccccc
#c
#c Inserts declaration for a constructor which takes two arguments.
#c Constructor name is assumed to be .this-module.
#c
#c Macro arguments 01+:
#c 
#c meth arg #   arg modfrs   obj style   type    name    arg cmnt
#c ----------   ----------   ---------   ----    ----    --------
#c metharg 1    01           02          03      04      05
#c metharg 2    06           07          08      09      10
#c
#c Macro Arg 11: method description
#c
#startm AD_XCONSTRUCTOR2 11
C.this-module::C.this-module (.%02-adornment%03 .%02-indirection %04,
	.%07-adornment%08 .%07-indirection %09)
{
.%02-setup(%03, %04)
.%07-setup(%08, %09)
  Impl.this-module * newRep;
  newRep = new Impl.this-module (.%02-internalname(%04),
	.%07-internalname(%09));
  assert (newRep);
  InitRep (newRep);
.%02-cleanup(%03, %04)
.%07-cleanup(%08, %09)
}
#endm


#ccccccccccccccccccccccccccc
#c
#c Inserts declaration for a constructor which takes three arguments.
#c Constructor name is assumed to be .this-module.
#c
#c Macro arguments 01+:
#c 
#c meth arg #   arg modfrs   obj style   type    name    arg cmnt
#c ----------   ----------   ---------   ----    ----    --------
#c metharg 1    01           02          03      04      05
#c metharg 2    06           07          08      09      10
#c metharg 3    11           12          13      14      15
#c
#c Macro Arg 16: method description
#c
#startm AD_XCONSTRUCTOR3 16
C.this-module::C.this-module (.%02-adornment%03 .%02-indirection %04,
	.%07-adornment%08 .%07-indirection %09,
	.%12-adornment%13 .%12-indirection %14)
{
.%02-setup(%03, %04)
.%07-setup(%08, %09)
.%12-setup(%13, %14)
  Impl.this-module * newRep;
  newRep = new Impl.this-module (.%02-internalname(%04),
	.%07-internalname(%09),
	.%12-internalname(%14));
  assert (newRep);
  InitRep (newRep);
.%02-cleanup(%03, %04)
.%07-cleanup(%08, %09)
.%12-cleanup(%13, %14)
}
#endm


#ccccccccccccccccccccccccccc
#c
#c Inserts declaration for a constructor which takes four arguments.
#c Constructor name is assumed to be .this-module.
#c
#c Macro arguments 01+:
#c 
#c meth arg #   arg modfrs   obj style   type    name    arg cmnt
#c ----------   ----------   ---------   ----    ----    --------
#c metharg 1    01           02          03      04      05
#c metharg 2    06           07          08      09      10
#c metharg 3    11           12          13      14      15
#c metharg 4    16           17          18      19      20
#c
#c Macro Arg 21: method description
#c
#startm AD_XCONSTRUCTOR4 21
C.this-module::C.this-module (.%02-adornment%03 .%02-indirection %04,
							  .%07-adornment%08 .%07-indirection %09,
							  .%12-adornment%13 .%12-indirection %14,
							  .%17-adornment%18 .%17-indirection %19)
{
.%02-setup(%03, %04)
.%07-setup(%08, %09)
.%12-setup(%13, %14)
.%17-setup(%18, %19)
  Impl.this-module * newRep;
  newRep = new Impl.this-module (.%02-internalname(%04),
	.%07-internalname(%09),
	.%12-internalname(%14),
	.%17-internalname(%19));
  assert (newRep);
  InitRep (newRep);
.%02-cleanup(%03, %04)
.%07-cleanup(%08, %09)
.%12-cleanup(%13, %14)
.%17-cleanup(%08, %19)
}
#endm


#ccccccccccccccccccccccccccc
#c
#c Argument1: text to be quoted.
#c 
#c Ignore the input
#c
#c TomR:added 980714
#c
#startm AD_CPP_QUOTE 01
#endm


#ccccccccccccccccccccccccccc
#c
#c Argument1: base name to be converted to output type.
#c ingnore the input
#c
#startm AD_AAFTYPES 01
I%01\
#endm


#ccccccccccccccccccccccccccc
#c
#c Argument1: base name to be converted to output type.
#c Ignore input
#c
#startm AD_DECLARE_FORWARD_AAFTYPES 01
#endm


#ccccccccccccccccccccccccccc
#c
#c Generate a forward declaration of a class.
#c
#c Argument: class name
#c
#startm AD_FORWARD_DECLARATION 01
#include "C%01.h"
#include "Impl%01.h"
#endm

#ccccccccccccccccccccccccccc
#c
#c Defining the interface UUID.
#c NOTE: Should be placed immediately before AD_CLASS_BEGIN
#c
#c GUID
#c Argument01: hex long  0-3[leading 0's w/o leading 0x]
#c Argument02: hex short 4-5[leading 0's w/o leading 0x]
#c Argument03: hex short 6-7[leading 0's w/o leading 0x]
#c Argument04: hex byte   8 [leading 0's w/o leading 0x]
#c Argument05: hex byte   9 [leading 0's w/o leading 0x]
#c Argument06: hex byte  10 [leading 0's w/o leading 0x]
#c Argument07: hex byte  11 [leading 0's w/o leading 0x]
#c Argument08: hex byte  12 [leading 0's w/o leading 0x]
#c Argument09: hex byte  13 [leading 0's w/o leading 0x]
#c Argument10: hex byte  14 [leading 0's w/o leading 0x]
#c Argument11: hex byte  15 [leading 0's w/o leading 0x]
#c
#c Example:
#c AD_DEFAULT_UUID(b1a21372, 1a7d, 11d2, bf, 78, 00, 10, 4b, c9, 15, 6d)
#c
#c TomR:980713: Added
#c
#startm AD_DEFAULT_UUID 11
// Default Interface for .this-module 
// {%01-%02-%03-%04%05-%06%07%08%09%10%11}
const IID IID_I.this-module = { 0x%01, 0x%02, 0x%03, { 0x%04, 0x%05, 0x%06, 0x%07, 0x%08, 0x%09, 0x%10, 0x%11 } };
#endm


#ccccccccccccccccccccccccccc
#c
#c Defining the Class "Factory" UUID.
#c NOTE: should be placed before AD_DEFAULT_UUID or after
#c AD_CLASS_END
#c
#c GUID
#c Argument01: hex long  0-3[leading 0's w/o leading 0x]
#c Argument02: hex short 4-5[leading 0's w/o leading 0x]
#c Argument03: hex short 6-7[leading 0's w/o leading 0x]
#c Argument04: hex byte   8 [leading 0's w/o leading 0x]
#c Argument05: hex byte   9 [leading 0's w/o leading 0x]
#c Argument06: hex byte  10 [leading 0's w/o leading 0x]
#c Argument07: hex byte  11 [leading 0's w/o leading 0x]
#c Argument08: hex byte  12 [leading 0's w/o leading 0x]
#c Argument09: hex byte  13 [leading 0's w/o leading 0x]
#c Argument10: hex byte  14 [leading 0's w/o leading 0x]
#c Argument11: hex byte  15 [leading 0's w/o leading 0x]
#c
#c Example:
#c AD_CLASS_UUID(b1a21373, 1a7d, 11d2, bf, 78, 00, 10, 4b, c9, 15, 6d)
#c
#c TomR:980713: Added
#c
#startm AD_CLASS_UUID 11
// CLSID for .this-module 
// {%01-%02-%03-%04%05-%06%07%08%09%10%11}
const CLSID CLSID_.this-module = { 0x%01, 0x%02, 0x%03, { 0x%04, 0x%05, 0x%06, 0x%07, 0x%08, 0x%09, 0x%10, 0x%11 } };
#endm


#ccccccccccccccccccccccccccc
#c
#c Inserts declaration for a static method used to bootstrap an AAF
#c session by creating the first session object.
#c
#startm AD_BEGIN_SESSION 00
#endm

#ccccccccccccccccccccccccccc
#c
#c Inserts declaration for a static method used for a container to create
#c its contained objects in the cpp API.
#c
#startm AD_STATIC_CREATE 00
#endm

#ccccccccccccccccccccccccccc
#c
#c The following macros assist in passing arguments to methods of the
#c contained implementation class:
#c
#c The objIn macros are for use with pointers to objects that are
#c passed into the method.  The Type argument is the base type, with
#c no indirection specified.  For example, if you're passing in
#c AObject*, AObject should be specified for the Type argument.#c
#c
#c The objOut macros are for use with pointers to pointers to objects
#c that are passed out of the method.  The Type argument is the base
#c type, with no indirection specified.  For example, if you're
#c passing in AObject**, AObject should be specified for the Type
#c argument.
#c
#c The objPass macros are for use with any kind of data which is
#c passed exactly into or out of the method.
#c


#ccccccccccccccccccccccccccc
#c
#c #define .objIn-setup(T, externArg, internArg)
#c
#c arg1 = unadorned type
#c arg2 = external arg name
#c
#startm .objIn-setup 02
  Impl%01 * internal%02 = NULL;
  if (%02)
    {
	  HRESULT hStat;
	  IAAFRoot * iObj;
	  ImplAAFRoot *arg;
	  hStat = %02->QueryInterface (IID_IAAFRoot, (void **)&iObj);
	  assert (SUCCEEDED (hStat));
	  assert (iObj);
	  hStat = iObj->GetImplRep((void **)&arg);
	  assert (SUCCEEDED (hStat));
	  internal%02 = static_cast<Impl%01*>(arg);
	  assert (internal%02);
    }
#endm


#ccccccccccccccccccccccccccc
#c
#c #define .objPass-setup(T, externArg, internArg)		/* nothing */
#c
#c arg1 = unadorned type
#c arg2 = external arg name
#c
#startm .objPass-setup 02
#endm


#ccccccccccccccccccccccccccc
#c
#c #define .objOut-setup(T, externArg, internArg)
#c
#c arg1 = unadorned type
#c arg2 = external arg name
#c
#startm .objOut-setup 02
  Impl%01 * internal%02;
  Impl%01 ** pinternal%02 = NULL;
  if (%02)
    {
	  pinternal%02 = &internal%02;
    }
#endm


#ccccccccccccccccccccccccccc
#c
#c #define .objIn-internalname(externArg, internArg)	(internArg)
#c
#c arg1 = external arg name
#c
#startm .objIn-internalname 01
internal%01\
#endm


#ccccccccccccccccccccccccccc
#c
#c #define .objPass-internalname(externArg, internArg)	(internArg)
#c
#c arg1 = external arg name
#c
#startm .objPass-internalname 01
%01\
#endm


#ccccccccccccccccccccccccccc
#c
#c #define .objOut-internalname(externArg, internArg)	(internArg)
#c
#c arg1 = external arg name
#c
#startm .objOut-internalname 01
pinternal%01\
#endm


#ccccccccccccccccccccccccccc
#c
#c #define .objIn-cleanup(T, externArg, internArg)		/* nothing */
#c
#c arg1 = unadorned type
#c arg2 = external arg name
#c
#startm .objIn-cleanup 02
#endm


#ccccccccccccccccccccccccccc
#c
#c #define .objPass-cleanup(T, externArg, internArg)	/* nothing */
#c
#c arg1 = unadorned type
#c arg2 = external arg name
#c
#startm .objPass-cleanup 02
#endm


#ccccccccccccccccccccccccccc
#c
#c #define .objOut-cleanup(T, externArg, internArg)
#c
#c arg1 = unadorned type
#c arg2 = external arg name
#c
#startm .objOut-cleanup 02
	if (SUCCEEDED(hr))
	{
		IUnknown *pUnknown;
		HRESULT	hStat;

		pUnknown = static_cast<IUnknown *> (internal%02->GetContainer());
		hStat = pUnknown->QueryInterface(IID_I%01, (void **)%02);
		assert (SUCCEEDED (hStat));
		pUnknown->Release();
	}
	else
	{
		*%02 = NULL;
	}
#endm

#ccccccccccccccccccccccccccc
#c
#c The following macros assist in passing arguments to methods of the
#c contained implementation class:
#c
#c The objIn macros are for use with pointers to objects that are
#c passed into the method.  The Type argument is the base type, with
#c no indirection specified.  For example, if you're passing in
#c AObject*, AObject should be specified for the Type argument.#c
#c
#c The objOut macros are for use with pointers to pointers to objects
#c that are passed out of the method.  The Type argument is the base
#c type, with no indirection specified.  For example, if you're
#c passing in AObject**, AObject should be specified for the Type
#c argument.
#c
#c The objPass macros are for use with any kind of data which is
#c passed exactly into or out of the method.
#c


#startm .objIn-adornment 00
I\
#endm


#startm .objPass-adornment 00
#endm


#startm .objOut-adornment 00
I\
#endm


#ccccccccccccccccccccccccccc
#c
#c Hack to quote the .this-module macro and keep it out of export
#c files.  Do not define this macro in exp.mac!!!
#c
#startm AD_EXPORT_THIS_MODULE 00
.this-module\
#endm
