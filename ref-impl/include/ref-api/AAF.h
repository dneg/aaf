//=---------------------------------------------------------------------=
//
// This file was GENERATED for the AAF SDK
//
// The contents of this file are subject to the AAF SDK Public
// Source License Agreement (the "License"); You may not use this file
// except in compliance with the License.  The License is available in
// AAFSDKPSL.TXT, or you may obtain a copy of the License from the AAF
// Association or its successor.
//
// Software distributed under the License is distributed on an "AS IS"
// basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See
// the License for the specific language governing rights and limitations
// under the License.
//
// The Original Code of this file is Copyright 1998-2001, Licensor of the
// AAF Association.
//
// The Initial Developer of the Original Code of this file and the
// Licensor of the AAF Association is Avid Technology.
// All rights reserved.
//
//=---------------------------------------------------------------------=

//=--------------------------------------------------------------------------=
// AAF Interfaces.
//=--------------------------------------------------------------------------=
//
#ifndef __AAF_h__
#define __AAF_h__

#ifndef __AAFCOMPlatform_h__
#include "AAFCOMPlatform.h"
#endif

#ifndef __AAFTypes_h__
#include "AAFTypes.h"
#endif

#ifdef __cplusplus
interface IAAFAIFCDescriptor;
interface IAAFClassDef;
interface IAAFCodecDef;
interface IAAFCommentMarker;
interface IAAFComponent;
interface IAAFCompositionMob;
interface IAAFConstantValue;
interface IAAFContainerDef;
interface IAAFContentStorage;
interface IAAFControlPoint;
interface IAAFDataDef;
interface IAAFDefObject;
interface IAAFPluginDef;
interface IAAFDictionary;
interface IAAFEdgecode;
interface IAAFOperationDef;
interface IAAFEssenceAccess;
interface IAAFEssenceData;
interface IAAFEssenceDescriptor;
interface IAAFEvent;
interface IAAFEventMobSlot;
interface IAAFFile;
interface IAAFFileDescriptor;
interface IAAFFilmDescriptor;
interface IAAFDigitalImageDescriptor;
interface IAAFCDCIDescriptor;
interface IAAFEssenceFormat;
interface IAAFEssenceGroup;
interface IAAFFiller;
interface IAAFFindSourceInfo;
interface IAAFOperationGroup;
interface IAAFGPITrigger;
interface IAAFHeader;
interface IAAFIdentification;
interface IAAFInterpolationDef;
interface IAAFKLVData;
interface IAAFLocator;
interface IAAFMasterMob;
interface IAAFMetaDefinition;
interface IAAFMob;
interface IAAFMobSlot;
interface IAAFNestedScope;
interface IAAFNetworkLocator;
interface IAAFObject;
interface IAAFParameter;
interface IAAFParameterDef;
interface IAAFProperty;
interface IAAFPropertyDef;
interface IAAFPropertyValue;
interface IAAFPluginManager;
interface IAAFPulldown;
interface IAAFRGBADescriptor;
interface IAAFScopeReference;
interface IAAFSegment;
interface IAAFSelector;
interface IAAFSequence;
interface IAAFSourceClip;
interface IAAFSourceMob;
interface IAAFSourceReference;
interface IAAFStaticMobSlot;
interface IAAFTapeDescriptor;
interface IAAFTaggedValue;
interface IAAFTextLocator;
interface IAAFTimecode;
interface IAAFTimelineMobSlot;
interface IAAFTransition;
interface IAAFTIFFDescriptor;
interface IAAFTimecodeStream;
interface IAAFTimecodeStream12M;
interface IAAFTypeDef;
interface IAAFTypeDefCharacter;
interface IAAFTypeDefIndirect;
interface IAAFTypeDefInt;
interface IAAFTypeDefRename;
interface IAAFTypeDefEnum;
interface IAAFTypeDefExtEnum;
interface IAAFTypeDefFixedArray;
interface IAAFTypeDefRecord;
interface IAAFTypeDefSet;
interface IAAFTypeDefStream;
interface IAAFTypeDefString;
interface IAAFTypeDefStrongObjRef;
interface IAAFTypeDefWeakObjRef;
interface IAAFTypeDefObjectRef;
interface IAAFTypeDefOpaque;
interface IAAFTypeDefVariableArray;
interface IAAFVaryingValue;
interface IAAFWAVEDescriptor;
interface IEnumAAFClassDefs;
interface IEnumAAFCodecDefs;
interface IEnumAAFCodecFlavours;
interface IEnumAAFComponents;
interface IEnumAAFContainerDefs;
interface IEnumAAFControlPoints;
interface IEnumAAFDataDefs;
interface IEnumAAFIdentifications;
interface IEnumAAFInterpolationDefs;
interface IEnumAAFOperationDefs;
interface IEnumAAFEssenceData;
interface IEnumAAFKLVData;
interface IEnumAAFLoadedPlugins;
interface IEnumAAFLocators;
interface IEnumAAFMobSlots;
interface IEnumAAFMobs;
interface IEnumAAFParameterDefs;
interface IEnumAAFParameters;
interface IEnumAAFProperties;
interface IEnumAAFPropertyDefs;
interface IEnumAAFPropertyValues;
interface IEnumAAFPluginDefs;
interface IEnumAAFPluginLocators;
interface IEnumAAFSegments;
interface IEnumAAFTaggedValues;
interface IEnumAAFTypeDefs;
interface IAAFRawStorage;
interface IAAFRandomRawStorage;
interface IAAFGetFileBits;
interface IAAFSetFileBits;
interface IAAFRandomFile;
interface IAAFEndian;
interface IAAFSearchSource;
interface IAAFEssenceMultiAccess;
interface IAAFTypeDefVariableArrayEx;
#else
typedef interface IAAFAIFCDescriptor IAAFAIFCDescriptor;
typedef interface IAAFClassDef IAAFClassDef;
typedef interface IAAFCodecDef IAAFCodecDef;
typedef interface IAAFCommentMarker IAAFCommentMarker;
typedef interface IAAFComponent IAAFComponent;
typedef interface IAAFCompositionMob IAAFCompositionMob;
typedef interface IAAFConstantValue IAAFConstantValue;
typedef interface IAAFContainerDef IAAFContainerDef;
typedef interface IAAFContentStorage IAAFContentStorage;
typedef interface IAAFControlPoint IAAFControlPoint;
typedef interface IAAFDataDef IAAFDataDef;
typedef interface IAAFDefObject IAAFDefObject;
typedef interface IAAFPluginDef IAAFPluginDef;
typedef interface IAAFDictionary IAAFDictionary;
typedef interface IAAFEdgecode IAAFEdgecode;
typedef interface IAAFOperationDef IAAFOperationDef;
typedef interface IAAFEssenceAccess IAAFEssenceAccess;
typedef interface IAAFEssenceData IAAFEssenceData;
typedef interface IAAFEssenceDescriptor IAAFEssenceDescriptor;
typedef interface IAAFEvent IAAFEvent;
typedef interface IAAFEventMobSlot IAAFEventMobSlot;
typedef interface IAAFFile IAAFFile;
typedef interface IAAFFileDescriptor IAAFFileDescriptor;
typedef interface IAAFFilmDescriptor IAAFFilmDescriptor;
typedef interface IAAFDigitalImageDescriptor IAAFDigitalImageDescriptor;
typedef interface IAAFCDCIDescriptor IAAFCDCIDescriptor;
typedef interface IAAFEssenceFormat IAAFEssenceFormat;
typedef interface IAAFEssenceGroup IAAFEssenceGroup;
typedef interface IAAFFiller IAAFFiller;
typedef interface IAAFFindSourceInfo IAAFFindSourceInfo;
typedef interface IAAFOperationGroup IAAFOperationGroup;
typedef interface IAAFGPITrigger IAAFGPITrigger;
typedef interface IAAFHeader IAAFHeader;
typedef interface IAAFIdentification IAAFIdentification;
typedef interface IAAFInterpolationDef IAAFInterpolationDef;
typedef interface IAAFKLVData IAAFKLVData;
typedef interface IAAFLocator IAAFLocator;
typedef interface IAAFMasterMob IAAFMasterMob;
typedef interface IAAFMetaDefinition IAAFMetaDefinition;
typedef interface IAAFMob IAAFMob;
typedef interface IAAFMobSlot IAAFMobSlot;
typedef interface IAAFNestedScope IAAFNestedScope;
typedef interface IAAFNetworkLocator IAAFNetworkLocator;
typedef interface IAAFObject IAAFObject;
typedef interface IAAFParameter IAAFParameter;
typedef interface IAAFParameterDef IAAFParameterDef;
typedef interface IAAFProperty IAAFProperty;
typedef interface IAAFPropertyDef IAAFPropertyDef;
typedef interface IAAFPropertyValue IAAFPropertyValue;
typedef interface IAAFPluginManager IAAFPluginManager;
typedef interface IAAFPulldown IAAFPulldown;
typedef interface IAAFRGBADescriptor IAAFRGBADescriptor;
typedef interface IAAFScopeReference IAAFScopeReference;
typedef interface IAAFSegment IAAFSegment;
typedef interface IAAFSelector IAAFSelector;
typedef interface IAAFSequence IAAFSequence;
typedef interface IAAFSourceClip IAAFSourceClip;
typedef interface IAAFSourceMob IAAFSourceMob;
typedef interface IAAFSourceReference IAAFSourceReference;
typedef interface IAAFStaticMobSlot IAAFStaticMobSlot;
typedef interface IAAFTapeDescriptor IAAFTapeDescriptor;
typedef interface IAAFTaggedValue IAAFTaggedValue;
typedef interface IAAFTextLocator IAAFTextLocator;
typedef interface IAAFTimecode IAAFTimecode;
typedef interface IAAFTimelineMobSlot IAAFTimelineMobSlot;
typedef interface IAAFTransition IAAFTransition;
typedef interface IAAFTIFFDescriptor IAAFTIFFDescriptor;
typedef interface IAAFTimecodeStream IAAFTimecodeStream;
typedef interface IAAFTimecodeStream12M IAAFTimecodeStream12M;
typedef interface IAAFTypeDef IAAFTypeDef;
typedef interface IAAFTypeDefCharacter IAAFTypeDefCharacter;
typedef interface IAAFTypeDefIndirect IAAFTypeDefIndirect;
typedef interface IAAFTypeDefInt IAAFTypeDefInt;
typedef interface IAAFTypeDefRename IAAFTypeDefRename;
typedef interface IAAFTypeDefEnum IAAFTypeDefEnum;
typedef interface IAAFTypeDefExtEnum IAAFTypeDefExtEnum;
typedef interface IAAFTypeDefFixedArray IAAFTypeDefFixedArray;
typedef interface IAAFTypeDefRecord IAAFTypeDefRecord;
typedef interface IAAFTypeDefSet IAAFTypeDefSet;
typedef interface IAAFTypeDefStream IAAFTypeDefStream;
typedef interface IAAFTypeDefString IAAFTypeDefString;
typedef interface IAAFTypeDefStrongObjRef IAAFTypeDefStrongObjRef;
typedef interface IAAFTypeDefWeakObjRef IAAFTypeDefWeakObjRef;
typedef interface IAAFTypeDefObjectRef IAAFTypeDefObjectRef;
typedef interface IAAFTypeDefOpaque IAAFTypeDefOpaque;
typedef interface IAAFTypeDefVariableArray IAAFTypeDefVariableArray;
typedef interface IAAFVaryingValue IAAFVaryingValue;
typedef interface IAAFWAVEDescriptor IAAFWAVEDescriptor;
typedef interface IEnumAAFClassDefs IEnumAAFClassDefs;
typedef interface IEnumAAFCodecDefs IEnumAAFCodecDefs;
typedef interface IEnumAAFCodecFlavours IEnumAAFCodecFlavours;
typedef interface IEnumAAFComponents IEnumAAFComponents;
typedef interface IEnumAAFContainerDefs IEnumAAFContainerDefs;
typedef interface IEnumAAFControlPoints IEnumAAFControlPoints;
typedef interface IEnumAAFDataDefs IEnumAAFDataDefs;
typedef interface IEnumAAFIdentifications IEnumAAFIdentifications;
typedef interface IEnumAAFInterpolationDefs IEnumAAFInterpolationDefs;
typedef interface IEnumAAFOperationDefs IEnumAAFOperationDefs;
typedef interface IEnumAAFEssenceData IEnumAAFEssenceData;
typedef interface IEnumAAFKLVData IEnumAAFKLVData;
typedef interface IEnumAAFLoadedPlugins IEnumAAFLoadedPlugins;
typedef interface IEnumAAFLocators IEnumAAFLocators;
typedef interface IEnumAAFMobSlots IEnumAAFMobSlots;
typedef interface IEnumAAFMobs IEnumAAFMobs;
typedef interface IEnumAAFParameterDefs IEnumAAFParameterDefs;
typedef interface IEnumAAFParameters IEnumAAFParameters;
typedef interface IEnumAAFProperties IEnumAAFProperties;
typedef interface IEnumAAFPropertyDefs IEnumAAFPropertyDefs;
typedef interface IEnumAAFPropertyValues IEnumAAFPropertyValues;
typedef interface IEnumAAFPluginDefs IEnumAAFPluginDefs;
typedef interface IEnumAAFPluginLocators IEnumAAFPluginLocators;
typedef interface IEnumAAFSegments IEnumAAFSegments;
typedef interface IEnumAAFTaggedValues IEnumAAFTaggedValues;
typedef interface IEnumAAFTypeDefs IEnumAAFTypeDefs;
typedef interface IAAFRawStorage IAAFRawStorage;
typedef interface IAAFRandomRawStorage IAAFRandomRawStorage;
typedef interface IAAFGetFileBits IAAFGetFileBits;
typedef interface IAAFSetFileBits IAAFSetFileBits;
typedef interface IAAFRandomFile IAAFRandomFile;
typedef interface IAAFEndian IAAFEndian;
typedef interface IAAFSearchSource IAAFSearchSource;
typedef interface IAAFEssenceMultiAccess IAAFEssenceMultiAccess;
typedef interface IAAFTypeDefVariableArrayEx IAAFTypeDefVariableArrayEx;
#endif

// IAAFAIFCDescriptor

// ************************
//
// Interface IAAFAIFCDescriptor
//
// ************************





#ifndef __IAAFAIFCDescriptor_INTERFACE_DEFINED__
#define __IAAFAIFCDescriptor_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFAIFCDescriptor;

#undef  INTERFACE
#define INTERFACE   IAAFAIFCDescriptor

DECLARE_INTERFACE_(IAAFAIFCDescriptor, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFAIFCDescriptor methods *** */

  //***********************************************************
  //
  // Initialize()
  //
  // Initializes a newly allocated, empty
  // IAAFAIFCDescriptor-supporting object.  This method must be
  // called after allocation, and before any other method can be
  // called.
  //
  // Succeeds if:
  // - Initialize() has not yet been called on this object.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_ALREADY_INITIALIZED
  //   - Initialize() has already been called on this object.
  STDMETHOD(Initialize) (THIS) PURE;


  //***********************************************************
  //
  // GetSummary()
  //
  // Gets a copy of the AIFC file information without the media.
  // 
  // Succeeds if all of the following are true:
  // - pSummary is a valid pointer.
  // - The size of the buffer is large enough to hold the AIFC file information.
  // 
  // If this method fails pSummary will not be changed.
  // 
  // This method will return the following codes:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.
  //
  // AAFRESULT_NULL_PARAM
  //   - pSummary arg is NULL.
  //
  // AAFRESULT_SMALLBUF
  //   - The buffer is too small to hold the AIFC file information.
  //
  //
  STDMETHOD(GetSummary) (THIS_
    // Size of preallocated buffer
    /*[in]*/ aafUInt32  size,

    // Preallocated buffer to hold the AIFC file information
    /*[out, size_is(size)]*/ aafDataValue_t  pSummary) PURE;

  //***********************************************************
  //
  // GetSummaryBufferSize()
  //
  // Returns the size of the buffer required for the GetSummary()
  // method.  The value is placed into the location specified by pSize.
  //
  // Succeeds if all of the following are true:
  // - the pSize pointer is valid.
  //
  // If this method fails nothing will be written to *pSize.
  //
  // This method will return the following codes:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.
  //
  // AAFRESULT_NULL_PARAM
  //   - pSize arg is NULL.
  //
  //
  STDMETHOD(GetSummaryBufferSize) (THIS_
    // required buffer size
    /*[out]*/ aafUInt32 *  pSize) PURE;

  //***********************************************************
  //
  // SetSummary()
  //
  // Sets the AIFC file information.
  // 
  // Succeeds if all of the following are true:
  // - pSummary is a valid pointer
  // 
  // If this method fails the summary property will not be
  // changed.
  // 
  // This method will return the following codes:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.
  //
  // AAFRESULT_NULL_PARAM
  //   - pSummary arg is NULL.
  //
  //
  STDMETHOD(SetSummary) (THIS_
    // Size of preallocated buffer
    /*[in]*/ aafUInt32  size,

    // buffer containing value
    /*[in, size_is(size)]*/ aafDataValue_t  pSummary) PURE;



  END_INTERFACE
};
#endif // __IAAFAIFCDescriptor_INTERFACE_DEFINED__



// IAAFClassDef

// ************************
//
// Interface IAAFClassDef
//
// ************************











#ifndef __IAAFClassDef_INTERFACE_DEFINED__
#define __IAAFClassDef_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFClassDef;

#undef  INTERFACE
#define INTERFACE   IAAFClassDef

DECLARE_INTERFACE_(IAAFClassDef, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFClassDef methods *** */

  //***********************************************************
  //
  // Initialize()
  //
  // Initializes this class definition object to inherit from the
  // given parent class.  If isConcrete is set to AAFTrue, objects of
  // this class can be instantiated; otherwise, it will be illegal to
  // instantiate such objects.
  // 
  // Succeeds if:
  // - The pID pointer is valid.
  // - The pParentClass pointer is valid.
  // - The pTypeName pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pID, pParentClass, or pTypeName arg is NULL.
  //
  STDMETHOD(Initialize) (THIS_
    // auid to be used to identify this type
    /*[in, ref]*/ aafUID_constref  classID,

    // existing class from which this one inherits
    /*[in]*/ IAAFClassDef * pParentClass,

    // friendly name of this type definition
    /*[in, string]*/ aafCharacter_constptr  pClassName,

    // can objects of this class be instantiated
    /*[in]*/ aafBoolean_t  isConcrete) PURE;


  //***********************************************************
  //
  // GetPropertyDefs()
  //
  // Returns an enumerator over all of the aaf property definitions
  // attached to the current class.
  // 
  // Succeeds if:
  // - The ppEnum pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppEnum arg is NULL.
  //
  STDMETHOD(GetPropertyDefs) (THIS_
    // Property Definition enumeration
    /*[out, retval]*/ IEnumAAFPropertyDefs ** ppEnum) PURE;


  //***********************************************************
  //
  // CountPropertyDefs()
  //
  // Returns number of property definitions in this class.
  // 
  // Succeeds if:
  // - The pCount pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pCount arg is NULL.
  //
  STDMETHOD(CountPropertyDefs) (THIS_
    // number of properties contained in this class definition
    /*[out]*/ aafUInt32 *  pCount) PURE;


  //***********************************************************
  //
  // RegisterNewPropertyDef()
  //
  // Creates a new property definition and registers it in this class
  // definition.  If ppPropDef is non-NULL, will return the new
  // property definition in ppPropDef.
  // 
  // Note that it is illegal to add mandatory properties to an
  // existing (registered) class.  This method will allow adding
  // either optional or mandatory properties to a class, but they must
  // be added to a class which has not yet been registered in the
  // dictionary.  If this class has already been registered, it is
  // possible to add optional properties, but not through this
  // method.  Optional properties added to an existing (registered)
  // class may be added through the RegisterOptionalPropertyDef()
  // method.
  // 
  // Succeeds if:
  // - The pID pointer is valid.
  // - The pName pointer is valid.
  // - The pTypeDef pointer is valid.
  // - This class has not already been registered in the dictionary.
  // - The auid specified by pID has not already been registered.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - either pName or pTypeDef arg is NULL.
  //
  // AAFRESULT_OBJECT_ALREADY_ATTACHED
  //   - This class has already been registered.
  //
  // AAFRESULT_ALREADY_UNIQUELY_INDENTIFED
  //   - This class already has a unique indentifier property.
  //
  // AAFRESULT_BAD_PARAM
  //   - The given ID has already been registered.
  //
  STDMETHOD(RegisterNewPropertyDef) (THIS_
    // auid to be used to identify this property
    /*[in, ref]*/ aafUID_constref  id,

    // name of the new property
    /*[in, string]*/ aafCharacter_constptr  pName,

    // type of the new property
    /*[in]*/ IAAFTypeDef * pTypeDef,

    // true if new property is to be optional
    /*[in]*/ aafBoolean_t  isOptional,

    // true if new property is to be the unique identifier of the class
    /*[in]*/ aafBoolean_t  isUniqueIdentifier,

    // return pointer to newly created property def
    /*[out]*/ IAAFPropertyDef ** ppPropDef) PURE;


  //***********************************************************
  //
  // RegisterOptionalPropertyDef()
  //
  // Creates a new property definition and registers it in this class
  // definition.  If ppPropDef is non-NULL, will return the new
  // property definition in ppPropDef.
  //
  // Note that it is illegal to add mandatory properties to an already
  // existing (registered) class.  It is assumed that this property is
  // being added to a class which is already registered.  If so, it
  // must be optional and this method will declare it so.  If it is
  // wished to add a mandatory property, that may be done through the
  // RegisterNewPropertyDef() method, but that must be called on a class
  // which is not yet registered.
  // 
  // Succeeds if:
  // - The pID pointer is valid.
  // - The pName pointer is valid.
  // - The pTypeDef pointer is valid.
  // - The auid specified by pID has not already been registered.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - either pName or pTypeDef arg is NULL.
  //
  // AAFRESULT_BAD_PARAM
  //   - The given ID has already been registered.
  //
  STDMETHOD(RegisterOptionalPropertyDef) (THIS_
    // auid to be used to identify this property
    /*[in, ref]*/ aafUID_constref  id,

    // name of the new property
    /*[in, string]*/ aafCharacter_constptr  pName,

    // type of the new property
    /*[in]*/ IAAFTypeDef * pTypeDef,

    // return pointer to newly created property def
    /*[out]*/ IAAFPropertyDef ** ppPropDef) PURE;


  //***********************************************************
  //
  // LookupPropertyDef()
  //
  // Looks up the property definition corresponding to the named auid
  // and returns a pointer to that property definition in ppPropDef.
  // 
  // Succeeds if:
  // - The pPropID pointer is valid.
  // - The ppPropDef pointer is valid.
  // - the auid specified by pID has been registered as a property
  //   definition for this class definition.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppPropDef arg is NULL.
  //
  // AAFRESULT_BAD_PARAM
  //   - The given ID has not been registered as a property
  //     definition.
  //
  STDMETHOD(LookupPropertyDef) (THIS_
    // auid reprepresenting property to look up
    /*[in, ref]*/ aafUID_constref  propID,

    // resulting property definition
    /*[out]*/ IAAFPropertyDef ** ppPropDef) PURE;


  //***********************************************************
  //
  // GetName()
  //
  // Gets Accesses a human-readable name for the class.  This name is not
  // meant to be a way for programs to refer to the class, as it is
  // of undetermined length, and is not checked to guarantee
  // uniqueness.
  // 
  // Writes the Name property, with a trailing null
  // character, into the pName buffer.  The
  // buffer is allocated by the caller.  The size of the buffer is
  // given by bufSize.  If the Name property has not yet
  // been set, a zero-length string will be written (that is,
  // only the trailing null character). 
  // 
  // Caller may call GetNameBufLen() to determine the
  // required buffer size.
  // 
  // If this method fails nothing will be written to
  // *pName.
  // 
  // Succeeds if:
  // - The pName pointer is valid.
  // - bufSize indicates that the buffer is large enough to hold
  //   Name.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pName arg is NULL.
  //
  // AAFRESULT_SMALL_BUF
  //   - bufSize indicates that the allocated buffer is not large
  //     enough to hold Name.
  //
  STDMETHOD(GetName) (THIS_
    // buffer into which Name is to be written
    /*[out, string, size_is(bufSize)]*/ aafCharacter *  pName,

    // size of *pName buffer in bytes
    /*[in]*/ aafUInt32  bufSize) PURE;


  //***********************************************************
  //
  // GetNameBufLen()
  //
  // Returns size of buffer (in bytes) required for GetName().
  // 
  // Succeeds if:
  // - The pBufSize pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pBufSize arg is NULL.
  //
  STDMETHOD(GetNameBufLen) (THIS_
    // size of required buffer, in bytes
    /*[out]*/ aafUInt32 *  pBufSize) PURE;


  //***********************************************************
  //
  // GetParent()
  //
  // Gets the Parent class for this object.  If there is no parent,
  // returns the result AAFRESULT_NO_PARENT.  The only class which has no parent will
  // be AAFObject.
  // 
  // Succeeds if:
  // - The ppClassDef pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pClassDef arg is NULL.
  //
  STDMETHOD(GetParent) (THIS_
    // parent class definition
    /*[out, retval]*/ IAAFClassDef ** ppClassDef) PURE;


  //***********************************************************
  //
  // IsConcrete()
  //
  // Returns true if this class can be instantiated; returns false
  // otherwise. 
  // 
  // Succeeds if:
  // - The ppClassDef pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pResult arg is NULL.
  //
  STDMETHOD(IsConcrete) (THIS_
    // Can this class be instantiated
    /*[out, retval]*/ aafBoolean_t*  pResult) PURE;


  //***********************************************************
  //
  // IsRoot()
  //
  // Returns true if this class is the base of the inheritance
  // hierarchy; returns false otherwise.
  // 
  // Succeeds if:
  // - The ppClassDef pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - isRoot arg is NULL.
  //
  STDMETHOD(IsRoot) (THIS_
    // Is this a root (base) class
    /*[out, retval]*/ aafBoolean_t*  isRoot) PURE;


  //***********************************************************
  //
  // IsUniquelyIdentified()
  //
  // Returns true if this class is uniquely identified.
  // 
  // Succeeds if:
  // - The pIsUniquelyIdentified pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pIsUniquelyIdentified arg is NULL.
  //
  STDMETHOD(IsUniquelyIdentified) (THIS_
    // Is this a UniquelyIdentified class
    /*[out, retval]*/ aafBoolean_t*  pIsUniquelyIdentified) PURE;


  //***********************************************************
  //
  // GetUniqueIdentifier()
  //
  // Returns the property definition corresponding to this class'
  // unique identifier.
  // 
  // Succeeds if:
  // - The ppUniqueIdentifier pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppUniqueIdentifier arg is NULL.
  //
  // AAFRESULT_PROP_NOT_PRESENT
  //   - If this class definition does not have a unique identifier
  //     property definition.
  //
  STDMETHOD(GetUniqueIdentifier) (THIS_
    // The unique identifier
    /*[out, retval]*/ IAAFPropertyDef ** ppUniqueIdentifier) PURE;


  //***********************************************************
  //
  // CreateInstance()
  //
  // Creates an object of this class, and returns it by reference in
  // the location specified by the ppObject argument.
  // 
  // Succeeds if:
  // - The ppObject pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppObject arg is NULL. 
  // 
  STDMETHOD(CreateInstance)(THIS_
    // Reference to the identifier of the interface
    REFIID riid,

    // Address of output variable that receives the 
    // interface pointer requested in riid
    IUnknown ** ppvObject) PURE;


  END_INTERFACE
};
#endif // __IAAFClassDef_INTERFACE_DEFINED__



// IAAFCodecDef

// ************************
//
// Interface IAAFCodecDef
//
// ************************






#ifndef __IAAFCodecDef_INTERFACE_DEFINED__
#define __IAAFCodecDef_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFCodecDef;

#undef  INTERFACE
#define INTERFACE   IAAFCodecDef

DECLARE_INTERFACE_(IAAFCodecDef, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFCodecDef methods *** */

  //***********************************************************
  //
  // Initialize()
  //
  // Init all fields of a definition object.
  //
  STDMETHOD(Initialize) (THIS_
    // AUID for new DeObject
    /*[in, ref]*/ aafUID_constref  id,

    // Name for new DefObject
    /*[in, string]*/ aafCharacter_constptr  pName,

    // Description for new DefObject
    /*[in, string]*/ aafCharacter_constptr  pDescription) PURE;


  //***********************************************************
  //
  // IsEssenceKindSupported()
  //
  // Returns AAFTrue if the given codec support transfers to essence
  // of the given essence kind.
  // 
  // Succeeds if all of the following are true:
  // - the pEssenceKind pointer is valid.
  // - the pIsSupported pointer is valid.
  // 
  // If this method fails nothing will be written to *pIsSupported.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pEssenceKind or pIsSupported is null.
  //
  STDMETHOD(IsEssenceKindSupported) (THIS_
    // The essence kind
    /*[in]*/ IAAFDataDef * pEssenceKind,

    // Is this type supported
    /*[out,retval]*/ aafBoolean_t*  pIsSupported) PURE;

 
  //***********************************************************
  //
  // AddEssenceKind()
  //
  // Appends the given essence kind to those supported by the codec.
  // This is dependant upon the format, not an incomplete implementation.
  // 
  // If this method fails no state will be changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pEssenceKind is null.
  //
  // AAFRESULT_DUPLICATE_ESSENCE_KIND
  //   - the given essenceKind is already contained.
  //
  STDMETHOD(AddEssenceKind) (THIS_
    // The essence kind
    /*[in]*/ IAAFDataDef * pEssenceKind) PURE;


  //***********************************************************
  //
  // RemoveEssenceKind()
  //
  // Removes the given essence kind from the list of those supported
  // by the codec.
  // 
  // If this method fails no state will be changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pEssenceKind is null.
  //
  // AAFRESULT_OBJECT_NOT_FOUND
  //   - the given essenceKind is not already contained.
  //
  STDMETHOD(RemoveEssenceKind) (THIS_
    // The essence kind to remove
    /*[in]*/ IAAFDataDef * pEssenceKind) PURE;


  //***********************************************************
  //
  // CountEssenceKinds()
  //
  // Places the number of supported essence kinds into *pResult.
  // 
  // If this method fails nothing will be written to *pResult.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pResult is NULL.
  //
  STDMETHOD(CountEssenceKinds) (THIS_
    // The number of essence kinds
    /*[out, retval]*/ aafUInt32 *  pResult) PURE;


  //***********************************************************
  //
  // GetEssenceKinds()
  //
  // Places an IEnumAAFDataDefs enumerator for the essence kinds
  // contained in the sequence into the *ppEnum argument.
  // 
  // The returned enumerator is AddRef()ed before it is returned.
  //
  // Succeeds if all of the following are true:
  // - this object has already been initialized.
  // - the ppEnum pointer is valid.
  // 
  // If this method fails nothing will be written to *ppEnum.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - Initialize() has already been called on this object.
  //
  // AAFRESULT_NULL_PARAM
  //   - ppEnum is null.
  //
  // E_FAIL
  //   - Failed to create the enumerator.
  //
  STDMETHOD(GetEssenceKinds) (THIS_
    // Essence Kind Enumeration
    /*[out, retval]*/ IEnumAAFDataDefs ** ppEnum) PURE;


  //***********************************************************
  //
  // AreThereFlavours()
  //
  // Find out whether its worth iterating over flavours.  Flavours are
  // used when a single codec can support multiple formats.  An
  // example would be a codec which would accept a "resolution ID"
  // for a particular manufacturer and set up all of the parameters.
  // When a new resolution ID is released, then a new codec plugin
  // would give users the ability to use the new resolutions without
  // upgrading the application.
  //
  // Succeeds if all of the following are true:
  // - the pResult pointer is valid.
  // 
  // If this method fails no state will be changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - if Result is null.
  //
  STDMETHOD(AreThereFlavours) (THIS_
    // True if there are flavours of this codec
    /*[out,retval]*/ aafBoolean_t *  pResult) PURE;


  //***********************************************************
  //
  // GetFileDescriptorClass()
  //
  // Places the file descriptor class object associated with this
  // codec into the *ppClass argument.  If none exists yet, NULL is
  // placed into the*ppClass argument.
  //
  // The returned class object, if it exists, is
  // AddRef()ed before it is returned.
  //
  // Succeeds if all of the following are true:
  // - the ppClass pointer is valid.
  // - A valid file descriptor class exists.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - ppClass is null.
  //
  STDMETHOD(GetFileDescriptorClass) (THIS_
    // Returned file descriptor class object
    /*[out]*/ IAAFClassDef ** ppClass) PURE;


  //***********************************************************
  //
  // SetFileDescriptorClass()
  //
  // Sets the file descriptor class associated with this codec to be
  // the given one. 
  //
  // Succeeds if all of the following are true:
  // - the pClass pointer is valid.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pClass is null.
  //
  STDMETHOD(SetFileDescriptorClass) (THIS_
    // File descriptor class object
    /*[in]*/ IAAFClassDef * pClass) PURE;


  //***********************************************************
  //
  // EnumCodecFlavours()
  //
  // Places an enumerator for codec flavour into the *ppEnum argument.
  // The returned enumerator is AddRef()ed before it is returned.
  // 
  // Flavours are used when a single codec can support multiple
  // formats.  An example would be a codec which would accept a
  // "resolution ID" for a particular manufacturer and set up all of
  // the parameters.  When a new resolution ID is released, then a
  // new codec plugin would give users the ability to use the new
  // resolutions without upgrading the application.
  //
  // Succeeds if all of the following are true:
  // - the ppEnum pointer is valid.
  // 
  // If this method fails nothing will be written to *ppEnum.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - if ppEnum is null.
  //
  STDMETHOD(EnumCodecFlavours) (THIS_
    // Codec flavour Enumeration
    /*[out,retval]*/ IEnumAAFCodecFlavours ** ppEnum) PURE;
  

  END_INTERFACE
};
#endif // __IAAFCodecDef_INTERFACE_DEFINED__



// IAAFCommentMarker

// ************************
//
// Interface IAAFCommentMarker
//
// ************************







#ifndef __IAAFCommentMarker_INTERFACE_DEFINED__
#define __IAAFCommentMarker_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFCommentMarker;

#undef  INTERFACE
#define INTERFACE   IAAFCommentMarker

DECLARE_INTERFACE_(IAAFCommentMarker, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFCommentMarker methods *** */


  //***********************************************************
  //
  // GetAnnotation()
  //
  // This method will get the annotation for this comment marker and place an
  // interface for it into the **ppResult argument. 
  //
  // Succeeds if all of the following are true:
  // - the pResult pointer is valid.
  // 
  // If this method fails nothing will be written to *pResult.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pResult arg is NULL.
  //
  STDMETHOD(GetAnnotation) (THIS_
    // Annotation property value
    /*[out,retval]*/ IAAFSourceReference ** ppResult) PURE;

  //***********************************************************
  //
  // SetAnnotation()
  //
  // This method will set the Annotation for this comment marker.
  // 
  // If this method fails no state will be changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  STDMETHOD(SetAnnotation) (THIS_
    // Annotation property value
    /*[in]*/ IAAFSourceReference * pAnnotation) PURE;


  END_INTERFACE
};
#endif // __IAAFCommentMarker_INTERFACE_DEFINED__



// IAAFComponent

// ************************
//
// Interface IAAFComponent
//
// ************************







#ifndef __IAAFComponent_INTERFACE_DEFINED__
#define __IAAFComponent_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFComponent;

#undef  INTERFACE
#define INTERFACE   IAAFComponent

DECLARE_INTERFACE_(IAAFComponent, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFComponent methods *** */

  //***********************************************************
  //
  // SetLength()
  //
  // Sets the length property value on this component object.
  // 
  // Succeeds if all of the following are true:
  // - the optional length property is present for this object.
  //
  // This method deals with an optional property, which will only be
  // present for time-varying media.
  // 
  // If this method fails the length property will not be
  // changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_BAD_PROP
  //   - the optional length property is not present for this object.
  //
  STDMETHOD(SetLength) (THIS_
    // The duration in edit units of this component
    /*[in]*/ aafLength_constref  length) PURE;


  //***********************************************************
  //
  // GetLength()
  //
  // Gets the duration in edit units of this component.
  //	
  // Succeeds if all of the following are true:
  // - the pLength pointer is valid.
  // - the optional length property is present for this object.
  //
  // This method deals with an optional property, which will only be
  // present for time-varying media.
  // 
  // If this method fails nothing will be written to *pLength.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pLength arg is NULL.
  //
  // AAFRESULT_BAD_PROP
  //   - the optional length property is not present for this object.
  //
  STDMETHOD(GetLength) (THIS_
    // Length of this component
    /*[retval][out]*/ aafLength_t *  pLength) PURE;
	

  //***********************************************************
  //
  // SetDataDef()
  //
  // sets the data definition property AUID on this component.
  // 
  // If this method fails the Data Definition property will not be
  // changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pDataDef arg is NULL.
  //
  STDMETHOD(SetDataDef) (THIS_
    // DataDef of this object
    /*[in]*/ IAAFDataDef * pDataDef) PURE;


  //***********************************************************
  //
  // GetDataDef()
  //
  // returns data definition object.
  //
  // Succeeds if all of the following are true:
  // - the ppDatadef pointer is valid.
  // 
  // If this method fails nothing will be written to *ppDatadef.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppDatadef arg is NULL.
  //
  STDMETHOD(GetDataDef) (THIS_
    // DataDef of this object
    /*[out, retval]*/ IAAFDataDef ** ppDatadef) PURE;

  //***********************************************************
  //
  // AppendKLVData()
  //
  // Appends a pre-existing KLV Data object to the specified
  // component.
  // 
  // Succeeds if all of the following are true:
  // - the pKLV pointer is valid.
  // 
  // If this method fails no state will be changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - the pData arg is NULL.
  //
  STDMETHOD(AppendKLVData) (THIS_
    // KLV object
    /*[in]*/ IAAFKLVData * pData) PURE;


  //***********************************************************
  //
  // CountKLVData()
  //
  // return total number of KLV data objects attached to this component.
  //
  // Succeeds if all of the following are true:
  // - the pNumData pointer is valid.
  // 
  // If this method fails nothing will be written to *pNumComments.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pNumData arg is NULL.
  //
  STDMETHOD(CountKLVData) (THIS_
    // Number  of KLV data objects
    /*[out]*/ aafUInt32 *  pNumData) PURE;


  //***********************************************************
  //
  // GetKLVData()
  //
  // return the enumeration for all KLV data objects on this component.  The returned
  // enumerator is AddRef()ed before it is returned.  The enumerator
  // is implemented as a EnumAAFKLVData.
  // 
  // Succeeds if all of the following are true:
  // - the ppEnum pointer is valid.
  // 
  // If this method fails nothing will be written to *ppEnum.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppEnum is null.
  //
  STDMETHOD(GetKLVData) (THIS_
    // KLV data objects
    /*[out]*/ IEnumAAFKLVData ** ppEnum) PURE;


  //***********************************************************
  //
  // RemoveKLVData()
  //
  // // Removes the given KLV data object from this component.
  // 
  // Succeeds if all of the following are true:
  // - the pData pointer is valid.
  // - the given KLV data object is present in the component.
  // 
  // If this method fails no state will be changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pData is null.
  //
  // AAFRESULT_OBJECT_NOT_FOUND
  //   - the given KLV data object is not in this component.
  //
  STDMETHOD(RemoveKLVData) (THIS_
    // KLV data object to remove
    /*[in]*/ IAAFKLVData * pData) PURE;


  END_INTERFACE
};
#endif // __IAAFComponent_INTERFACE_DEFINED__



// IAAFCompositionMob

// ************************
//
// Interface IAAFCompositionMob
//
// ************************



#ifndef __IAAFCompositionMob_INTERFACE_DEFINED__
#define __IAAFCompositionMob_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFCompositionMob;

#undef  INTERFACE
#define INTERFACE   IAAFCompositionMob

DECLARE_INTERFACE_(IAAFCompositionMob, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFCompositionMob methods *** */

  //***********************************************************
  //
  // Initialize()
  //
  // Initializes this object with the given name.
  // 
  // Succeeds if all of the following are true:
  // - this object has not yet been initialized.
  // - the pName pointer is valid.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_ALREADY_INITIALIZED
  //   - Initialize() has already been called on this object.
  //
  // AAFRESULT_NULL_PARAM
  //   - pName argument is NULL.
  //
  STDMETHOD(Initialize) (THIS_
    // Mob name [optional]
    /*[in, string]*/ aafCharacter_constptr  pName) PURE;


  //***********************************************************
  //
  // GetDefaultFade()
  //
  // Get the default fade for this composition.  If there is no
  // default fade, this function returns with no error, but the VALID
  // field of the structure is false.  This allows you to pass this
  // struct to SourceClip::GetFade() in all cases.
  //
  // Succeeds if all of the following are true:
  // - this object has already been initialized.
  // - the pResult pointer is valid.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pResult argument is NULL.
  //
  STDMETHOD(GetDefaultFade) (THIS_
    // a default fade struct
    /*[out]*/ aafDefaultFade_t *  pResult) PURE;
	

  //***********************************************************
  //
  // SetDefaultFade()
  //
  // Adds the default crossfade properties to the Mob.
  //
  // Succeeds if all of the following are true:
  // - this object has already been initialized.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_BAD_TYPE
  //   - invalid fadeType.
  //
  // AAFRESULT_BAD_LENGTH
  //   - invalid fadeLength.
  //
  STDMETHOD(SetDefaultFade) (THIS_
    // Default fade length
    /*[in]*/ aafLength_t  fadeLength,

    // default fade type
    /*[in]*/ aafFadeType_t  fadeType,

    // default fade edit unit
    /*[in]*/ aafRational_t  fadeEditUnit) PURE;

  END_INTERFACE
};
#endif // __IAAFCompositionMob_INTERFACE_DEFINED__



// IAAFConstantValue

// ************************
//
// Interface IAAFConstantValue
//
// ************************







#ifndef __IAAFConstantValue_INTERFACE_DEFINED__
#define __IAAFConstantValue_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFConstantValue;

#undef  INTERFACE
#define INTERFACE   IAAFConstantValue

DECLARE_INTERFACE_(IAAFConstantValue, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFConstantValue methods *** */


  //***********************************************************
  //
  // Initialize()
  //
  // Initializes a new constant value object to be identified with the
  // given the given type, and with the given human-legible name.
  //
  // This method must be called after allocation, and before
  // any other method can be called.
  //
  // Succeeds if:
  // - Initialize() has not yet been called on this object.
  // - pParameterDef and pValue are a valid pointers.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_ALREADY_INITIALIZED
  //   - This object has already had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pParameterDef or pValue arg is NULL.
  // 
  //
  STDMETHOD(Initialize) (THIS_
    // Parameter definition for this object (this determines the type of the constant value)
    /*[in]*/ IAAFParameterDef * pParameterDef,

    // Size of preallocated buffer
    /*[in]*/ aafUInt32  valueSize,

    // buffer containing value
    /*[in, size_is(valueSize)]*/ aafDataBuffer_t  pValue) PURE;


  //***********************************************************
  //
  // GetValue()
  //
  // Writes the value into the pValue buffer.  The buffer is allocated
  // by the caller, and the size of the buffer is given by
  // valueSize.
  // 
  // Caller may call GetValueBufLen() to determine the
  // required buffer size.
  // 
  // Succeeds if all of the following are true:
  // - the pValue pointer is valid.
  // - valueSize indicates the buffer is large enough to hold the
  //   name.
  // 
  // If this method fails nothing will be written to *pValue.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pValue arg is NULL.
  //
  // AAFRESULT_SMALLBUF
  //   - valueSize indicates the buffer is too small to hold the
  //     value.
  //
  STDMETHOD(GetValue) (THIS_
    // Size of preallocated buffer
    /*[in]*/ aafUInt32  valueSize,

    // Preallocated buffer to hold value
    /*[out, size_is(valueSize),length_is(*bytesRead)]*/ aafDataBuffer_t  pValue,

    // Number of actual bytes read
    /*[out]*/ aafUInt32*  bytesRead) PURE;


  //***********************************************************
  //
  // GetValueBufLen()
  //
  // Returns the length of buffer required for the GetValue()
  // method.  The value is placed into the location specified by
  // pLen.
  //
  // Succeeds if all of the following are true:
  // - the pLen pointer is valid.
  //
  // If this method fails nothing will be written to *pLen.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pLen arg is NULL.
  //
  STDMETHOD(GetValueBufLen) (THIS_
    // Pointer to an variable used to return the length
    /*[out]*/ aafUInt32 *  pLen) PURE;

  //***********************************************************
  //
  // GetTypeDefinition()
  //
  // Places the type definition of the dataval inside this parameter into the
  // *ppTypeDef argument.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - ppTypeDef is null.
  //
  STDMETHOD(GetTypeDefinition) (THIS_
    // Type Definition of the dataval inside of this object
    /*[out,retval]*/ IAAFTypeDef ** ppTypeDef) PURE;

  //***********************************************************
  //
  // SetValue()
  //
  // The data value is set from a buffer of size valueSize and type.
  //
  // Succeeds if all of the following are true:
  // - pTypeDef is valid and registered with the object's dictionary.
  // - the pValue pointer is valid.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - ppTypeDef is null.
  //
  STDMETHOD(SetValue) (THIS_
    // Size of preallocated buffer
    /*[in]*/ aafUInt32  valueSize,

    // buffer containing value
    /*[in, size_is(valueSize)]*/ aafDataBuffer_t  pValue) PURE;


  END_INTERFACE
};
#endif // __IAAFConstantValue_INTERFACE_DEFINED__



// IAAFContainerDef

// ************************
//
// Interface IAAFContainerDef
//
// ************************



#ifndef __IAAFContainerDef_INTERFACE_DEFINED__
#define __IAAFContainerDef_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFContainerDef;

#undef  INTERFACE
#define INTERFACE   IAAFContainerDef

DECLARE_INTERFACE_(IAAFContainerDef, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFContainerDef methods *** */

  //***********************************************************
  //
  // Initialize()
  //
  // Init all fields of a definition object.
  //
  STDMETHOD(Initialize) (THIS_
    // AUID for new DeObject
    /*[in, ref]*/ aafUID_constref  id,

    // Name for new DefObject
    /*[in, string]*/ aafCharacter_constptr  pName,

    // Description for new DefObject
    /*[in, string]*/ aafCharacter_constptr  pDescription) PURE;


  //***********************************************************
  //
  // EssenceIsIdentified()
  //
  // Tells whether the given plugin is capable of supporting
  // authentication.  The methods for authenticating a plugin are
  // still <tbd>.
  // 
  // Succeeds if all of the following are true:
  // - the pEssenceIsIdentified pointer is valid.
  // 
  // If this method fails nothing will be written to
  // *pEssenceIsIdentified.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pEssenceIsIdentified arg is NULL.
  //
  STDMETHOD(EssenceIsIdentified) (THIS_
    // The EssenceIsIdentified
    /*[out]*/ aafBoolean_t *  pEssenceIsIdentified) PURE;


  //***********************************************************
  //
  // SetEssenceIsIdentified()
  //
  // Tells whether the given plugin is capable of supporting
  // authentication.  The methods for authenticating a plugin are
  // still <tbd>.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  STDMETHOD(SetEssenceIsIdentified) (THIS_
    // The EssenceIsIdentified flag
    /*[in]*/ aafBoolean_t  EssenceIsIdentified) PURE;

  END_INTERFACE
};
#endif // __IAAFContainerDef_INTERFACE_DEFINED__



// IAAFContentStorage

// ************************
//
// Interface IAAFContentStorage
//
// ************************


#ifndef __IAAFContentStorage_INTERFACE_DEFINED__
#define __IAAFContentStorage_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFContentStorage;




#undef  INTERFACE
#define INTERFACE   IAAFContentStorage

DECLARE_INTERFACE_(IAAFContentStorage, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFContentStorage methods *** */


  //***********************************************************
  //
  // LookupMob()
  //
  // Looks up the Mob that matches the given mob id and puts it into
  // the ppMob argument.  The returned mob interface is AddRef()ed
  // before it is returned.
  // 
  // Succeeds if all of the following are true:
  // - the ppMob pointer is valid.
  // 
  // If this method fails nothing will be written to *ppMob.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppMob is null
  //
  // AAFRESULT_MOB_NOT_FOUND
  //   - the requested mob wasn't found.
  //
  STDMETHOD(LookupMob) (THIS_
    // The Mob ID
    /*[in, ref]*/ aafMobID_constref  mobID,

    // Matching Mob
    /*[out,retval]*/ IAAFMob ** ppMob) PURE;


  //***********************************************************
  //
  // CountMobs()
  //
  // Writes the number of matches for the given mob kind into the
  // *pNumMobs argument.
  // 
  // Succeeds if all of the following are true:
  // - the pNumMobs pointer is valid.
  // 
  // If this method fails nothing will be written to *pNumMobs.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pNumMobs is null.
  //
  STDMETHOD(CountMobs) (THIS_
    // The mob kind to count
    /*[in]*/ aafMobKind_t  mobKind,

    // Total number of mobs of kind mobKind
    /*[out, retval]*/ aafNumSlots_t *  pResult) PURE;


  //***********************************************************
  //
  // GetMobs()
  //
  // Places an enumerator for mobs that apply to the criteria into the
  // *ppEnum argument.  If pSearchCriteria is null, all mobs are
  // returned.   The searchTag field of pSearchCriteria, and exactly
  // ONE of the fields in the union (tags.mobID, tags.name, etc. )
  // must be set.  Only one search criterion may be specified.  The
  // returned enumerator is AddRef()ed before it is returned.
  // 
  // Succeeds if all of the following are true:
  // - the ppEnum pointer is valid.
  // 
  // If this method fails nothing will be written to *ppEnum.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppEnum is null.
  //
  STDMETHOD(GetMobs) (THIS_
    // Search Criteria for enumeration
    /*[in]*/ aafSearchCrit_t *  pSearchCriteria,

    // Mob Enumeration
    /*[out, retval]*/ IEnumAAFMobs ** ppEnum) PURE;


  //***********************************************************
  //
  // AddMob()
  //
  // Appends the given mob to the header.  If the given mob is already
  // contained this method will do nothing and will return success.
  // 
  // Succeeds if all of the following are true:
  // - the pMob pointer is valid.
  // - the given mob is not already part of this collection.
  // 
  // If this method fails no state will be changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pMob is null.
  //
  // AAFRESULT_DUPLICATE_MOBID
  //   - the given mob is already contained.
  //
  STDMETHOD(AddMob) (THIS_
    // Mob to add
    /*[in]*/ IAAFMob * pMob) PURE;


  //***********************************************************
  //
  // RemoveMob()
  //
  // // Removes the given mob from the header.
  //
  // Succeeds if all of the following are true:
  // - the pMob pointer is valid.
  // - the given mob is currently in the collection.
  // 
  // If this method fails no state will be changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pMob is null.
  //
  // AAFRESULT_MOB_NOT_FOUND
  //   - the given mob is not already contained.
  //
  STDMETHOD(RemoveMob) (THIS_
    // Mob to remove
    /*[in]*/ IAAFMob * pMob) PURE;


  //***********************************************************
  //
  // CountEssenceData()
  //
  // Writes the total number of essence data into the *pNumEssenceData
  // argument.
  // 
  // Succeeds if all of the following are true:
  // - the pNumEssenceData pointer is valid.
  // 
  // If this method fails nothing will be written to
  // *pNumEssenceData.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pNumEssenceData is null.
  //
  STDMETHOD(CountEssenceData) (THIS_
    // Total number of essence data
    /*[out, retval]*/ aafUInt32 *  pResult) PURE;


  //***********************************************************
  //
  // IsEssenceDataPresent()
  //
  // // 
  // Succeeds if all of the following are true:
  // - the pResult pointer is valid.
  // 
  // If this method fails no state will be changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pResult is null.
  //
  STDMETHOD(IsEssenceDataPresent) (THIS_
    // A Unique File Mob ID
    /*[in, ref]*/ aafMobID_constref  fileMobID,

    // The Essence File Format
    /*[in]*/ aafFileFormat_t  fmt,

    // True if the essence is found
    /*[out,retval]*/ aafBoolean_t *  pResult) PURE;


  //***********************************************************
  //
  // EnumEssenceData()
  //
  // Places an enumerator for essence that applies to the criteria
  // into the *ppEnum argument.  The returned enumerator is
  // AddRef()ed before it is returned.
  // 
  // Succeeds if all of the following are true:
  // - the pMediaCriteria pointer is valid.
  // - the ppEnum pointer is valid.
  // 
  // If this method fails nothing will be written to *ppEnum.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - either pMediaCriteria or ppEnum is null.
  //
  STDMETHOD(EnumEssenceData) (THIS_
    // Essence Enumeration
    /*[out,retval]*/ IEnumAAFEssenceData ** ppEnum) PURE;


  //***********************************************************
  //
  // AddEssenceData()
  //
  // Appends the given essence data object to the header.
  // 
  // NOTE! Stub only.   Implementation not yet added.
  //
  // Succeeds if all of the following are true:
  // - the pEssenceData pointer is valid.
  // 
  // If this method fails no state will be changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_DUPLICATE_MOBID
  //   - The given mob has already been added.  The validation is done by comparing
  //		mobIDs, which should be unique.
  //
  // AAFRESULT_NULL_PARAM
  //   - pEssenceData is null.
  //
  STDMETHOD(AddEssenceData) (THIS_
    // Essence data object to append
    /*[in]*/ IAAFEssenceData * pEssenceData) PURE;

  //***********************************************************
  //
  // RemoveEssenceData()
  //
  // // Removes the given EssenceData from the header.
  //
  // Succeeds if all of the following are true:
  // - the pEssenceData pointer is valid.
  // - the given EssenceData is currently in the collection.
  // 
  // If this method fails no state will be changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pEssenceData is null.
  //
  // AAFRESULT_ESSENCE_NOT_FOUND
  //   - the given EssenceData is not already contained.
  //
  STDMETHOD(RemoveEssenceData) (THIS_
    // EssenceData to remove
    /*[in]*/ IAAFEssenceData * pEssenceData) PURE;

  //***********************************************************
  //
  // LookupEssenceData()
  //
  // Looks up the EssenceData that matches the given mob id and puts it into
  // the ppEssenceData argument.  The returned EssenceData interface is AddRef()ed
  // before it is returned.
  // 
  // Succeeds if all of the following are true:
  // - the ppEssenceData pointer is valid.
  // 
  // If this method fails nothing will be written to *ppEssenceData.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppEssenceData is null
  //
  // AAFRESULT_MOB_NOT_FOUND
  //   - the requested EssenceData wasn't found.
  //
  STDMETHOD(LookupEssenceData) (THIS_
    // The Mob ID
    /*[in, ref]*/ aafMobID_constref  mobID,

    // Matching EssenceData
    /*[out,retval]*/ IAAFEssenceData ** ppEssenceData) PURE;


  END_INTERFACE
};
#endif // __IAAFContentStorage_INTERFACE_DEFINED__



// IAAFControlPoint

// ************************
//
// Interface IAAFControlPoint
//
// ************************








#ifndef __IAAFControlPoint_INTERFACE_DEFINED__
#define __IAAFControlPoint_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFControlPoint;

#undef  INTERFACE
#define INTERFACE   IAAFControlPoint

DECLARE_INTERFACE_(IAAFControlPoint, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFControlPoint methods *** */


  //***********************************************************
  //
  // Initialize()
  //
  // Initializes a new control point object to be 
  //
  // This method must be called after allocation, and before
  // any other method can be called.
  //
  // Succeeds if:
  // - Initialize() has not yet been called on this object.
  // - pVaryingValue is a valid pointer.
  // - time is a valid rational.
  // - pValue is a valid pointer
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_ALREADY_INITIALIZED
  //   - This object has already had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pName or pValue arg is NULL.
  // 
  //
  STDMETHOD(Initialize) (THIS_
    // A varying value (this determines the type of this control point through the parameter definition)
    /*[in]*/ IAAFVaryingValue * pVaryingValue,

    // Control Point time
    /*[in]*/ aafRational_constref  time,

    // Size of preallocated buffer
    /*[in]*/ aafUInt32  valueSize,

    // buffer containing value
    /*[in, size_is(valueSize)]*/ aafDataBuffer_t  pValue) PURE;

  //***********************************************************
  //
  // GetTime()
  //
  // Returns the position of the control point within an operation group, expressed as a rational
  // running from 0 to 1.
  // 
  // Succeeds if all of the following are true:
  // - the pTime pointer is valid.
  // 
  // If this method fails nothing will be written to *pTime.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_PROP_NOT_PRESENT
  //   - This property does not exist in the file.
  //
  // AAFRESULT_NULL_PARAM
  //   - pTime arg is NULL.
  //
  STDMETHOD(GetTime) (THIS_
    // Pointer to an aafRational_t
    /*[out,retval]*/ aafRational_t *  pTime) PURE;

  //***********************************************************
  //
  // GetEditHint()
  //
  // Returns the edit hint of the control point, which describes how to alter the
  // position if the AAFOperationGroup is made longer or shorter.
  //
  // Succeeds if all of the following are true:
  // - the pEditHint pointer is valid.
  // 
  // If this method fails nothing will be written to *pEditHint.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_PROP_NOT_PRESENT
  //   - This property does not exist in the file.
  //
  // AAFRESULT_NULL_PARAM
  //   - pEditHint arg is NULL.
  //
  STDMETHOD(GetEditHint) (THIS_
    // Pointer to an aafEditHint_t
    /*[out,retval]*/ aafEditHint_t *  pEditHint) PURE;

  //***********************************************************
  //
  // GetValueBufLen()
  //
  // Returns the length of buffer required for the GetValue() method.
  // The value is placed into the location specified by pLen.
  //
  // Succeeds if all of the following are true:
  // - the pLen pointer is valid.
  //
  // If this method fails nothing will be written to *pLen.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pLen arg is NULL.
  //
  STDMETHOD(GetValueBufLen) (THIS_
    // Pointer to an variable used to return the length
    /*[out]*/ aafUInt32 *  pLen) PURE;

  //***********************************************************
  //
  // GetValue()
  //
  // Writes the value into the pValue buffer.  The buffer is allocated by the caller,
  // and the size of the buffer is given by valueSize.
  // 
  // Caller may call GetValueBufLen() to determine the
  // required buffer size.
  // 
  // Succeeds if all of the following are true:
  // - the pValue pointer is valid.
  // - valueSize indicates the buffer is large enough to hold the name.
  // 
  // If this method fails nothing will be written to *pValue.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pValue arg is NULL.
  //
  // AAFRESULT_SMALLBUF
  //   - valueSize indicates the buffer is too small to hold the value.
  //
  STDMETHOD(GetValue) (THIS_
    // Size of preallocated buffer
    /*[in]*/ aafUInt32  valueSize,

    // Preallocated buffer to hold value
    /*[out, size_is(valueSize),length_is(*bytesRead)]*/ aafDataBuffer_t  pValue,

    // Number of actual bytes read
    /*[out]*/ aafUInt32*  bytesRead) PURE;

  //***********************************************************
  //
  // SetTime()
  //
  // Sets the position of the control point within an operation group, expressed as a rational
  // running from 0 to 1.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  STDMETHOD(SetTime) (THIS_
    // Control Point time
    /*[in]*/ aafRational_t  pTime) PURE;

  //***********************************************************
  //
  // SetEditHint()
  //
  // Sets the control point Edit hint value, which describes how to alter the
  // position if the AAFOperationGroup is made longer or shorter.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  STDMETHOD(SetEditHint) (THIS_
    // Control Point Edit hint
    /*[in]*/ aafEditHint_t  editHint) PURE;

  //***********************************************************
  //
  // GetTypeDefinition()
  //
  // Places the type definition of the dataval inside this parameter into the
  // *ppTypeDef argument.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - ppTypeDef is null.
  //
  STDMETHOD(GetTypeDefinition) (THIS_
    // Type Definition of the dataval inside of this object
    /*[out,retval]*/ IAAFTypeDef ** ppTypeDef) PURE;

  //***********************************************************
  //
  // SetValue()
  //
  // The data value is set from a buffer of size valueSize and type.
  //
  // Succeeds if all of the following are true:
  // - pTypeDef is valid and registered with the object's dictionary.
  // - the pValue pointer is valid.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - ppTypeDef is null.
  //
  STDMETHOD(SetValue) (THIS_
    // Size of preallocated buffer
    /*[in]*/ aafUInt32  valueSize,

    // buffer containing value
    /*[in, size_is(valueSize)]*/ aafDataBuffer_t  pValue) PURE;


  END_INTERFACE
};
#endif // __IAAFControlPoint_INTERFACE_DEFINED__




// IAAFDataDef

// ************************
//
// Interface IAAFDataDef
//
// ************************


#ifndef __IAAFDataDef_INTERFACE_DEFINED__
#define __IAAFDataDef_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFDataDef;

#undef  INTERFACE
#define INTERFACE   IAAFDataDef

DECLARE_INTERFACE_(IAAFDataDef, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFDataDef methods *** */

  //***********************************************************
  //
  // Initialize()
  //
  // Init all fields of a definition object.
  //
  STDMETHOD(Initialize) (THIS_
    // AUID for new DeObject
    /*[in, ref]*/ aafUID_constref  id,

    // Name for new DefObject
    /*[in, string]*/ aafCharacter_constptr  pName,

    // Description for new DefObject
    /*[in, string]*/ aafCharacter_constptr  pDescription) PURE;


  //***********************************************************
  //
  // IsPictureKind()
  //
  // Sets return value to TRUE if DataDef is a picture.
  //
  STDMETHOD(IsPictureKind) (THIS_
    // pointer to the return value
    /*[retval,out]*/ aafBoolean_t *  bIsPictureKind) PURE;


  //***********************************************************
  //
  // IsMatteKind()
  //
  // Sets return value to TRUE if DataDef is a matte.
  //
  STDMETHOD(IsMatteKind) (THIS_
    // pointer to the return value
    /*[retval,out]*/ aafBoolean_t *  bIsMatteKind) PURE;


  //***********************************************************
  //
  // IsPictureWithMatteKind()
  //
  // Sets return value to TRUE if DataDef is a picture with matte.
  //
  STDMETHOD(IsPictureWithMatteKind) (THIS_
    // pointer to the return value
    /*[retval,out]*/ aafBoolean_t *  bIsPictureWithMatteKind) PURE;


  //***********************************************************
  //
  // IsSoundKind()
  //
  // Sets return value to TRUE if DataDef is a sound.
  //
  STDMETHOD(IsSoundKind) (THIS_
    // pointer to the return value
    /*[retval,out]*/ aafBoolean_t *  bIsSoundKind) PURE;


  //***********************************************************
  //
  // DoesDataDefConvertTo()
  //
  // Sets return value to TRUE if the DataDef of the given object
		   // can be converted to the DataDef specified in the IN 
		   // parameter with the DataDefName string.
  //
  STDMETHOD(DoesDataDefConvertTo) (THIS_
    // data def to compare against
    /*[in]*/ IAAFDataDef * id,

    // pointer to result
    /*[retval, out]*/ aafBoolean_t *  bDoesConvertTo) PURE;
		   

  //***********************************************************
  //
  // IsDataDefOf()
  //
  // Sets the value to TRUE if the DataDef of the given object
  // matches the DataDef specified in the IN parameter with the
  // DataDefName string.
  //
  STDMETHOD(IsDataDefOf) (THIS_
    // data def to compare against
    /*[in]*/ IAAFDataDef * pDataDef,

    // pointer to result
    /*[retval, out]*/ aafBoolean_t *  bIsDataDefOf) PURE;


  //***********************************************************
  //
  // DoesDataDefConvertFrom()
  //
  // Sets return value to TRUE if the DataDef of the given object
  // can be converted from the DataDef specified in the IN 
  // parameter specified with the DataDefName string.
  //
  STDMETHOD(DoesDataDefConvertFrom) (THIS_
    // data def to compare against
    /*[in]*/ IAAFDataDef * pDataDef,

    // pointer to result
    /*[retval, out]*/ aafBoolean_t *  bDoesConvertFrom) PURE;

  END_INTERFACE
};
#endif // __IAAFDataDef_INTERFACE_DEFINED__



// IAAFDefObject

// ************************
//
// Interface IAAFDefObject
//
// ************************




#ifndef __IAAFDefObject_INTERFACE_DEFINED__
#define __IAAFDefObject_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFDefObject;

#undef  INTERFACE
#define INTERFACE   IAAFDefObject

DECLARE_INTERFACE_(IAAFDefObject, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFDefObject methods *** */

  //***********************************************************
  //
  // SetName()
  //
  // Sets the Name of this definition.
  //
  // Set the Name property to the value specified in
  // pName.  A copy is made of the data so the caller
  // retains ownership of the *pName buffer and is
  // responsible for de-allocating it.  There is no pre-set limit to
  // the length of the name, other than available system memory or
  // disk space.
  // 
  // Succeeds if all of the following are true:
  // - the pName pointer is valid.
  // 
  // If this method fails the Name property will not be
  // changed.
  // 
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pName arg is NULL.
  //
  STDMETHOD(SetName) (THIS_
    // buffer from which Name is to be read
    /*[in, string]*/ aafCharacter_constptr  pName) PURE;


  //***********************************************************
  //
  // GetName()
  //
  // Gets the Name of this definition.
  // 
  // Writes the Name property, with a trailing null
  // character, into the pName buffer.  The
  // buffer is allocated by the caller.  The size of the buffer is
  // given by bufSize.  If the Name property has not yet
  // been set, a zero-length string will be written (that is,
  // only the trailing null character). 
  // 
  // Caller may call GetNameBufLen() to determine the
  // required buffer size.
  // 
  // If this method fails nothing will be written to
  // *pName.
  // 
  // Succeeds if:
  // - The pName pointer is valid.
  // - bufSize indicates that the buffer is large enough to hold
  //   Name.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pName arg is NULL.
  //
  // AAFRESULT_SMALL_BUF
  //   - bufSize indicates that the allocated buffer is not large
  //     enough to hold Name.
  //
  STDMETHOD(GetName) (THIS_
    // buffer into which Name is to be written
    /*[out, string, size_is(bufSize)]*/ aafCharacter *  pName,

    // size of *pName buffer in bytes
    /*[in]*/ aafUInt32  bufSize) PURE;


  //***********************************************************
  //
  // GetNameBufLen()
  //
  // Returns size of buffer (in bytes) required for GetName().
  // 
  // Succeeds if:
  // - The pBufSize pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pBufSize arg is NULL.
  //
  STDMETHOD(GetNameBufLen) (THIS_
    // size of required buffer, in bytes
    /*[out]*/ aafUInt32 *  pBufSize) PURE;


  //***********************************************************
  //
  // SetDescription()
  //
  // Sets the Description of this definition.
  //
  // Set the Description property to the value specified in
  // pDescription.  A copy is made of the data so the caller
  // retains ownership of the *pDescription buffer and is
  // responsible for de-allocating it.  There is no pre-set limit to
  // the length of the name, other than available system memory or
  // disk space.
  // 
  // Succeeds if all of the following are true:
  // - the pDescription pointer is valid.
  // 
  // If this method fails the Description property will not be
  // changed.
  // 
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pDescription arg is NULL.
  //
  STDMETHOD(SetDescription) (THIS_
    // buffer from which Description is to be read
    /*[in, string]*/ aafCharacter_constptr  pDescription) PURE;


  //***********************************************************
  //
  // GetDescription()
  //
  // Gets the Description of this definition.
  // 
  // Writes the Description property, with a trailing null
  // character, into the pDescription buffer.  The
  // buffer is allocated by the caller.  The size of the buffer is
  // given by bufSize.  If the Description property has not yet
  // been set, a zero-length string will be written (that is,
  // only the trailing null character). 
  // 
  // Caller may call GetDescriptionBufLen() to determine the
  // required buffer size.
  // 
  // If this method fails nothing will be written to
  // *pDescription.
  // 
  // Succeeds if:
  // - The pDescription pointer is valid.
  // - bufSize indicates that the buffer is large enough to hold
  //   Description.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pDescription arg is NULL.
  //
  // AAFRESULT_SMALL_BUF
  //   - bufSize indicates that the allocated buffer is not large
  //     enough to hold Description.
  //
  STDMETHOD(GetDescription) (THIS_
    // buffer into which Description is to be written
    /*[out, string, size_is(bufSize)]*/ aafCharacter *  pDescription,

    // size of *pDescription buffer in bytes
    /*[in]*/ aafUInt32  bufSize) PURE;


  //***********************************************************
  //
  // GetDescriptionBufLen()
  //
  // Returns size of buffer (in bytes) required for GetDescription().
  // 
  // Succeeds if:
  // - The pBufSize pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pBufSize arg is NULL.
  //
  STDMETHOD(GetDescriptionBufLen) (THIS_
    // size of required buffer, in bytes
    /*[out]*/ aafUInt32 *  pBufSize) PURE;


  //***********************************************************
  //
  // Initialize()
  //
  // Init all fields of a definition object.
  //
  STDMETHOD(Initialize) (THIS_
    // AUID for new DeObject
    /*[in, ref]*/ aafUID_constref  id,

    // Name for new DefObject
    /*[in, string]*/ aafCharacter_constptr  pName) PURE;


  //***********************************************************
  //
  // GetAUID()
  //
  // Gets the AUID for this object.
  //
  STDMETHOD(GetAUID) (THIS_
    // Pointer to an AUID reference
    /*[retval,out]*/ aafUID_t *  pAuid) PURE;


  END_INTERFACE
};
#endif // __IAAFDefObject_INTERFACE_DEFINED__



// IAAFPluginDef

// ************************
//
// Interface IAAFPluginDef
//
// ************************






#ifndef __IAAFPluginDef_INTERFACE_DEFINED__
#define __IAAFPluginDef_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFPluginDef;

#undef  INTERFACE
#define INTERFACE   IAAFPluginDef

DECLARE_INTERFACE_(IAAFPluginDef, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFPluginDef methods *** */

  //***********************************************************
  //
  // Initialize()
  //
  // Init all fields of a definition object.
  //
  STDMETHOD(Initialize) (THIS_
    // AUID for new DeObject
    /*[in, ref]*/ aafUID_constref  id,

    // Name for new DefObject
    /*[in]*/ aafCharacter_constptr  pName,

    // Description for new DefObject
    /*[in]*/ aafCharacter_constptr  pDescription) PURE;

  //***********************************************************
  //
  // GetCategoryClass()
  //
  // Obtains the Category Class, which is identifies the stored
  // classID of the subclass of AAFPluggableDefinition which
  // references this plugin descriptor.  This ID is written into the
  // caller-allocated aafUID_t specified by the pCategoryClass
  // argument.
  // 
  // Succeeds if all of the following are true:
  // - the pCategoryClass pointer is valid.
  // 
  // If this method fails nothing will be written to *pCategoryClass.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pCategoryClass arg is NULL.
  //
  STDMETHOD(GetCategoryClass) (THIS_
    // The CategoryClass
    /*[out]*/ aafUID_t *  pCategoryClass) PURE;


  //***********************************************************
  //
  // SetCategoryClass()
  //
  // Sets the Category Class, which is identifies the stored classID
  // of the subclass of AAFPluggableDefinition which references this
  // plugin descriptor.
  // 
  // If this method fails the Category Class property will not be
  // changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  STDMETHOD(SetCategoryClass) (THIS_
    // The Category Class
    /*[in, ref]*/ aafUID_constref  categoryClass) PURE;


  //***********************************************************
  //
  // GetPluginVersion()
  //
  // Gets the Plugin Version property associated with this plugin
  // descriptor and places it into *pVersion. 
  //
  // Succeeds if all of the following are true:
  // - the pVersion pointer is valid.
  // 
  // If this method fails, nothing will be written to *pVersion.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pVersion arg is NULL.
  //
  STDMETHOD(GetPluginVersion) (THIS_
    // The Plugin Version
    /*[out]*/ aafVersionType_t *  pVersion) PURE;


  //***********************************************************
  //
  // SetPluginVersion()
  //
  // Sets the plugin version property of this plugin descriptor.
  //
  // Succeeds if all of the following are true:
  // - pVersion pointer is valid.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pVersion arg is NULL.
  //
  STDMETHOD(SetPluginVersion) (THIS_
    // The plugin Version
    /*[in]*/ aafVersionType_t *  pVersion) PURE;


  //***********************************************************
  //
  // SetPluginVersionString()
  //
  // Sets the Plugin Version String property.
  //
  // Set the PluginVersionString property to the value specified in
  // pPluginVersionString.  A copy is made of the data so the caller
  // retains ownership of the *pPluginVersionString buffer and is
  // responsible for de-allocating it.  There is no pre-set limit to
  // the length of the name, other than available system memory or
  // disk space.
  // 
  // Succeeds if all of the following are true:
  // - the pPluginVersionString pointer is valid.
  // 
  // If this method fails the PluginVersionString property will not be
  // changed.
  // 
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pPluginVersionString arg is NULL.
  //
  STDMETHOD(SetPluginVersionString) (THIS_
    // buffer from which PluginVersionString is to be read
    /*[in, string]*/ aafCharacter_constptr  pPluginVersionString) PURE;


  //***********************************************************
  //
  // GetPluginVersionString()
  //
  // Gets the Plugin Version String property.
  // 
  // Writes the PluginVersionString property, with a trailing null
  // character, into the pPluginVersionString buffer.  The
  // buffer is allocated by the caller.  The size of the buffer is
  // given by bufSize.  If the PluginVersionString property has not yet
  // been set, a zero-length string will be written (that is,
  // only the trailing null character). 
  // 
  // Caller may call GetPluginVersionStringBufLen() to determine the
  // required buffer size.
  // 
  // If this method fails nothing will be written to
  // *pPluginVersionString.
  // 
  // Succeeds if:
  // - The pPluginVersionString pointer is valid.
  // - bufSize indicates that the buffer is large enough to hold
  //   PluginVersionString.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pPluginVersionString arg is NULL.
  //
  // AAFRESULT_SMALL_BUF
  //   - bufSize indicates that the allocated buffer is not large
  //     enough to hold PluginVersionString.
  //
  STDMETHOD(GetPluginVersionString) (THIS_
    // buffer into which PluginVersionString is to be written
    /*[out, string, size_is(bufSize)]*/ aafCharacter *  pPluginVersionString,

    // size of *pPluginVersionString buffer in bytes
    /*[in]*/ aafUInt32  bufSize) PURE;


  //***********************************************************
  //
  // GetPluginVersionStringBufLen()
  //
  // Returns size of buffer (in bytes) required for GetPluginVersionString().
  // 
  // Succeeds if:
  // - The pBufSize pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pBufSize arg is NULL.
  //
  STDMETHOD(GetPluginVersionStringBufLen) (THIS_
    // size of required buffer, in bytes
    /*[out]*/ aafUInt32 *  pBufSize) PURE;


  //***********************************************************
  //
  // SetPluginManufacturerName()
  //
  // Sets the Plugin Manufacturer Name string property.
  //
  // Set the PluginManufacturerName property to the value specified in
  // pPluginManufacturerName.  A copy is made of the data so the caller
  // retains ownership of the *pPluginManufacturerName buffer and is
  // responsible for de-allocating it.  There is no pre-set limit to
  // the length of the name, other than available system memory or
  // disk space.
  // 
  // Succeeds if all of the following are true:
  // - the pPluginManufacturerName pointer is valid.
  // 
  // If this method fails the PluginManufacturerName property will not be
  // changed.
  // 
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pPluginManufacturerName arg is NULL.
  //
  STDMETHOD(SetPluginManufacturerName) (THIS_
    // buffer from which PluginManufacturerName is to be read
    /*[in, string]*/ aafCharacter_constptr  pPluginManufacturerName) PURE;


  //***********************************************************
  //
  // GetPluginManufacturerName()
  //
  // Gets the Plugin Manufacturer Name string property.
  // 
  // Writes the PluginManufacturerName property, with a trailing null
  // character, into the pPluginManufacturerName buffer.  The
  // buffer is allocated by the caller.  The size of the buffer is
  // given by bufSize.  If the PluginManufacturerName property has not yet
  // been set, a zero-length string will be written (that is,
  // only the trailing null character). 
  // 
  // Caller may call GetPluginManufacturerNameBufLen() to determine the
  // required buffer size.
  // 
  // If this method fails nothing will be written to
  // *pPluginManufacturerName.
  // 
  // Succeeds if:
  // - The pPluginManufacturerName pointer is valid.
  // - bufSize indicates that the buffer is large enough to hold
  //   PluginManufacturerName.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pPluginManufacturerName arg is NULL.
  //
  // AAFRESULT_SMALL_BUF
  //   - bufSize indicates that the allocated buffer is not large
  //     enough to hold PluginManufacturerName.
  //
  STDMETHOD(GetPluginManufacturerName) (THIS_
    // buffer into which PluginManufacturerName is to be written
    /*[out, string, size_is(bufSize)]*/ aafCharacter *  pPluginManufacturerName,

    // size of *pPluginManufacturerName buffer in bytes
    /*[in]*/ aafUInt32  bufSize) PURE;


  //***********************************************************
  //
  // GetPluginManufacturerNameBufLen()
  //
  // Returns size of buffer (in bytes) required for GetPluginManufacturerName().
  // 
  // Succeeds if:
  // - The pBufSize pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pBufSize arg is NULL.
  //
  STDMETHOD(GetPluginManufacturerNameBufLen) (THIS_
    // size of required buffer, in bytes
    /*[out]*/ aafUInt32 *  pBufSize) PURE;


  //***********************************************************
  //
  // GetManufacturerInfo()
  //
  // This method will get an AAFNetworkLocator pointing to
  // ManufacturerInfo for this plugin and place an interface for the
  // locator into the **ppResult argument.  If a ManufacturerInfo
  // locator exists, the result will be AddRef()ed. If not, the
  // result will be NULL.
  //
  // Succeeds if all of the following are true:
  // - the ppResult pointer is valid.
  // 
  // If this method fails nothing will be written to *ppResult.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppResult arg is NULL.
  //
  STDMETHOD(GetManufacturerInfo) (THIS_
    // ManufacturerInfo property value
    /*[out, retval]*/ IAAFNetworkLocator ** ppResult) PURE;


  //***********************************************************
  //
  // SetManufacturerInfo()
  //
  // This method will set a locator pointing to the location of
  // ManufacturerInfo for this plugin.  If a ManufacturerInfo
  // already exists for this mob slot, it will be discarded.
  // 
  // If this method fails no state will be changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  STDMETHOD(SetManufacturerInfo) (THIS_
    // ManufacturerInfo property value
    /*[in]*/ IAAFNetworkLocator * pManufacturerInfo) PURE;


  //***********************************************************
  //
  // GetManufacturerID()
  //
  // Obtains the manufacturer ID, which is identifies the manfacturer
  // of this plugin.  This ID is written into the caller-allocated
  // aafUID_t specified by the pManufacturerID argument.
  // 
  // Succeeds if all of the following are true:
  // - the pManufacturerID pointer is valid.
  // 
  // If this method fails nothing will be written to
  // *pManufacturerID.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pManufacturerID arg is NULL.
  //
  STDMETHOD(GetManufacturerID) (THIS_
    // The ManufacturerID
    /*[out]*/ aafUID_t *  pManufacturerID) PURE;


  //***********************************************************
  //
  // SetManufacturerID()
  //
  // Sets the manufacturer ID, which is identifies the manufacturer
  // of this plugin.
  // 
  // If this method fails the ManufacturerID property will not be
  // changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  STDMETHOD(SetManufacturerID) (THIS_
    // The Category Class
    /*[in, ref]*/ aafUID_constref  manufacturerID) PURE;


  //***********************************************************
  //
  // GetHardwarePlatform()
  //
  // Obtains the hardware platform ID, which identifies the hardware
  // platform which is required to use this plugin.  This ID is
  // written into the caller-allocated variable specified by the
  // pHardwarePlatform argument. The type aafHardwarePlatform_t is an
  // extensible enumerated type, and the value given must be either
  // standard or in the type dictionary.
  // 
  // Succeeds if all of the following are true:
  // - the pHardwarePlatform pointer is valid.
  // 
  // If this method fails nothing will be written to
  // *pHardwarePlatform.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pHardwarePlatform arg is NULL.
  //
  STDMETHOD(GetHardwarePlatform) (THIS_
    // The HardwarePlatform
    /*[out]*/ aafHardwarePlatform_t *  pHardwarePlatform) PURE;


  //***********************************************************
  //
  // SetHardwarePlatform()
  //
  // Sets the hardware platform ID, which identifies the hardware
  // platform which is required to use this plugin.  The type
  // aafHardwarePlatform_t is an extensible enumerated type, and the
  // value given must be either standard or in the type dictionary.
  // 
  // If this method fails the HardwarePlatform property will not be
  // changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  STDMETHOD(SetHardwarePlatform) (THIS_
    // The Category Class
    /*[in]*/ aafHardwarePlatform_constref  hardwarePlatform) PURE;


  //***********************************************************
  //
  // GetPlatformVersionRange()
  //
  // Gets the minimum and maximum platform Version properties
  // associated with this plugin descriptor and places it into
  // *pMinVersion, and *pMaxVersion.  These are the minimum and
  // maximum versions of the platform for which this plugin will
  // function.
  //
  // Succeeds if all of the following are true:
  // - both pMinVersion and pMaxVersion pointers are valid.
  // 
  // If this method fails, nothing will be written to *pMinVersion or
  // *pMaxVersion.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pMinVersion or pMaxVersion arg is NULL.
  //
  STDMETHOD(GetPlatformVersionRange) (THIS_
    // The Minimum Platform Version
    /*[out]*/ aafVersionType_t *  pMinVersion,

    // The Maximum Platform Version
    /*[out]*/ aafVersionType_t *  pMaxVersion) PURE;


  //***********************************************************
  //
  // SetPlatformMinimumVersion()
  //
  // Sets the maximum platform Version property of this plugin
  // descriptor.  This is the minimum version of the platform for
  // which this plugin will function.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  STDMETHOD(SetPlatformMinimumVersion) (THIS_
    // The Minimum Platform Version
    /*[in]*/ aafVersionType_constref  minVersion) PURE;


  //***********************************************************
  //
  // SetPlatformMaximumVersion()
  //
  // Sets the maximum platform Version properties associated with this
  // plugin descriptor.  This is the maximum version of the platform
  // for which this plugin will function.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  STDMETHOD(SetPlatformMaximumVersion) (THIS_
    // The Maximum Platform Version
    /*[in]*/ aafVersionType_constref  maxVersion) PURE;


  //***********************************************************
  //
  // GetEngine()
  //
  // Obtains the software engine ID, which identifies the software
  // subsystem used for essence management and playback used by the
  // plugin.  This ID is written into the caller-allocated variable
  // specified by the pHardwarePlatform argument.  The type
  // aafEngine_t is an extensible, enumerated type, and the value
  // given must be either standard or in the type dictionary.
  // 
  // Succeeds if all of the following are true:
  // - the pHardwarePlatform pointer is valid.
  // 
  // If this method fails nothing will be written to
  // *pHardwarePlatform.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pEngine arg is NULL.
  //
  STDMETHOD(GetEngine) (THIS_
    // The software engine
    /*[out]*/ aafEngine_t *  pEngine) PURE;


  //***********************************************************
  //
  // SetEngine()
  //
  // Sets the software engine ID, which identifies the software
  // subsystem used for essence management and playback used by the
  // plugin.  The type aafEngine_t is an extensible enumerated type,
  // and the value given must be either standard or in the type
  // dictionary.
  // 
  // If this method fails the engine property will not be
  // changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  STDMETHOD(SetEngine) (THIS_
    // The software engine
    /*[in]*/ aafEngine_constref  engine) PURE;


  //***********************************************************
  //
  // GetEngineVersionRange()
  //
  // Gets the minimum and maximum engine Version properties of the
  // engine which is associated with this plugin and places it into
  // *pMinVersion, and *pMaxVersion.  These are the minimum and
  // maximum versions of the engine for which this plugin will
  // function.
  //
  // Succeeds if all of the following are true:
  // - both pMinVersion and pMaxVersion pointers are valid.
  // 
  // If this method fails, nothing will be written to *pMinVersion or
  // *pMaxVersion.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pMinVersion or pMaxVersion arg is NULL.
  //
  STDMETHOD(GetEngineVersionRange) (THIS_
    // The Minimum Engine Version
    /*[out]*/ aafVersionType_t *  pMinVersion,

    // The Maximum Engine Version
    /*[out]*/ aafVersionType_t *  pMaxVersion) PURE;


  //***********************************************************
  //
  // SetEngineMinimumVersion()
  //
  // Sets the minimum engine Version property to the minimum useful
  // version of the engine which is associated with this plugin.  This
  // is the minimum version of the engine for which this plugin will
  // function.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  STDMETHOD(SetEngineMinimumVersion) (THIS_
    // The Minimum Engine Version
    /*[in]*/ aafVersionType_constref  minVersion) PURE;


  //***********************************************************
  //
  // SetEngineMaximumVersion()
  //
  // Sets the minimum engine Version property to the maximum useful
  // version of the engine which is associated with this plugin.  This
  // is the maximum version of the engine for which this plugin will
  // function.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  STDMETHOD(SetEngineMaximumVersion) (THIS_
    // The Minimum Engine Version
    /*[in]*/ aafVersionType_constref  pMaxVersion) PURE;


  //***********************************************************
  //
  // GetPluginAPI()
  //
  // Obtains the manufacturer ID Class, which identifies the plugin
  // interface supported by the plugin.  This ID is written into the
  // caller-allocated variable specified by the pPluginAPI argument.
  // The type aafPluginAPI_t is an extensible enumerated type, and
  // the value given must be either standard or in the type
  // dictionary.
  // 
  // Succeeds if all of the following are true:
  // - the pPluginAPI pointer is valid.
  // 
  // If this method fails nothing will be written to *pPluginAPI.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pPluginAPI arg is NULL.
  //
  STDMETHOD(GetPluginAPI) (THIS_
    // The PluginAPI
    /*[out]*/ aafPluginAPI_t *  pPluginAPI) PURE;


  //***********************************************************
  //
  // SetPluginAPI()
  //
  // Obtains the manufacturer ID, which identifies the plugin
  // interface supported by the plugin.
  // 
  // The type aafPluginAPI_t is an extensible enumerated type, and
  // the value given must be either standard or in the type dictionary.
  // 
  // If this method fails the PluginAPI property will not be
  // changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  STDMETHOD(SetPluginAPI) (THIS_
    // The Category Class
    /*[in]*/ aafPluginAPI_constref  pluginAPI) PURE;


  //***********************************************************
  //
  // GetPluginAPIVersionRange()
  //
  // Gets the minimum and maximum plugin API Version properties of the
  // plugin API which is associated with this plugin descriptor and
  // places it into *pMinVersion, and *pMaxVersion.  These are the
  // minimum and maximum versions of the PluginAPI for which this
  // plugin will function.
  //
  // Succeeds if all of the following are true:
  // - both pMinVersion and pMaxVersion pointers are valid.
  // 
  // If this method fails, nothing will be written to *pMinVersion or
  // *pMaxVersion.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pMinVersion or pMaxVersion arg is NULL.
  //
  STDMETHOD(GetPluginAPIVersionRange) (THIS_
    // The Minimum Plugin API Version
    /*[out]*/ aafVersionType_t *  pMinVersion,

    // The Maximum Plugin API Version
    /*[out]*/ aafVersionType_t *  pMaxVersion) PURE;


  //***********************************************************
  //
  // SetPluginAPIMinimumVersion()
  //
  // Sets the minimum plugin API Version property to the minimum
  // useful version of the plugin API which is associated with this
  // plugin.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  STDMETHOD(SetPluginAPIMinimumVersion) (THIS_
    // The Minimum Plugin API Version
    /*[out]*/ aafVersionType_constref  minVersion) PURE;


  //***********************************************************
  //
  // SetPluginAPIMaximumVersion()
  //
  // Sets the maximum engine Version property to the maximum useful
  // version of the plugin API which is associated with this plugin.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  STDMETHOD(SetPluginAPIMaximumVersion) (THIS_
    // The Maximum Plugin API Version
    /*[in]*/ aafVersionType_constref  maxVersion) PURE;


  //***********************************************************
  //
  // IsSoftwareOnly()
  //
  // Tells whether the given plugin is capable of running in a
  // software-only environment.  A value of AAFTrue indicates that no
  // additional hardware is required.  If the result is AAFTrue, then
  // this plugin may also support hardware acceleration, as long as
  // it also contains a software method of processing the data.
  // 
  // Succeeds if all of the following are true:
  // - the pIsSoftwareOnly pointer is valid.
  // 
  // If this method fails nothing will be written to *pIsSoftwareOnly.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pIsSoftwareOnly arg is NULL.
  //
  STDMETHOD(IsSoftwareOnly) (THIS_
    // The IsSoftwareOnly
    /*[out]*/ aafBoolean_t *  pIsSoftwareOnly) PURE;


  //***********************************************************
  //
  // SetIsSoftwareOnly()
  //
  // Sets whether the given plugin is capable of running in a
  // software-only environment, and returns AAFFalse if any hardware
  // is required.  If isSoftwareOnly is AAFTrue, then this plugin may
  // also support hardware acceleration, as long as it also contains
  // a software method of processing the data.  If this method fails
  // the isSoftwareOnly property will not be changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  STDMETHOD(SetIsSoftwareOnly) (THIS_
    // The isSoftwareOnly flag
    /*[in]*/ aafBoolean_t  isSoftwareOnly) PURE;


  //***********************************************************
  //
  // IsAccelerated()
  //
  // Tells whether the given plugin is capable of running with a
  // hardware accelerator.  If the result is AAFTrue, then this
  // plugin may also support software decompression.
  // 
  // Succeeds if all of the following are true:
  // - the pIsAccelerated pointer is valid.
  // 
  // If this method fails nothing will be written to *pIsAccelerated.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pIsAccelerated arg is NULL.
  //
  STDMETHOD(IsAccelerated) (THIS_
    // The IsAccelerated
    /*[out]*/ aafBoolean_t *  pIsAccelerated) PURE;


  //***********************************************************
  //
  // SetIsAccelerated()
  //
  // Tells whether the given plugin is capable of running with a
  // hardware accelerator.  If the result is AAFTrue, then this
  // plugin may also support software decompression.
  //
  // If this method fails the IsAccelerated property will not be
  // changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  STDMETHOD(SetIsAccelerated) (THIS_
    // The isAccelerated flag
    /*[in]*/ aafBoolean_t  isAccelerated) PURE;


  //***********************************************************
  //
  // SupportsAuthentication()
  //
  // Tells whether the given plugin is capable of supporting
  // authentication.  The methods for authenticating a plugin are
  // still <tbd>.
  // 
  // Succeeds if all of the following are true:
  // - the pSupportsAuthentication pointer is valid.
  // 
  // If this method fails nothing will be written to
  // *pSupportsAuthentication.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pSupportsAuthentication arg is NULL.
  //
  STDMETHOD(SupportsAuthentication) (THIS_
    // The SupportsAuthentication
    /*[out]*/ aafBoolean_t *  pSupportsAuthentication) PURE;


  //***********************************************************
  //
  // SetSupportsAuthentication()
  //
  // Tells whether the given plugin is capable of supporting
  // authentication.  The methods for authenticating a plugin are
  // still <tbd>.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  STDMETHOD(SetSupportsAuthentication) (THIS_
    // The SupportsAuthentication flag
    /*[in]*/ aafBoolean_t  SupportsAuthentication) PURE;



  //***********************************************************
  //
  // CountLocators()
  //
  // Return the number of locators attached to this plugin descriptor.
  // The number of locators may be zero if the plugin is in the
  // current file.
  // 
  // Succeeds if all of the following are true:
  // - the pCount pointer is valid.
  // 
  // If this method fails nothing is written to *pCount.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pCount is null.
  //
  STDMETHOD(CountLocators) (THIS_
    // Returns the number of locators
    /*[out]*/ aafUInt32 *  pResult) PURE;


  //***********************************************************
  //
  // AppendLocator()
  //
  // Append another locator to this plugin descriptor.  Use this
  // function to add a locator to be scanned last when searching for
  // the plugin (a secondary location for the plugin).
  // 
  // Succeeds if all of the following are true:
  // - the pLocator pointer is valid.
  // 
  // If this method fails no state will be changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pLocator is null.
  //
  STDMETHOD(AppendLocator) (THIS_
    // Locator to append
    /*[in]*/ IAAFLocator * pLocator) PURE;


  //***********************************************************
  //
  // PrependLocator()
  //
  // Append another locator to this plugin descriptor.  Use this
  // function to add a locator to be scanned first when searching for
  // the plugin (a new primary location for the plugin).
  // 
  // Succeeds if all of the following are true:
  // - the pLocator pointer is valid.
  // 
  // If this method fails no state will be changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pLocator is null.
  //
  STDMETHOD(PrependLocator) (THIS_
    // Locator to append
    /*[in]*/ IAAFLocator * pLocator) PURE;


  //***********************************************************
  //
  // InsertLocatorAt()
  //
  // Insert another locator to this plugin descriptor at the given
  // index.  Locators already existing at the named and higher indices
  // will be moved up to the next higher index to accommodate.
  // 
  // Succeeds if all of the following are true:
  // - index is less than or equal to the value returned by
  //   CountLocators().
  // - the pLocator pointer is valid.
  // 
  // If this method fails no state will be changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pLocator is null.
  //
  // AAFRESULT_BADINDEX
  //   - index is greater than the value returned by
  //     CountLocators().
  //
  STDMETHOD(InsertLocatorAt) (THIS_
    // index to insert locator
    /*[in]*/ aafUInt32  index,

    // Locator to insert
    /*[in]*/ IAAFLocator * pLocator) PURE;


  //***********************************************************
  //
  // GetLocatorAt()
  //
  // Gets the locator which exists in this plugin descriptor at the
  // given index.
  // 
  // Succeeds if all of the following are true:
  // - index is less than the value returned by CountLocators().
  // - the ppLocator pointer is valid.
  // 
  // If this method fails no state will be changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppLocator is null.
  //
  // AAFRESULT_BADINDEX
  //   - index is greater than or equal to the value returned by
  //     CountLocators().
  //
  STDMETHOD(GetLocatorAt) (THIS_
    // index to insert locator
    /*[in]*/ aafUInt32  index,

    // returned Locator
    /*[out]*/ IAAFLocator ** ppLocator) PURE;


  //***********************************************************
  //
  // RemoveLocatorAt()
  //
  // Removes the locator which exists in this plugin descriptor at the
  // given index.  Locators already existing at indices higher than
  // the named index will be moved down to the next higher index to
  // accommodate.
  // 
  // Succeeds if all of the following are true:
  // - index is less than the value returned by CountLocators().
  // - the ppLocator pointer is valid.
  // 
  // If this method fails no state will be changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppLocator is null.
  //
  // AAFRESULT_BADINDEX
  //   - index is greater than or equal to the value returned by
  //     CountLocators().
  //
  STDMETHOD(RemoveLocatorAt) (THIS_
    // index to insert locator
    /*[in]*/ aafUInt32  index) PURE;



  //***********************************************************
  //
  // GetLocators()
  //
  // Places an IEnumAAFPluginLocators enumerator for the plugin
  // locators contained in the AAFPluginDescriptor into the *ppEnum
  // argument.
  // 
  // The returned enumerator is AddRef()ed before it is returned.
  //
  // Succeeds if all of the following are true:
  // - this object has already been initialized.
  // - the ppEnum pointer is valid.
  // 
  // If this method fails nothing will be written to *ppEnum.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - Initialize() has already been called on this object.
  //
  // AAFRESULT_NULL_PARAM
  //   - ppEnum is null.
  //
  // E_FAIL
  //   - Failed to create the enumerator.
  //
  STDMETHOD(GetLocators) (THIS_
    // Plugin Locator Enumeration
    /*[out, retval]*/ IEnumAAFPluginLocators ** ppEnum) PURE;

    //***********************************************************
  //
  // SetDefinitionObjectID()
  //
  // Sets the definition object handled by this plugin.
  //
  STDMETHOD(SetDefinitionObjectID) (THIS_
    // AUID of an AAFDefinitionObject
    /*[in]*/ aafUID_t  pDef) PURE;

    //***********************************************************
  //
  // GetDefinitionObjectID()
  //
  // Gets the definition object handled by this plugin.
  //
  STDMETHOD(GetDefinitionObjectID) (THIS_
    // AUID of an AAFDefinitionObject
    /*[retval,out]*/ aafUID_t*  ppDef) PURE;


  END_INTERFACE
};
#endif // __IAAFPluginDef_INTERFACE_DEFINED__




// IAAFDictionary

// ************************
//
// Interface IAAFDictionary
//
// ************************




















#ifndef __IAAFDictionary_INTERFACE_DEFINED__
#define __IAAFDictionary_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFDictionary;

#undef  INTERFACE
#define INTERFACE   IAAFDictionary

DECLARE_INTERFACE_(IAAFDictionary, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFDictionary methods *** */

  //***********************************************************
  //
  // CreateInstance()
  //
  // Creates a single uninitialized AAF object of the class associated 
  // with a specified stored object id. 
  // 
  STDMETHOD(CreateInstance)(THIS_
    // Class identifier (AUID) of the stored object. This is the
    // corresponding SMPTE identifier (as a GUID) for all predefined
    // built-in classes.
    aafUID_constref id,

    // Reference to the identifier of the interface
    REFIID riid,

    // Address of output variable that receives the 
    // interface pointer requested in riid
    IUnknown ** ppvObject) PURE;


  //***********************************************************
  //
  // CreateMetaInstance()
  //
  // Creates a single uninitialized AAF meta class or type associated 
  // with a specified stored object id. 
  // 
  STDMETHOD(CreateMetaInstance)(THIS_
    // Identifier (id) of a class or type definition. This is the
    // corresponding SMPTE identifier (as a GUID) for all predefined
    // built-in definitions.
    aafUID_constref id,

    // Reference to the identifier of the interface
    REFIID riid,

    // Address of output variable that receives the 
    // interface pointer requested in riid
    IUnknown ** ppMetaDefinition) PURE;



  //***********************************************************
  //
  // RegisterClassDef()
  //
  // Add the class definition object to the dictionary.
  // 
  // Succeeds if:
  // - The pClassDef pointer is valid.
  // - the ID contained in the class def is not already been
  //   registered.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pClassDef arg is NULL.
  //
  // AAFRESULT_INVALID_PARAM
  //   - The class def ID has already been registered.
  //
  STDMETHOD(RegisterClassDef) (THIS_
    // Class Definition
    /*[in]*/ IAAFClassDef * pClassDef) PURE;


  //***********************************************************
  //
  // LookupClassDef()
  //
  // Return the class definition with the given id.
  // 
  // Succeeds if:
  // - The pClassID pointer is valid.
  // - The ppClassDef pointer is valid.
  // - the ID is a recognized id for a class definition.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - Either pClassID or ppClassDef arg is NULL.
  //
  // AAFRESULT_INVALID_PARAM
  //   - The given ID is not recognized as a class definition ID.
  //
  STDMETHOD(LookupClassDef) (THIS_
    // Class Unique ID
    /*[in, ref]*/ aafUID_constref  classId,

    // Class Definition
    /*[out,retval]*/ IAAFClassDef ** ppClassDef) PURE;


  //***********************************************************
  //
  // GetClassDefs()
  //
  // Return an enumerator for all class definitions.
  //
  // Succeeds if:
  // - The ppEnum pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppEnum arg is NULL.
  //
  STDMETHOD(GetClassDefs) (THIS_
    // Class Definition Enumeration
    /*[out,retval]*/ IEnumAAFClassDefs ** ppEnum) PURE;


  //***********************************************************
  //
  // CountClassDefs()
  //
  // Writes the number of class definition objects into the
  // *pResult argument.
  // 
  // Succeeds if all of the following are true:
  // - the pResult pointer is valid.
  // 
  // If this method fails nothing will be written to *pResult.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pResult is null.
  //
  STDMETHOD(CountClassDefs) (THIS_
    // Total number of class definition objects
    /*[out, retval]*/ aafUInt32 *  pResult) PURE;

  //***********************************************************
  //
  // CreateForwardClassReference()
  //
  // Return the class definition with the given id.
  // 
  // Succeeds if:
  // - The classId does not represent an existing forward class reference
  //   or a class definition that has already been successfully registered.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_INVALID_PARAM
  //   - The given ID is not recognized as a class definition ID.
  //
  STDMETHOD(CreateForwardClassReference) (THIS_
    // Class Unique ID
    /*[in, ref]*/ aafUID_constref  classId) PURE;

  //***********************************************************
  //
  // HasForwardClassReference()
  //
  // Return kAAFTrue if the given class identification is a forward reference.
  // 
  // Succeeds if:
  // - The pClassID pointer is valid.
  // - The ppClassDef pointer is valid.
  // - the ID is a recognized id for a class definition.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - Either pClassID or ppClassDef arg is NULL.
  //
  // AAFRESULT_INVALID_PARAM
  //   - The given ID is not recognized as a class definition ID.
  //
  STDMETHOD(HasForwardClassReference) (THIS_
    // Class Unique ID
    /*[in, ref]*/ aafUID_constref  classId,

    // true if forward class reference; false if not a forward class reference
    /*[out,retval]*/ aafBoolean_t *  pResult) PURE;

  //***********************************************************
  //
  // RegisterTypeDef()
  //
  // Add the type definition object to the dictionary.
  // 
  // Succeeds if:
  // - The pTypeDef pointer is valid.
  // - the ID is not already been registered.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pClassDef arg is NULL.
  //
  // AAFRESULT_INVALID_PARAM
  //   - The given type has already been registered.
  //
  STDMETHOD(RegisterTypeDef) (THIS_
    // Type Definition Object
    /*[in]*/ IAAFTypeDef * pTypeDef) PURE;


  //***********************************************************
  //
  // LookupTypeDef()
  //
  // Return the type definition object with the given id.
  // 
  // Succeeds if:
  // - The pTypeID pointer is valid.
  // - The ppTypeDef pointer is valid.
  // - the ID is a recognized id for a type definition.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - Either pTypeID or ppTypeDef arg is NULL.
  //
  // AAFRESULT_INVALID_PARAM
  //   - The given ID is not recognized as a type definition ID.
  //
  STDMETHOD(LookupTypeDef) (THIS_
    // Type Unique ID
    /*[in, ref]*/ aafUID_constref  typeId,

    // Type Definition Object
    /*[out,retval]*/ IAAFTypeDef ** ppTypeDef) PURE;


  //***********************************************************
  //
  // GetTypeDefs()
  //
  // Return an enumerator for all type definitions.
  //
  // Succeeds if:
  // - The ppEnum pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppEnum arg is NULL.
  //
  STDMETHOD(GetTypeDefs) (THIS_
    // Type Def Enumeration
    /*[out,retval]*/ IEnumAAFTypeDefs ** ppEnum) PURE;


  //***********************************************************
  //
  // CountTypeDefs()
  //
  // Writes the number of type definition objects into the
  // *pResult argument.
  // 
  // Succeeds if all of the following are true:
  // - the pResult pointer is valid.
  // 
  // If this method fails nothing will be written to *pResult.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pResult is null.
  //
  STDMETHOD(CountTypeDefs) (THIS_
    // Total number of type definition objects
    /*[out, retval]*/ aafUInt32 *  pResult) PURE;


  //***********************************************************
  //
  // RegisterOpaqueTypeDef()
  //
  // Add the opaquetype definition object to the dictionary.
  // 
  // Succeeds if:
  // - The pTypeDef pointer is valid.
  // - the definition is not already been registered with RegisterTypeDef.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pTypeDef arg is NULL.
  //
  // AAFRESULT_INVALID_PARAM
  //   - The given type has already been registered.
  //
  STDMETHOD(RegisterOpaqueTypeDef) (THIS_
    // Type Definition Object
    /*[in]*/ IAAFTypeDef * pTypeDef) PURE;


  //***********************************************************
  //
  // LookupOpaqueTypeDef()
  //
  // Return the opaque type definition object with the given id.
  // 
  // Succeeds if:
  // - The pTypeID pointer is valid.
  // - The ppTypeDef pointer is valid.
  // - the ID is a recognized id for an opaque type definition.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - Either typeId or ppTypeDef arg is NULL.
  //
  // AAFRESULT_INVALID_PARAM
  //   - The given ID is not recognized as a type definition ID.
  //
  STDMETHOD(LookupOpaqueTypeDef) (THIS_
    // Type Unique ID
    /*[in, ref]*/ aafUID_constref  typeId,

    // Type Definition Object
    /*[out,retval]*/ IAAFTypeDef ** ppTypeDef) PURE;


  //***********************************************************
  //
  // GetOpaqueTypeDefs()
  //
  // Return an enumerator for all registered opaque type definitions.
  //
  // Succeeds if:
  // - The ppEnum pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppEnum arg is NULL.
  //
  STDMETHOD(GetOpaqueTypeDefs) (THIS_
    // Type Def Enumeration
    /*[out,retval]*/ IEnumAAFTypeDefs ** ppEnum) PURE;


  //***********************************************************
  //
  // CountOpaqueTypeDefs()
  //
  // Writes the number of opaque type definition objects into the
  // *pResult argument.
  // 
  // Succeeds if all of the following are true:
  // - the pResult pointer is valid.
  // 
  // If this method fails nothing will be written to *pResult.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pResult is null.
  //
  STDMETHOD(CountOpaqueTypeDefs) (THIS_
    // Total number of opaque type definition objects
    /*[out, retval]*/ aafUInt32 *  pResult) PURE;

  //***********************************************************
  //
  // RegisterKLVDataKey()
  //
  // Add the definition for the given KLV key to the runtime dictionary.
  // The pTypeDef will often be kAAFTypeID_UInt8Array,
  // but may be something else.  // 
  // Succeeds if:
  // - The pTypeDef pointer is valid.
  // - the definition is not already been registered with RegisterTypeDef.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pTypeDef arg is NULL.
  //
  // AAFRESULT_INVALID_PARAM
  //   - The given type has already been registered.
  //
  STDMETHOD(RegisterKLVDataKey) (THIS_
    // Key to define
    /*[in]*/ aafUID_t  pUID,

    // Type Definition Object
    /*[in]*/ IAAFTypeDef * pTypeDef) PURE;

  //***********************************************************
  //
  // RegisterDataDef()
  //
  // Add the data definition object to the header's list of definitions.
  //
  STDMETHOD(RegisterDataDef) (THIS_
    // Data Definition Object
    /*[in]*/ IAAFDataDef * pDataDef) PURE;


  //***********************************************************
  //
  // LookupDataDef()
  //
  // Return the data definition object with the given id.
  //
  STDMETHOD(LookupDataDef) (THIS_
    // Data Definition Unique ID
    /*[in, ref]*/ aafUID_constref  dataDefinitionId,

    // Data Definition Object
    /*[out,retval]*/ IAAFDataDef ** ppDataDef) PURE;


  //***********************************************************
  //
  // GetDataDefs()
  //
  // Return an enumerator for aff data definitions.
  //
  STDMETHOD(GetDataDefs) (THIS_
    // Definition Enumeration
    /*[out,retval]*/ IEnumAAFDataDefs ** ppEnum) PURE;


  //***********************************************************
  //
  // CountDataDefs()
  //
  // Writes the number of data definition objects into the
  // *pResult argument.
  // 
  // Succeeds if all of the following are true:
  // - the pResult pointer is valid.
  // 
  // If this method fails nothing will be written to *pResult.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pResult is null.
  //
  STDMETHOD(CountDataDefs) (THIS_
    // Total number of data definition objects
    /*[out, retval]*/ aafUInt32 *  pResult) PURE;


  //***********************************************************
  //
  // RegisterOperationDef()
  //
  // Add the operation definition object to the header's list of definitions.
  //
  STDMETHOD(RegisterOperationDef) (THIS_
    // Operation Definition Object
    /*[in]*/ IAAFOperationDef * pOperationDef) PURE;


  //***********************************************************
  //
  // LookupOperationDef()
  //
  // Return the operation definition object with the given id.
  //
  STDMETHOD(LookupOperationDef) (THIS_
    // Operation Def Unique ID
    /*[in, ref]*/ aafUID_constref  operationId,

    // Operation definition object
    /*[out,retval]*/ IAAFOperationDef ** ppOperationDef) PURE;


  //***********************************************************
  //
  // GetOperationDefs()
  //
  // Return an enumerator for all operation definitions.
  //
  STDMETHOD(GetOperationDefs) (THIS_
    // Definition Enumeration
    /*[out,retval]*/ IEnumAAFOperationDefs ** ppEnum) PURE;


  //***********************************************************
  //
  // CountOperationDefs()
  //
  // Writes the number of operation definition objects into the
  // *pResult argument.
  // 
  // Succeeds if all of the following are true:
  // - the pResult pointer is valid.
  // 
  // If this method fails nothing will be written to *pResult.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pResult is null.
  //
  STDMETHOD(CountOperationDefs) (THIS_
    // Total number of operation definition objects
    /*[out, retval]*/ aafUInt32 *  pResult) PURE;


  //***********************************************************
  //
  // RegisterParameterDef()
  //
  // Add the parameter definition object to the header's list of definitions.
  //
  STDMETHOD(RegisterParameterDef) (THIS_
    // Parameter Definition Object
    /*[in]*/ IAAFParameterDef * pParmDef) PURE;


  //***********************************************************
  //
  // LookupParameterDef()
  //
  // Return the parameter definition object with the given id.
  //
  STDMETHOD(LookupParameterDef) (THIS_
    // Parameter Unique ID
    /*[in, ref]*/ aafUID_constref  parameterId,

    // Parameter definition object
    /*[out,retval]*/ IAAFParameterDef ** ppParmDef) PURE;


  //***********************************************************
  //
  // GetParameterDefs()
  //
  // Return an enumerator for all parameter definitions.
  //
  STDMETHOD(GetParameterDefs) (THIS_
    // Definition Enumeration
    /*[out,retval]*/ IEnumAAFParameterDefs ** ppEnum) PURE;


  //***********************************************************
  //
  // CountParameterDefs()
  //
  // Writes the number of parameter definition objects into the
  // *pResult argument.
  // 
  // Succeeds if all of the following are true:
  // - the pResult pointer is valid.
  // 
  // If this method fails nothing will be written to *pResult.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pResult is null.
  //
  STDMETHOD(CountParameterDefs) (THIS_
    // Total number of parameter definition objects
    /*[out, retval]*/ aafUInt32 *  pResult) PURE;


  //***********************************************************
  //
  // RegisterCodecDef()
  //
  // Add the codec definition object to the header's list of definitions.
  //
  STDMETHOD(RegisterCodecDef) (THIS_
    // Codec Definition Object
    /*[in]*/ IAAFCodecDef * pParmDef) PURE;


  //***********************************************************
  //
  // LookupCodecDef()
  //
  // Return the codec definition object with the given id.
  //
  STDMETHOD(LookupCodecDef) (THIS_
    // Parameter Unique ID
    /*[in, ref]*/ aafUID_constref  parameterId,

    // Codec definition object
    /*[out,retval]*/ IAAFCodecDef ** ppParmDef) PURE;


  //***********************************************************
  //
  // GetCodecDefs()
  //
  // Return an enumerator for all codec definitions.
  //
  STDMETHOD(GetCodecDefs) (THIS_
    // Definition Enumeration
    /*[out,retval]*/ IEnumAAFCodecDefs ** ppEnum) PURE;


  //***********************************************************
  //
  // CountCodecDefs()
  //
  // Writes the number of codec definition objects into the
  // *pResult argument.
  // 
  // Succeeds if all of the following are true:
  // - the pResult pointer is valid.
  // 
  // If this method fails nothing will be written to *pResult.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pResult is null.
  //
  STDMETHOD(CountCodecDefs) (THIS_
    // Total number of codec definition objects
    /*[out, retval]*/ aafUInt32 *  pResult) PURE;


  //***********************************************************
  //
  // RegisterContainerDef()
  //
  // Add the container definition object to the header's list of definitions.
  //
  STDMETHOD(RegisterContainerDef) (THIS_
    // Container Definition Object
    /*[in]*/ IAAFContainerDef * pParmDef) PURE;


  //***********************************************************
  //
  // LookupContainerDef()
  //
  // Return the container definition object with the given id.
  //
  STDMETHOD(LookupContainerDef) (THIS_
    // Parameter Unique ID
    /*[in, ref]*/ aafUID_constref  parameterId,

    // Container definition object
    /*[out,retval]*/ IAAFContainerDef ** ppParmDef) PURE;


  //***********************************************************
  //
  // GetContainerDefs()
  //
  // Return an enumerator for all container definitions.
  //
  STDMETHOD(GetContainerDefs) (THIS_
    // Definition Enumeration
    /*[out,retval]*/ IEnumAAFContainerDefs ** ppEnum) PURE;


  //***********************************************************
  //
  // CountContainerDefs()
  //
  // Writes the number of container definition objects into the
  // *pResult argument.
  // 
  // Succeeds if all of the following are true:
  // - the pResult pointer is valid.
  // 
  // If this method fails nothing will be written to *pResult.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pResult is null.
  //
  STDMETHOD(CountContainerDefs) (THIS_
    // Total number of container definition objects
    /*[out, retval]*/ aafUInt32 *  pResult) PURE;


  //***********************************************************
  //
  // RegisterInterpolationDef()
  //
  // Add the Interpolation definition object to the header's list of definitions.
  //
  STDMETHOD(RegisterInterpolationDef) (THIS_
    // Interpolation Definition Object
    /*[in]*/ IAAFInterpolationDef * pInterpolationDef) PURE;


  //***********************************************************
  //
  // LookupInterpolationDef()
  //
  // Return the Interpolation definition object with the given id.
  //
  STDMETHOD(LookupInterpolationDef) (THIS_
    // Parameter Unique ID
    /*[in, ref]*/ aafUID_constref  parameterId,

    // Interpolation definition object
    /*[out,retval]*/ IAAFInterpolationDef ** ppInterpolationDef) PURE;


  //***********************************************************
  //
  // GetInterpolationDefs()
  //
  // Return an enumerator for aff Interpolation definitions.
  //
  STDMETHOD(GetInterpolationDefs) (THIS_
    // Definition Enumeration
    /*[out,retval]*/ IEnumAAFInterpolationDefs ** ppEnum) PURE;


  //***********************************************************
  //
  // CountInterpolationDefs()
  //
  // Writes the number of interpolation definition objects into the
  // *pResult argument.
  // 
  // Succeeds if all of the following are true:
  // - the pResult pointer is valid.
  // 
  // If this method fails nothing will be written to *pResult.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pResult is null.
  //
  STDMETHOD(CountInterpolationDefs) (THIS_
    // Total number of interpolation definition objects
    /*[out, retval]*/ aafUInt32 *  pResult) PURE;


  //***********************************************************
  //
  // RegisterPluginDef()
  //
  // Add the Interpolation definition object to the header's list of definitions.
  //
  STDMETHOD(RegisterPluginDef) (THIS_
    // plugin definition Object
    /*[in]*/ IAAFPluginDef * pPlugDef) PURE;


  //***********************************************************
  //
  // LookupPluginDef()
  //
  // Return the plugin descriptor object with the given id.
  //
  STDMETHOD(LookupPluginDef) (THIS_
    // Parameter Unique ID
    /*[in, ref]*/ aafUID_constref  parameterId,

    // plugin descriptor object
    /*[out,retval]*/ IAAFPluginDef ** ppPlugDef) PURE;


  //***********************************************************
  //
  // GetPluginDefs()
  //
  // Return an enumerator for all plugin descriptors.
  //
  STDMETHOD(GetPluginDefs) (THIS_
    // Definition Enumeration
    /*[out,retval]*/ IEnumAAFPluginDefs ** ppEnum) PURE;


  //***********************************************************
  //
  // CountPluginDefs()
  //
  // Writes the number of plugin definition objects into the
  // *pResult argument.
  // 
  // Succeeds if all of the following are true:
  // - the pResult pointer is valid.
  // 
  // If this method fails nothing will be written to *pResult.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pResult is null.
  //
  STDMETHOD(CountPluginDefs) (THIS_
    // Total number of plugin definition objects
    /*[out, retval]*/ aafUInt32 *  pResult) PURE;

  END_INTERFACE
};
#endif // __IAAFDictionary_INTERFACE_DEFINED__



// IAAFEdgecode

// ************************
//
// Interface IAAFEdgecode
//
// ************************
 



#ifndef __IAAFEdgecode_INTERFACE_DEFINED__
#define __IAAFEdgecode_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFEdgecode;

#undef  INTERFACE
#define INTERFACE   IAAFEdgecode

DECLARE_INTERFACE_(IAAFEdgecode, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFEdgecode methods *** */


  //***********************************************************
  //
  // Initialize()
  //
  // This function creates a new edgecode clip with the
  // given property values.  The edgecode value is represented with an
  // aafEdgecode_t struct consisting of startFrame, filmKind, and
  // codeFormat.
  //
  STDMETHOD(Initialize) (THIS_
    // Length Property Value
    /*[in]*/ aafLength_t    length  ,

    // Edgecode Value
    /*[in]*/ aafEdgecode_t  edgecode) PURE;

  //***********************************************************
  //
  // GetEdgecode()
  //
  // This set of functions returns the required property values
  // for the object identified by XXX.
  //
  STDMETHOD(GetEdgecode) (THIS_
    // Edgecode
    /*[out]*/ aafEdgecode_t *  edgecode) PURE;


  END_INTERFACE
};
#endif // __IAAFEdgecode_INTERFACE_DEFINED__



// IAAFOperationDef

// ************************
//
// Interface IAAFOperationDef
//
// ************************







 

#ifndef __IAAFOperationDef_INTERFACE_DEFINED__
#define __IAAFOperationDef_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFOperationDef;

#undef  INTERFACE
#define INTERFACE   IAAFOperationDef

DECLARE_INTERFACE_(IAAFOperationDef, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFOperationDef methods *** */

  //***********************************************************
  //
  // Initialize()
  //
  // Init all fields of a definition object.
  //
  STDMETHOD(Initialize) (THIS_
    // AUID for new DeObject
    /*[in, ref]*/ aafUID_constref  id,

    // Name for new DefObject
    /*[in, string]*/ aafCharacter_constptr  pName,

    // Description for new DefObject
    /*[in, string]*/ aafCharacter_constptr  pDescription) PURE;


  //***********************************************************
  //
  // GetDataDef()
  //
  // Places the DataDefinition object attached to this
  // IAAFOperationDef into the *ppDataDef argument.  The data
  // definition will match one of the AUIDs in the file
  // AAFDataDefs.h, (which includes DDEF_PICTURE, and
  // DDEF_SOUND), and indicates what type of data the operation will
  // be performed upon.  For example, a video dissolve will have the
  // data def DEF_VIDEO.  If a data definition is used which is not
  // from AAFDataDefs.h, then the client is responsible for making
  // sure that a data definition object with that ID exists in the
  // dictionary.  The SDK will take care of creating the standard data
  // definitions.
  //
  // Succeeds if all of the following are true:
  // - the ppDataDefID pointer is valid.
  // - A valid DataDefinition exists.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - ppDataDef is null.
  //
  // AAFRESULT_INVALID_DATA_DEF
  //   - There is no IAAFDataDefinition.  There has to be one of some
  //     kind for this to be a valid operation definition.
  //
  STDMETHOD(GetDataDef) (THIS_
    // Returned DataDefinition object
    /*[out]*/ IAAFDataDef ** ppDataDef) PURE;


  //***********************************************************
  //
  // SetDataDef()
  //
  // Sets the IAAFDataDefinition of this IAAFOperationDef to be the
  // given one.  The
  // data definition will match one of the AUIDs in the file
  // AAFDataDefs.h, (which includes DDEF_PICTURE, and
  // DDEF_SOUND), and indicates what type of data the operation will
  // be performed upon.  For example, a video dissolve will have the
  // data def DEF_VIDEO.  If a data definition is used which is not
  // from AAFDataDefs.h, then the client is responsible for making
  // sure that a data definition object with that ID exists in the
  // dictionary.  The SDK will take care of creating the standard data
  // definitions.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pDataDef is null.
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  STDMETHOD(SetDataDef) (THIS_
    // Essence Descriptor object
    /*[in]*/ IAAFDataDef * pDataDef) PURE;


  //***********************************************************
  //
  // IsTimeWarp()
  //
  // Returns the value of isTimeWarp.  IsTimeWarp is true if the
  // length of an IAAFOperationGroup is different from the lengths of
  // the input segments.  For example, a slow motion effect.
  //
  // Succeeds if all of the following are true:
  // - the bIsTimeWarp pointer is valid.
  // 
  // If this method fails nothing will be written to *bIsTimeWarp.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - bIsTimeWarp arg is NULL.
  //
  STDMETHOD(IsTimeWarp) (THIS_
    // pointer to the return value
    /*[out, retval]*/ aafBoolean_t *  bIsTimeWarp) PURE;


  //***********************************************************
  //
  // SetIsTimeWarp()
  //
  // Sets the IsTimeWarp boolean.  IsTimeWarp is true if the length of
  // an IAAFOperationGroup is different from the lengths of the input
  // segments.  For example, a slow motion effect.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  STDMETHOD(SetIsTimeWarp) (THIS_
    // is timewarp value
    /*[in]*/ aafBoolean_t  IsTimeWarp) PURE;


  //***********************************************************
  //
  // PrependDegradeToOperation()
  //
  // Prepend another operation definition to the DegradeTo list of
  // definitions.  Use this function to add an operation definition to
  // be scanned first when searching for the a replacement (a more
  // desirable alternate operation).
  // 
  // Succeeds if all of the following are true:
  // - the pOperationDef pointer is valid.
  // 
  // If this method fails no state will be changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pOperationDef is null.
  //
  STDMETHOD(PrependDegradeToOperation) (THIS_
    // Degrade To Operation Definition Object
    /*[in]*/ IAAFOperationDef * pOperationDef) PURE;


  //***********************************************************
  //
  // AppendDegradeToOperation()
  //
  // Append another operation definition to the DegradeTo list of
  // definitions.  Use this function to add an operation definition to
  // be scanned last when searching for the a replacement (a less
  // desirable alternate operation).
  // 
  // Succeeds if all of the following are true:
  // - the pOperationDef pointer is valid.
  // 
  // If this method fails no state will be changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pOperationDef is null.
  //
  STDMETHOD(AppendDegradeToOperation) (THIS_
    // Degrade To operation Definition Object
    /*[in]*/ IAAFOperationDef * pOperationDef) PURE;


  //***********************************************************
  //
  // InsertDegradeToOperationAt()
  //
  // Insert an operation definition into the DegradeTo list of
  // definitions at the given index.  Operation definitions already
  // existing at the given and higher indices will be moved up to the
  // next higher index to accommodate.
  // 
  // Succeeds if all of the following are true:
  // - the pOperationDef pointer is valid.
  // - index is less than or equal to the value returned by
  //   CountDegradeToOperations().
  // 
  // If this method fails no state will be changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pOperationDef is null.
  //
  // AAFRESULT_BADINDEX
  //   - index is greater than the value returned by
  //     CountDegradeToOperations().
  //
  STDMETHOD(InsertDegradeToOperationAt) (THIS_
    // index where operation def is to be inserted
    /*[in]*/ aafUInt32  index,

    // Degrade To operation Definition Object
    /*[in]*/ IAAFOperationDef * pOperationDef) PURE;


  //***********************************************************
  //
  // RemoveDegradeToOperationAt()
  //
  // Removes the indexed operation definition from the DegradeTo list
  // of definitions.  Operation definitions already existing at
  // indices higher than the given index will be moved down to the
  // next lower index to accommodate.
  // 
  // Succeeds if all of the following are true:
  // - index is less than the value returned by
  //   CountDegradeToOperations().
  // 
  // If this method fails no state will be changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_BADINDEX
  //   - index is greater or equal to than the value returned by
  //     CountDegradeToOperations().
  //
  STDMETHOD(RemoveDegradeToOperationAt) (THIS_
    // index where operation def is to be inserted
    /*[in]*/ aafUInt32  index) PURE;


  //***********************************************************
  //
  // GetDegradeToOperations()
  //
  // Return an enumerator for aaf operation definitions, ordered from
  // the most desirable to the least desirable alternative.
  // 
  // Succeeds if all of the following are true:
  // - the ppEnum pointer is valid.
  // 
  // If this method fails nothing will be written to *ppEnum.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppEnum is null.
  //
  STDMETHOD(GetDegradeToOperations) (THIS_
    // Operation Definition Enumeration
    /*[out, retval]*/ IEnumAAFOperationDefs ** ppEnum) PURE;


  //***********************************************************
  //
  // CountDegradeToOperations()
  //
  // Retrieves the number of Degrade To operations currently present
  // and places that number in *pResult.
  // 
  // Succeeds if all of the following are true:
  // - the pResult pointer is valid.
  // 
  // If this method fails nothing will be written to *pResult.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pResult is null.
  //
  STDMETHOD(CountDegradeToOperations) (THIS_
    // resulting count of Degrade To operations
    /*[out, retval]*/ aafUInt32 *  pResult) PURE;


  //***********************************************************
  //
  // GetCategory()
  //
  // This method returns an AUID indicating the category of the given operation.
  //
  // Succeeds if all of the following are true:
  // - the pValue pointer is valid.
  // 
  // If this method fails nothing will be written to *pValue.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pValue arg is NULL.
  //
  STDMETHOD(GetCategory) (THIS_
    // The enumeration describing the current category
    /*[out]*/ aafUID_t*  pValue) PURE;


  //***********************************************************
  //
  // SetCategory()
  //
  // This method sets an AUID indicating the category of the given operation.
  // 
  // If this method fails no state will be changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  STDMETHOD(SetCategory) (THIS_
    // The enumeration describing the current categor
    /*[in, ref]*/ aafUID_constref  value) PURE;


  //***********************************************************
  //
  // GetNumberInputs()
  //
  // Gets the Number of input media segments.
  // 
  // Succeeds if all of the following are true:
  // - the pNumberInputs pointer is valid.
  // 
  // If this method fails nothing will be written to *pNumberInputs.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pNumberInputs arg is NULL.
  //
  STDMETHOD(GetNumberInputs) (THIS_
    // Pointer to Number of Inputs
    /*[out, retval]*/ aafInt32 *  pNumberInputs) PURE;


  //***********************************************************
  //
  // SetNumberInputs()
  //
  // Sets the Number of input media segments.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  STDMETHOD(SetNumberInputs) (THIS_
    // Number of Inputs
    /*[in]*/ aafInt32  NumberInputs) PURE;


  //***********************************************************
  //
  // GetBypass()
  //
  // Gets the Bypass media segment index, which is a value from 0
  // to one less than that returned by GetNumberInputs().  This
  // value allows the client application to pick one of the inputs
  // (foreground, background, etc.) to stand in for the
  // effect if it is not available, and none of the degrade to
  // effects are available.
  // 
  // Succeeds if all of the following are true:
  // - the pBypass pointer is valid.
  // 
  // If this method fails nothing will be written to *pBypass.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pBypass arg is NULL.
  //
  STDMETHOD(GetBypass) (THIS_
    // Pointer to a Bypass media segment index 
    /*[out,retval]*/ aafUInt32 *  pBypass) PURE;


  //***********************************************************
  //
  // SetBypass()
  //
  // Sets the media segment index, which is a value from 0 to one
  // less than that returned by GetNumberInputs().  This value
  // allows the client application to pick one of the inputs
  // (foreground, background, etc.) to stand in for the
  // effect if it is not available, and none of the degrade to
  // effects are available.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  STDMETHOD(SetBypass) (THIS_
    // Bypass media segment index
    /*[in]*/ aafUInt32  bypass) PURE;


  //***********************************************************
  //
  // AddParameterDef()
  //
  // Add the Parameter Definition object to the unordered list of
  // parameter definitions. 
  // 
  // Succeeds if all of the following are true:
  // - the pAAFParameterDef pointer is valid. 
  // - the given Parameter Definition does not exists in this Operation
  //   Definition already
  // 
  // If this method fails no state will be changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pAAFParameterDef is null.
  //
  // AAFRESULT_OBJECT_ALREADY_ATTACHED
  //	- pAAFParameterDef is already in this OperationDef
  //
  STDMETHOD(AddParameterDef) (THIS_
    // Parameter definition Object
    /*[in]*/ IAAFParameterDef * pParameterDef) PURE;


  //***********************************************************
  //
  // GetParameterDefs()
  //
  // Return an enumerator for the unordered list of AAF Parameter
  // definitions.
  // 
  // Succeeds if all of the following are true:
  // - the ppEnum pointer is valid.
  // 
  // If this method fails nothing will be written to *ppEnum.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppEnum is null.
  //
  STDMETHOD(GetParameterDefs) (THIS_
    // Parameter definition enumeration
    /*[out,retval]*/ IEnumAAFParameterDefs ** ppEnum) PURE;


  //***********************************************************
  //
  // CountParameterDefs()
  //
  // This method returns the number of parameter defs.
  //
  // Succeeds if all of the following are true:
  // - the pResult pointer is valid.
  // 
  // If this method fails nothing will be written to *pResult.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pResult arg is NULL.
  //
  STDMETHOD(CountParameterDefs) (THIS_
    // Number of parameter defs
    /*[out]*/ aafUInt32 *  pResult) PURE;


  //***********************************************************
  //
  // LookupParameterDef()
  //
  // This method looks up the parameter def corresponding to the given
  // ID.
  //
  // Succeeds if all of the following are true:
  // - the given ID corresponds to a known parameter def
  // - the ppParameterDef pointer is valid.
  // 
  // If this method fails nothing will be written to *ppParameterDef.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pParameterDef arg is NULL.
  //
  // AAFRESULT_OBJECT_NOT_FOUND
  //   - given ID does not correspond to a known parameter def.
  //
  STDMETHOD(LookupParameterDef) (THIS_
    // ID of parameter def to look up
    /*[in]*/ aafUID_constref  parameterDefId,

    // resulting parameter def
    /*[out]*/ IAAFParameterDef ** ppParameterDef) PURE;

  END_INTERFACE
};
#endif // __IAAFOperationDef_INTERFACE_DEFINED__



// IAAFEssenceAccess

// ************************
//
// Interface IAAFEssenceAccess
//
// ************************









#ifndef __IAAFEssenceAccess_INTERFACE_DEFINED__
#define __IAAFEssenceAccess_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFEssenceAccess;

#undef  INTERFACE
#define INTERFACE   IAAFEssenceAccess

DECLARE_INTERFACE_(IAAFEssenceAccess, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFEssenceAccess methods *** */


  //***********************************************************
  //
  // SetEssenceCodecFlavour()
  //
  // Sets which flavour of the codec ID is to be used.
  //
  // An example of a flavour would be a number of standard starting
  // JPEG tables.
  //
  STDMETHOD(SetEssenceCodecFlavour) (THIS_
    // The particular flavour
    /*[in, ref]*/ aafUID_constref  flavour) PURE;


  //***********************************************************
  //
  // WriteSamples()
  //
  // Writes data to the given essence stream.
  //
  // A single video frame is ONE sample.
  //
  // Buflen must be large enough to hold the total sample size.
  //
  // Possible Errors:
  //   AAFRESULT_SINGLE_CHANNEL_OP -- Tried to write to an interleaved
  //                                  stream.
  //   AAFRESULT_BADDATAADDRESS    -- The buffer must not be a NULL
  //                                  pointer.
  //
  STDMETHOD(WriteSamples) (THIS_
    // write this many samples
    /*[in]*/ aafUInt32  nSamples,

    // from a buffer of this size
    /*[in]*/ aafUInt32  buflen,

    // from a buffer
    /*[in,size_is(buflen)]*/ aafDataBuffer_t  buffer,

    // The number of samples actually written
    /*[out, ref]*/ aafUInt32 *  samplesWritten,

    // The number of bytes actually written
    /*[out, ref]*/ aafUInt32 *  bytesWritten) PURE;


  //***********************************************************
  //
  // GetLargestSampleSize()
  //
  // Returns the size in bytes of the largest sample for a given
  // essence type.
  //
  // For uncompressed data, or the output of the software codec, the
  // sample size will propably be a constant.
  //
  // The essence type parameter exists to support codecs with multiple
  // interleaved essence types.
  //
  STDMETHOD(GetLargestSampleSize) (THIS_
    // for this essence type
    /*[in]*/ IAAFDataDef * pDataDef,

    // the largest sample size
    /*[out]*/ aafLength_t*  maxSize) PURE;


  //***********************************************************
  //
  // GetIndexedSampleSize()
  //
  // Returns the size in bytes of the given sample for a given essence
  // type.
  //
  // For uncompressed data, or the output of the software codec, the
  // sample size will propably be a constant.
  //
  // The essence type parameter exists to support codecs with multiple
  // interleaved essence types.
  // 
  // Possible Errors:
  //   AAFRESULT_NULL_PARAM      -- A return parameter was NULL.
  //   AAFRESULT_BADSAMPLEOFFSET -- The supplied sample offset is out
  //                                of range.
  //
  STDMETHOD(GetIndexedSampleSize) (THIS_
    // and this essence type
    /*[in]*/ IAAFDataDef * pDataDef,

    // for this [0-based] sample frame number
    /*[in]*/ aafPosition_t  frameNum,

    // How big is the sample frame?
    /*[out]*/ aafLength_t*  frameSize) PURE;


  //***********************************************************
  //
  // SetTransformParameters()
  //
  // Sets a series of format objects which will be used to describe
  // the in-memory format.
  //
  // This is the format expected on writes and produced on reads.
  //
  // On writes, the data will be written in this format, except
  // where a software codec may be used.  On reads, the data will be
  // translated to this format.
  //
  // The order of the parameters does matter, as transformations will
  // be applied in that order to get from the on-disk format to the
  // in-memory format.
  //
  STDMETHOD(SetTransformParameters) (THIS_
    // A set of transforms to apply to the essence if required
    /*[in]*/ IAAFEssenceFormat * op) PURE;
	 

  //***********************************************************
  //
  // CountSamples()
  //
  // Returns the number of samples of the given essence type on the
  // given essence stream.
  // 
  // A video sample is one frame.
  //
  STDMETHOD(CountSamples) (THIS_
    // For this essence dataDef
    /*[in]*/ IAAFDataDef * pDataDef,

    // find out how many samples are present
    /*[out]*/ aafLength_t *  result) PURE;


  //***********************************************************
  //
  // ReadSamples()
  //
  // Read a given number of samples from an opened essence stream.
  //
  // This call will only return a single channel of essence from an
  // interleaved stream.
  //
  // A video sample is a frame.
  //
  // Buflen is in bytes, and should be large enough to hold the
  // samples after the requested transforms have been applied.
  //
  // Possible Errors:
  //   AAFRESULT_END_OF_DATA -- Hit the end of the essence (like
  //                            EOF) while reading.
  //   AAFRESULT_SMALLBUF    -- Buffer too small for samples.
  //
  STDMETHOD(ReadSamples) (THIS_
    // Read this many samples
    /*[in]*/ aafUInt32  nSamples,

    // into a buffer of this size
    /*[in]*/ aafUInt32  buflen,

    // The transfer buffer
    /*[out, size_is(buflen),length_is(*bytesRead)]*/ aafDataBuffer_t  buffer,

    // The number of samples actually read
    /*[out, ref]*/ aafUInt32 *  samplesRead,

    // The number of bytes actually read
    /*[out, ref]*/ aafUInt32 *  bytesRead) PURE;


  //***********************************************************
  //
  // Seek()
  //
  // The seek function for essence.
  //
  // Useful only on reading, you can't seek aound while writing
  // essence.
  //
  // An audio frame is one sample across all channels.
  //
  // Possible Errors:
  //   AAFRESULT_BADSAMPLEOFFSET -- Hit the end of the essence
  //                                (like EOF) while reading.
  //
  STDMETHOD(Seek) (THIS_
    // A 0-based offset in units of the sample rate to seek to.
    /*[in]*/ aafPosition_t  sampleFrameNum) PURE;


  //***********************************************************
  //
  // GetFileFormat()
  //
  // Given an AAFEssenceFormat, read the essence parameters inside
  // and set the values from the file format.
  //
  STDMETHOD(GetFileFormat) (THIS_
    // An AAFEssenceFormat with parameter codes set but no values
    /*[in]*/ IAAFEssenceFormat * opsTemplate,

    // Another AAFEssenceFormat with values set
    /*[out]*/ IAAFEssenceFormat ** opsResult) PURE;


  //***********************************************************
  //
  // GetFileFormatParameterList()
  //
  // Returns an AAFEssenceFormat containing a list of all parameters
  // supported by the current codec.
  //
  STDMETHOD(GetFileFormatParameterList) (THIS_
    // An ampty AAFEssenceFormat object
    /*[out]*/ IAAFEssenceFormat ** ops) PURE;


  //***********************************************************
  //
  // GetEmptyFileFormat()
  //
  // Returns an empty AAFEssenceFormat object.  This is the factory
  // method for AAFEssenceFormat.
  //
  STDMETHOD(GetEmptyFileFormat) (THIS_
    // An ampty AAFEssenceFormat object
    /*[out]*/ IAAFEssenceFormat ** ops) PURE;


  //***********************************************************
  //
  // PutFileFormat()
  //
  // Given an AAFEssenceFormat, read the essence parameters inside
  // and change the file format.
  //
  STDMETHOD(PutFileFormat) (THIS_
    // An AAFEssenceFormat with one or more parameter/value pairs
    /*[in]*/ IAAFEssenceFormat * ops) PURE;


  //***********************************************************
  //
  // GetCodecName()
  //
  // Returns the full name of the given codec expanded for human
  // consumption.
  //
  // No other call uses this name, so it may be fully
  // descriptive, esp. of limitations.
  //
  // The name will be truncated to fit within "buflen" bytes.
  //
  // Possible Errors:
  //   AAFRESULT_CODEC_INVALID - The given codec ID is not loaded.
  //   AAFRESULT_SMALLBUF      - The buffer is not large enough to
  //                             hold the data.
  //
  STDMETHOD(GetCodecName) (THIS_
    // The size of the name buffer to be filled
    /*[in]*/ aafUInt32  namelen,

    // The buffer to fill
    /*[out,size_is(namelen)]*/ aafCharacter *  name) PURE;


  //***********************************************************
  //
  // GetCodecID()
  //
  // Returns the codec ID being used to handle the specified essence.
  //
  // This will be required in order to send private data to the
  // codec.
  //
  // The name will be truncated to fit within "buflen" bytes.
  //
  STDMETHOD(GetCodecID) (THIS_
    // Returns the current codec ID
    /*[out]*/ aafCodecID_t *  codecID) PURE;


  //***********************************************************
  //
  // CompleteWrite()
  //
  // Handle any format related writing at the end and adjust mob
  // lengths.  Must be called before releasing a write essence
  // access.
  //
  // Possible Errors:
  //   AAFRESULT_STREAM_FULL
  //   - The essence can not be written because of a fault such as a
  //     disk full error in the underlying operating system.
  STDMETHOD(CompleteWrite) (THIS) PURE;






  END_INTERFACE
};
#endif // __IAAFEssenceAccess_INTERFACE_DEFINED__


// IAAFEssenceData

// ************************
//
// Interface IAAFEssenceData
//
// ************************





#ifndef __IAAFEssenceData_INTERFACE_DEFINED__
#define __IAAFEssenceData_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFEssenceData;

#undef  INTERFACE
#define INTERFACE   IAAFEssenceData

DECLARE_INTERFACE_(IAAFEssenceData, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFEssenceData methods *** */


  //***********************************************************
  //
  // Initialize()
  //
  // Associates a weak reference to the given file mob with the
  // essence data.
  //
  // Succeeds if all of the following are true:
  // - the pFileMob pointer is valid and points to 
  // a file mob (contains a file descriptor).
  // 
  // If this method fails no state will be changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pFileMob is null.
  //
  STDMETHOD(Initialize) (THIS_
    // reference to a file mob
    /*[in]*/ IAAFSourceMob * pFileMob) PURE;

  //***********************************************************
  //
  // Write()
  //
  // Write pre-interleaved data to a essence stream.
  //
  STDMETHOD(Write) (THIS_
    // write this many bytes
    /*[in]*/ aafUInt32  bytes,

    // here is the buffer
    /*[out, size_is(bytes)]*/ aafDataBuffer_t  buffer,

    // 
    /*[out,ref]*/ aafUInt32 *  bytesWritten) PURE;


  //***********************************************************
  //
  // Read()
  //
  // Read pre-interleaved data from a essence stream.
  //
  STDMETHOD(Read) (THIS_
    // read this many bytes
    /*[in]*/ aafUInt32  bytes,

    // here is the buffer
    /*[out, size_is(bytes), length_is(*bytesRead)]*/ aafDataBuffer_t  buffer,

    // 
    /*[out,ref]*/ aafUInt32 *  bytesRead) PURE;


  //***********************************************************
  //
  // SetPosition()
  //
  // Seek to absolute position within the essence data.
  //
  STDMETHOD(SetPosition) (THIS_
    // offset from beginning of essence
    /*[in]*/ aafPosition_t  offset) PURE;


  //***********************************************************
  //
  // GetPosition()
  //
  // Get the absolute position within the essence data.
  //
  STDMETHOD(GetPosition) (THIS_
    // offset from beginning of essence
    /*[out]*/ aafPosition_t*  pOffset) PURE;


  //***********************************************************
  //
  // GetSize()
  //
  // Return the total size of the essence data.
  //
  STDMETHOD(GetSize) (THIS_
    // size of essence data
    /*[out]*/ aafLength_t *  pSize ) PURE;


  //***********************************************************
  //
  // SetFileMob()
  //
  // Associates a weak reference to the given file mob with the
  // essence data.
  //
  // Succeeds if all of the following are true:
  // - the pFileMob pointer is valid and points to 
  // a file mob (contains a file descriptor).
  // 
  // If this method fails no state will be changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pFileMob is null.
  //
  STDMETHOD(SetFileMob) (THIS_
    // reference to a file mob
    /*[in]*/ IAAFSourceMob * pFileMob) PURE;


  //***********************************************************
  //
  // GetFileMob()
  //
  // Associates a weak reference to the given file mob with the
  // essence data.
  //
  // Succeeds if all of the following are true:
  // - the ppFileMob pointer is valid and a weak
  // reference to the associated file mob can be
  // resolved.
  // 
  // If this method fails no state will be changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppFileMob is null.
  //
  STDMETHOD(GetFileMob) (THIS_
    // reference to a file mob
    /*[in]*/ IAAFSourceMob ** ppFileMob) PURE;


  //***********************************************************
  //
  // GetFileMobID()
  //
  // Return the mob id used to find the file mob associated with this
  // essence.  The file mob must exist in the same file as this
  // essence data.
  //
  STDMETHOD(GetFileMobID) (THIS_
    // the file mob id associated with essence
    /*[out]*/ aafMobID_t *  pFileMobID) PURE;


  END_INTERFACE
};
#endif // __IAAFEssenceData_INTERFACE_DEFINED__



// IAAFEssenceDescriptor

// ************************
//
// Interface IAAFEssenceDescriptor
//
// ************************





#ifndef __IAAFEssenceDescriptor_INTERFACE_DEFINED__
#define __IAAFEssenceDescriptor_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFEssenceDescriptor;

#undef  INTERFACE
#define INTERFACE   IAAFEssenceDescriptor

DECLARE_INTERFACE_(IAAFEssenceDescriptor, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFEssenceDescriptor methods *** */

  //***********************************************************
  //
  // CountLocators()
  //
  // Return the number of locators attached to this essence
  // descriptor.  The number of locators may be zero if the essence is
  // in the current file.
  // 
  // Succeeds if all of the following are true:
  // - the pCount pointer is valid.
  // 
  // If this method fails nothing is written to *pCount.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pCount is null.
  //
  STDMETHOD(CountLocators) (THIS_
    // Returns the number of locators
    /*[out]*/ aafUInt32 *  pResult) PURE;


  //***********************************************************
  //
  // AppendLocator()
  //
  // Append another locator to this essence descriptor.  Use this
  // function to add a locator to be scanned last when searching for
  // the essence (a secondary location for the essence).
  // 
  // Succeeds if all of the following are true:
  // - the pLocator pointer is valid.
  // 
  // If this method fails no state will be changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pLocator is null.
  //
  STDMETHOD(AppendLocator) (THIS_
    // Locator to append
    /*[in]*/ IAAFLocator * pLocator) PURE;


  //***********************************************************
  //
  // PrependLocator()
  //
  // Prepend another locator to this essence descriptor.  Use this
  // function to add a locator to be scanned first when searching for
  // the essence (a new primary location for the essence).
  // 
  // Succeeds if all of the following are true:
  // - the pLocator pointer is valid.
  // 
  // If this method fails no state will be changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pLocator is null.
  //
  STDMETHOD(PrependLocator) (THIS_
    // Locator to append
    /*[in]*/ IAAFLocator * pLocator) PURE;


  //***********************************************************
  //
  // InsertLocatorAt()
  //
  // Inserts the given locator at the given index.  Locators already
  // existing at the given and higher indices will be moved to the
  // next higher index to accommodate.
  // 
  // Succeeds if all of the following are true:
  // - the pLocator pointer is valid.
  // - index is less than or equal to the value returned by
  //   CountLocators().
  // 
  // If this method fails no state will be changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pLocator is null.
  //
  // AAFRESULT_BADINDEX
  //   - index is greater than the value returned by
  //     CountLocators().
  //
  STDMETHOD(InsertLocatorAt) (THIS_
    // index at which locator is to be inserted
    /*[in]*/ aafUInt32  index,

    // Locator to append
    /*[in]*/ IAAFLocator * pLocator) PURE;


  //***********************************************************
  //
  // GetLocatorAt()
  //
  // Retrieves the locator at the given index.
  // 
  // Succeeds if all of the following are true:
  // - the pLocator pointer is valid.
  // - index is less than the value returned by CountLocators().
  // 
  // If this method fails no state will be changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pLocator is null.
  //
  // AAFRESULT_BADINDEX
  //   - index is greater than or equal to the value returned by
  //     CountLocators().
  //
  STDMETHOD(GetLocatorAt) (THIS_
    // index of locator to retrieve
    /*[in]*/ aafUInt32  index,

    // returned locator
    /*[out, retval]*/ IAAFLocator ** ppLocator) PURE;


  //***********************************************************
  //
  // RemoveLocatorAt()
  //
  // Removes the locator at the given index.  Locators already
  // existing at indices higher than the given index will be moved to
  // the next lower index to accommodate.
  // 
  // Succeeds if all of the following are true:
  // - index is less than the value returned by CountLocators().
  // 
  // If this method fails no state will be changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_BADINDEX
  //   - index is greater than or equal to the value returned by
  //     CountLocators().
  //
  STDMETHOD(RemoveLocatorAt) (THIS_
    // index of locator to remove
    /*[in]*/ aafUInt32  index) PURE;


  //***********************************************************
  //
  // GetLocators()
  //
  // Returns an enumerator to the locators.  The number of locators
  // may be zero if the essence is in the current file.
  // 
  // Succeeds if all of the following are true:
  // - the ppEnum pointer is valid.
  // 
  // If this method fails nothing will be written to *ppEnum.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppEnum is null.
  //
  STDMETHOD(GetLocators) (THIS_
    // An enumerator to the locators on this essence descriptor
    /*[out]*/ IEnumAAFLocators ** ppEnum) PURE;

  END_INTERFACE
};
#endif // __IAAFEssenceDescriptor_INTERFACE_DEFINED__



// IAAFEvent

// ************************
//
// Interface IAAFEvent
//
// ************************





#ifndef __IAAFEvent_INTERFACE_DEFINED__
#define __IAAFEvent_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFEvent;

#undef  INTERFACE
#define INTERFACE   IAAFEvent

DECLARE_INTERFACE_(IAAFEvent, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFEvent methods *** */


  //***********************************************************
  //
  // GetPosition()
  //
  // This method will return the Position of this event.
  // 
  // Succeeds if all of the following are true:
  // - the pPosition pointer is valid.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pPosition arg is NULL.
  //
  STDMETHOD(GetPosition) (THIS_
    // Position property value
    /*[out,retval]*/ aafPosition_t *  pPosition) PURE;

  //***********************************************************
  //
  // SetPosition()
  //
  // This method will set the Position of this event.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.).
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  STDMETHOD(SetPosition) (THIS_
    // Position property value
    /*[in]*/ aafPosition_t  Position) PURE;


  //***********************************************************
  //
  // SetComment()
  //
  // Sets specifies the purpose of the event.
  //
  // Set the Comment property to the value specified in
  // pComment.  A copy is made of the data so the caller
  // retains ownership of the *pComment buffer and is
  // responsible for de-allocating it.  There is no pre-set limit to
  // the length of the name, other than available system memory or
  // disk space.
  // 
  // Succeeds if all of the following are true:
  // - the pComment pointer is valid.
  // 
  // If this method fails the Comment property will not be
  // changed.
  // 
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pComment arg is NULL.
  //
  STDMETHOD(SetComment) (THIS_
    // buffer from which Comment is to be read
    /*[in, string]*/ aafCharacter_constptr  pComment) PURE;


  //***********************************************************
  //
  // GetComment()
  //
  // Gets specifies the purpose of the event.
  // 
  // Writes the Comment property, with a trailing null
  // character, into the pComment buffer.  The
  // buffer is allocated by the caller.  The size of the buffer is
  // given by bufSize.  If the Comment property has not yet
  // been set, a zero-length string will be written (that is,
  // only the trailing null character). 
  // 
  // Caller may call GetCommentBufLen() to determine the
  // required buffer size.
  // 
  // If this method fails nothing will be written to
  // *pComment.
  // 
  // Succeeds if:
  // - The pComment pointer is valid.
  // - bufSize indicates that the buffer is large enough to hold
  //   Comment.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pComment arg is NULL.
  //
  // AAFRESULT_SMALL_BUF
  //   - bufSize indicates that the allocated buffer is not large
  //     enough to hold Comment.
  //
  STDMETHOD(GetComment) (THIS_
    // buffer into which Comment is to be written
    /*[out, string, size_is(bufSize)]*/ aafCharacter *  pComment,

    // size of *pComment buffer in bytes
    /*[in]*/ aafUInt32  bufSize) PURE;


  //***********************************************************
  //
  // GetCommentBufLen()
  //
  // Returns size of buffer (in bytes) required for GetComment().
  // 
  // Succeeds if:
  // - The pBufSize pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pBufSize arg is NULL.
  //
  STDMETHOD(GetCommentBufLen) (THIS_
    // size of required buffer, in bytes
    /*[out]*/ aafUInt32 *  pBufSize) PURE;


  END_INTERFACE
};
#endif // __IAAFEvent_INTERFACE_DEFINED__



// IAAFEventMobSlot

// ************************
//
// Interface IAAFEventMobSlot
//
// ************************




#ifndef __IAAFEventMobSlot_INTERFACE_DEFINED__
#define __IAAFEventMobSlot_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFEventMobSlot;

#undef  INTERFACE
#define INTERFACE   IAAFEventMobSlot

DECLARE_INTERFACE_(IAAFEventMobSlot, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFEventMobSlot methods *** */

  //***********************************************************
  //
  // GetEditRate()
  //
  // This method will get the edit rate for this mob slot.
  // 
  // Succeeds if all of the following are true:
  // - the pEditRate pointer is valid.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pEditRate arg is NULL.
  //
  STDMETHOD(GetEditRate) (THIS_
    // Edit rate property value
    /*[out,retval]*/ aafRational_t *  pEditRate) PURE;


  //***********************************************************
  //
  // SetEditRate()
  //
  // This method will get set edit rate for this mob slot.
  // 
  // Succeeds if all of the following are true:
  // - the pEditRate pointer is valid.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pEditRate arg is NULL.
  //
  STDMETHOD(SetEditRate) (THIS_
    // Edit rate property value
    /*[in]*/ aafRational_t *  pEditRate) PURE;




  END_INTERFACE
};
#endif // __IAAFEventMobSlot_INTERFACE_DEFINED__



// IAAFFile

// ************************
//
// Interface IAAFFile
//
// ************************




#ifndef __IAAFFile_INTERFACE_DEFINED__
#define __IAAFFile_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFFile;

#undef  INTERFACE
#define INTERFACE   IAAFFile

DECLARE_INTERFACE_(IAAFFile, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFFile methods *** */

  //***********************************************************
  //
  // Open()
  //
  // Associates this IAAFFile-supporting object with the storage to
  // which it is to be associated.  It will then be possible to access
  // objects within this file.
  //
  // This method will succeed only if all of the following are true:
  // - This object has not already been opened.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_ALREADY_OPEN
  //   - This object has already been Open()ed.
  STDMETHOD(Open) (THIS) PURE;


  //***********************************************************
  //
  // SaveCopyAs()
  //
  // Copies the contents of this file to *pDestFile.  Requires that
  // *pDestFile be open, writeable or modifiable, and not yet
  // contain any objects.
  //
  // NOTE! Stub only.   Implementation not yet added.
  //
  // Succeeds if:
  // - This object is currently open.
  // - The named filesystem file is writable.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_OPEN
  //   - This object is not open.
  //
  // AAFRESULT_NOT_WRITEABLE
  //   - The named file cannot be written.
  //
  STDMETHOD(SaveCopyAs) (THIS_
    // File to recieve contents
    /*[in]*/ IAAFFile * pDestFile) PURE;


  //***********************************************************
  //
  // GetHeader()
  //
  // Returns the IAAFHeader-supporting object associated with this
  // file.  If this object has never been associated with a file, a
  // new empty IAAFHeader-supporting object will be created and
  // returned.  The returned header is AddRef()ed before it is
  // returned.  Note that the header is automatically created when the
  // file object is created.
  //
  // Succeeds if:
  // - This object has already been Initialize()d.
  // - This file object is open.
  // - the given header pointer is valid.
  // - this object contains a header.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NOT_OPEN
  //   - This object is not open.
  //
  // AAFRESULT_NULL_PARAM
  //   - the header pointer arg is NULL.
  //
  // AAFRESULT_NO_HEADER
  //   - this object contains no header.
  //
  STDMETHOD(GetHeader) (THIS_
    // Set to header of the current file
    /*[out, retval]*/ IAAFHeader ** ppHeader) PURE;


  //***********************************************************
  //
  // GetRevision()
  //
  // Get the revision of the current AAF file, and returns it in pRev.
  //
  // Succeeds if:
  // - This object has already been Initialize()d.
  // - the given revision pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - the revision pointer arg is NULL.
  //
  STDMETHOD(GetRevision) (THIS_
    // Revision of the current file
    /*[out, retval]*/ aafFileRev_t *  pRev) PURE;


  //***********************************************************
  //
  // Save()
  //
  // If this IAAFFile-supporting object is open, all unsaved changes
  // made to the contents of this object are saved.
  //
  // This method will succeed only if all of the following are true:
  // - This object is currently open.
  // - Sufficient space remains in the storage for the data to be
  //   written.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_OPEN
  //   - This object is not open.
  //
  // AAFRESULT_WRONG_OPENMODE
  //   - This object is not open for writing or modification.
  //
  // AAFRESULT_INSUFFICIENT_SPACE
  //   - There is insufficient space in the storage to save the
  //     contents of this object.
  STDMETHOD(Save) (THIS) PURE;


  //***********************************************************
  //
  // Close()
  //
  // Dissociates this IAAFFile-supporting object from its
  // currently-associated storage.  Any AAF objects which were
  // contained within this object will then no longer be available to
  // the client.
  //
  // If the client is maintaining any references to any objects which
  // are contained in this object, those objects will be marked as
  // dissociated, and methods on them will fail.
  //
  // Any unsaved changes will be written to the file before the Close
  // operation is complete.
  //
  // This method will succeed only if all of the following are true:
  // - This object is currently open.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_OPEN
  //   - This object is not already open.
  STDMETHOD(Close) (THIS) PURE;

  //***********************************************************
  //
  // GetDictionary()
  //
  // Places the dictionary that contains all types of aaf definition
  // objects into the *ppDictionary argument.  The returned dictionary
  // is AddRef()ed before it is returned.  Note that the dictionary
  // is automatically created when the header object is created.
  // 
  // Succeeds if all of the following are true:
  // - the ppDictionary pointer is valid.
  // 
  // If this method fails no state will be changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppDictionary is null.
  //
  STDMETHOD(GetDictionary) (THIS_
    // The AAF Dictionary
    /*[out, retval]*/ IAAFDictionary ** ppDictionary) PURE;


  END_INTERFACE
};
#endif // __IAAFFile_INTERFACE_DEFINED__



// IAAFFileDescriptor

// ************************
//
// Interface IAAFFileDescriptor
//
// ************************



#ifndef __IAAFFileDescriptor_INTERFACE_DEFINED__
#define __IAAFFileDescriptor_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFFileDescriptor;

#undef  INTERFACE
#define INTERFACE   IAAFFileDescriptor

DECLARE_INTERFACE_(IAAFFileDescriptor, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFFileDescriptor methods *** */

  //***********************************************************
  //
  // SetLength()
  //
  // // 
  // Sets the length of the essence in samples [not edit units].
  // 
  // Always succeeds.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  STDMETHOD(SetLength) (THIS_
    // length of the essence in samples
    /*[in]*/ aafLength_t  length) PURE;


  //***********************************************************
  //
  // GetLength()
  //
  // // Gets the length of the essence in samples [not edit units].
  //
  // Succeeds if all of the following are true:
  // - the pLength pointer is valid.
  // 
  // If this method fails nothing will be written to *pLength.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pLength arg is NULL.
  //
  STDMETHOD(GetLength) (THIS_
    // returns length of the essence in samples
    /*[out]*/ aafLength_t *  pLength) PURE;


  //***********************************************************
  //
  // SetCodecDef()
  //
  // // Set to the exact codec which was used as a hint.
  // 
  // Always succeeds.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  STDMETHOD(SetCodecDef) (THIS_
    // Which codec was used
    /*[in]*/ IAAFCodecDef * codecDef) PURE;


  //***********************************************************
  //
  // GetCodecDef()
  //
  // // Get to the exact codec which was used as a hint.
  //
  // Succeeds if all of the following are true:
  // - the pCodecDef pointer is valid.
  // 
  // If this method fails nothing will be written to *pCodecDef.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pCodecDef arg is NULL.
  //
  STDMETHOD(GetCodecDef) (THIS_
    // Which codec was used
    /*[out]*/ IAAFCodecDef ** pCodecDef) PURE;


  //***********************************************************
  //
  // SetSampleRate()
  //
  // Sets sample rate of the essence as opposed to the edit rate.
  // 
  // If this method fails the sample rate property will not be
  // changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  STDMETHOD(SetSampleRate) (THIS_
    // sample rate of the essence
    /*[in]*/ aafRational_constref  rate) PURE;


  //***********************************************************
  //
  // GetSampleRate()
  //
  // Gets sample rate of the essence as opposed to the edit rate. and
  // writes it into the *pRate argument.
  //
  // Succeeds if all of the following are true:
  // - the pRate pointer is valid.
  // 
  // If this method fails nothing will be written to *pRate.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pRate arg is NULL.
  //
  STDMETHOD(GetSampleRate) (THIS_
    // sample rate of the essence
    /*[out]*/ aafRational_t*  pRate) PURE;


  //***********************************************************
  //
  // SetContainerFormat()
  //
  // Identifies the file format.  The container format is an optional
  // property.
  // 
  // If this method fails the container format property will not be
  // changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  STDMETHOD(SetContainerFormat) (THIS_
    // file format
    /*[in]*/ IAAFContainerDef * format) PURE;


  //***********************************************************
  //
  // GetContainerFormat()
  //
  // // Optional. Identifies the file format.
  //
  // Succeeds if all of the following are true:
  // - the pFormat pointer is valid.
  // 
  // If this method fails nothing will be written to *pFormat.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pFormat arg is NULL.
  //
  STDMETHOD(GetContainerFormat) (THIS_
    // Identifies the file format
    /*[out]*/ IAAFContainerDef ** pFormat) PURE;

  END_INTERFACE
};
#endif // __IAAFFileDescriptor_INTERFACE_DEFINED__



// IAAFFilmDescriptor

// ************************
//
// Interface IAAFFilmDescriptor
//
// ************************




#ifndef __IAAFFilmDescriptor_INTERFACE_DEFINED__
#define __IAAFFilmDescriptor_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFFilmDescriptor;

#undef  INTERFACE
#define INTERFACE   IAAFFilmDescriptor

DECLARE_INTERFACE_(IAAFFilmDescriptor, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFFilmDescriptor methods *** */

  //***********************************************************
  //
  // SetFilmManufacturer()
  //
  // Sets the Film Manufacturer string property.
  //
  // Set the FilmManufacturer property to the value specified in
  // pFilmManufacturer.  A copy is made of the data so the caller
  // retains ownership of the *pFilmManufacturer buffer and is
  // responsible for de-allocating it.  There is no pre-set limit to
  // the length of the name, other than available system memory or
  // disk space.
  // 
  // Succeeds if all of the following are true:
  // - the pFilmManufacturer pointer is valid.
  // 
  // If this method fails the FilmManufacturer property will not be
  // changed.
  // 
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pFilmManufacturer arg is NULL.
  //
  STDMETHOD(SetFilmManufacturer) (THIS_
    // buffer from which FilmManufacturer is to be read
    /*[in, string]*/ aafCharacter_constptr  pFilmManufacturer) PURE;


  //***********************************************************
  //
  // GetFilmManufacturer()
  //
  // Gets the Film Manufacturer string property.
  // 
  // Writes the FilmManufacturer property, with a trailing null
  // character, into the pFilmManufacturer buffer.  The
  // buffer is allocated by the caller.  The size of the buffer is
  // given by bufSize.  If the FilmManufacturer property has not yet
  // been set, a zero-length string will be written (that is,
  // only the trailing null character). 
  // 
  // Caller may call GetFilmManufacturerBufLen() to determine the
  // required buffer size.
  // 
  // If this method fails nothing will be written to
  // *pFilmManufacturer.
  // 
  // Succeeds if:
  // - The pFilmManufacturer pointer is valid.
  // - bufSize indicates that the buffer is large enough to hold
  //   FilmManufacturer.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pFilmManufacturer arg is NULL.
  //
  // AAFRESULT_SMALL_BUF
  //   - bufSize indicates that the allocated buffer is not large
  //     enough to hold FilmManufacturer.
  //
  STDMETHOD(GetFilmManufacturer) (THIS_
    // buffer into which FilmManufacturer is to be written
    /*[out, string, size_is(bufSize)]*/ aafCharacter *  pFilmManufacturer,

    // size of *pFilmManufacturer buffer in bytes
    /*[in]*/ aafUInt32  bufSize) PURE;


  //***********************************************************
  //
  // GetFilmManufacturerBufLen()
  //
  // Returns size of buffer (in bytes) required for GetFilmManufacturer().
  // 
  // Succeeds if:
  // - The pBufSize pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pBufSize arg is NULL.
  //
  STDMETHOD(GetFilmManufacturerBufLen) (THIS_
    // size of required buffer, in bytes
    /*[out]*/ aafUInt32 *  pBufSize) PURE;


  //***********************************************************
  //
  // SetFilmModel()
  //
  // Sets the Film Model string property.
  //
  // Set the FilmModel property to the value specified in
  // pFilmModel.  A copy is made of the data so the caller
  // retains ownership of the *pFilmModel buffer and is
  // responsible for de-allocating it.  There is no pre-set limit to
  // the length of the name, other than available system memory or
  // disk space.
  // 
  // Succeeds if all of the following are true:
  // - the pFilmModel pointer is valid.
  // 
  // If this method fails the FilmModel property will not be
  // changed.
  // 
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pFilmModel arg is NULL.
  //
  STDMETHOD(SetFilmModel) (THIS_
    // buffer from which FilmModel is to be read
    /*[in, string]*/ aafCharacter_constptr  pFilmModel) PURE;


  //***********************************************************
  //
  // GetFilmModel()
  //
  // Gets the Film Model string property.
  // 
  // Writes the FilmModel property, with a trailing null
  // character, into the pFilmModel buffer.  The
  // buffer is allocated by the caller.  The size of the buffer is
  // given by bufSize.  If the FilmModel property has not yet
  // been set, a zero-length string will be written (that is,
  // only the trailing null character). 
  // 
  // Caller may call GetFilmModelBufLen() to determine the
  // required buffer size.
  // 
  // If this method fails nothing will be written to
  // *pFilmModel.
  // 
  // Succeeds if:
  // - The pFilmModel pointer is valid.
  // - bufSize indicates that the buffer is large enough to hold
  //   FilmModel.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pFilmModel arg is NULL.
  //
  // AAFRESULT_SMALL_BUF
  //   - bufSize indicates that the allocated buffer is not large
  //     enough to hold FilmModel.
  //
  STDMETHOD(GetFilmModel) (THIS_
    // buffer into which FilmModel is to be written
    /*[out, string, size_is(bufSize)]*/ aafCharacter *  pFilmModel,

    // size of *pFilmModel buffer in bytes
    /*[in]*/ aafUInt32  bufSize) PURE;


  //***********************************************************
  //
  // GetFilmModelBufLen()
  //
  // Returns size of buffer (in bytes) required for GetFilmModel().
  // 
  // Succeeds if:
  // - The pBufSize pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pBufSize arg is NULL.
  //
  STDMETHOD(GetFilmModelBufLen) (THIS_
    // size of required buffer, in bytes
    /*[out]*/ aafUInt32 *  pBufSize) PURE;


  //***********************************************************
  //
  // GetFilmFormat()
  //
  // Gets the film format.
  //
  // Valid values include:
  //  - kFt35MM
  //  - kFt16MM
  //  - kFt8MM
  //  - kFt65MM
  // 
  // This method succeeds if all of the following are true:
  // - the pFilmFormat pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pFilmFormat arg is NULL.
  //
  STDMETHOD(GetFilmFormat) (THIS_
    // pointer to the filmFormat
    /*[out]*/ aafFilmType_t*  pFilmFormat) PURE;


  //***********************************************************
  //
  // GetFrameRate()
  //
  // Get the frame rate of the film.
  // 
  // This method succeeds if all of the following are true:
  // - the pRate pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pRate parameter is NULL.
  //
  STDMETHOD(GetFrameRate) (THIS_
    // Frame Rate
    /*[out]*/ aafUInt32*  pRate) PURE;


  //***********************************************************
  //
  // GetPerfPerFrame()
  //
  // Get the number of perforations per frame.
  // 
  // This method succeeds if all of the following are true:
  // - the pPerfPerFrame pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pPerfPerFrame parameter is NULL.
  //
  STDMETHOD(GetPerfPerFrame) (THIS_
    // Perforations per frame
    /*[out]*/ aafUInt8*  pPerfPerFrame) PURE;


  //***********************************************************
  //
  // GetFilmAspectRatio()
  //
  // Get the image aspect ratio.
  // 
  // This method succeeds if all of the following are true:
  // - the pAspectRatio pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pAspectRatio arg is NULL.
  //
  STDMETHOD(GetFilmAspectRatio) (THIS_
    // Film Aspect Ratio
    /*[out]*/ aafRational_t*  pAspectRatio) PURE;


  //***********************************************************
  //
  // SetFilmFormat()
  //
  // Sets the film format of the film.
  // Valid values include:
  //  - kFt35MM
  //  - kFt16MM
  //  - kFt8MM
  //  - kFt65MM
  // 
  // This method succeeds if all of the following are true:
  // - formFactor represents a valid format.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_BAD_TYPE
  //	- filmFormat is invalid.
  //
  STDMETHOD(SetFilmFormat) (THIS_
    // Film Format
    /*[in]*/ aafFilmType_t  filmFormat) PURE;


  //***********************************************************
  //
  // SetFrameRate()
  //
  // Set the frame rate of the film.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  STDMETHOD(SetFrameRate) (THIS_
    // Frame Rate
    /*[in]*/ aafUInt32  rate) PURE;


  //***********************************************************
  //
  // SetPerfPerFrame()
  //
  // Set the number of perforations per frame.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  STDMETHOD(SetPerfPerFrame) (THIS_
    // Perforations per frame
    /*[in]*/ aafUInt8  perfPerFrame) PURE;


  //***********************************************************
  //
  // SetFilmAspectRatio()
  //
  // Set the image aspect ratio.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  STDMETHOD(SetFilmAspectRatio) (THIS_
    // Film Aspect Ratio
    /*[in]*/ aafRational_t  aspectRatio) PURE;

  END_INTERFACE
};
#endif // __IAAFFilmDescriptor_INTERFACE_DEFINED__



// IAAFDigitalImageDescriptor

// ************************
//
// Interface IAAFDigitalImageDescriptor
//
// ************************



#ifndef __IAAFDigitalImageDescriptor_INTERFACE_DEFINED__
#define __IAAFDigitalImageDescriptor_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFDigitalImageDescriptor;

#undef  INTERFACE
#define INTERFACE   IAAFDigitalImageDescriptor

DECLARE_INTERFACE_(IAAFDigitalImageDescriptor, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFDigitalImageDescriptor methods *** */

  //***********************************************************
  //
  // SetCompression()
  //
  // // Sets the kind of compression and format of compression
  // information of the video essence data.  This property is
  // optional.  If there is no compression, the property is omitted.
  // 
  // If this method fails the Data Definition property will not be
  // changed.
  // 
  // This method will return the following codes:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  STDMETHOD(SetCompression) (THIS_
    // Identifies a Codec definition for the desired compression and
	// format of compression information.
    /*[in]*/ aafUID_constref  codecID) PURE;


  //***********************************************************
  //
  // GetCompression()
  //
  // Gets the kind of compression and format of compression
  // information of the video essence data.  This property is
  // optional.  If there is no compression, the null AUID is
  // returned.
  //
  // Succeeds if all of the following are true:
  // - the pCompression pointer is valid.
  // 
  // If this method fails nothing will be written to *pCompression.
  // 
  // This method will return the following codes:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pComporession arg is NULL.
  //
  STDMETHOD(GetCompression) (THIS_
    // Identifies a Codec definition for the desired compression and
	// format of compression information.
    /*[out]*/ aafUID_t *  pCompression) PURE;


  //***********************************************************
  //
  // SetStoredView()
  //
  // Sets the dimension of the stored view.  Typically this includes
  // leading blank video lines, any VITC lines, as well as the active
  // picture area.
  // 
  // If this method fails the Stored Height and Stored Width
  // properties will not be changed.
  // 
  // This method will return the following codes:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  STDMETHOD(SetStoredView) (THIS_
    // Number of pixels in vertical dimension of stored view.
    /*[in]*/ aafUInt32  StoredHeight,

    // Number of pixels in horizontal dimension of stored view.
    /*[in]*/ aafUInt32  StoredWidth) PURE;


  //***********************************************************
  //
  // GetStoredView()
  //
  // Gets the dimension of the stored view.  Typically this includes
  // leading blank video lines, any VITC lines, as well as the active
  // picture area.
  // 
  // Succeeds if all of the following are true:
  // - pStoredHieght and pStoredWidth are valid pointers.
  // 
  // If this method fails, the *pStoredHieght and *pStoredWidth will
  // not be changed.
  // 
  // This method will return the following codes:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - either pStoredHeight or pStoredWidth is NULL.
  //
  STDMETHOD(GetStoredView) (THIS_
    // Number of pixels in vertical dimension of stored view.
    /*[out]*/ aafUInt32 *  pStoredHeight,

    // Number of pixels in horizontal dimension of stored view.
    /*[out]*/ aafUInt32 *  pStoredWidth) PURE;


  //***********************************************************
  //
  // SetSampledView()
  //
  // Sets the dimensions of sampled view.  Typically this includes
  // any VITC lines as well as the active picture area, but excludes
  // leading blank video lines.  The offset is specified relative to
  // the rectangle specified by Set/GetStoredView().
  //
  // The following properties are optional:
  //
  //     SampledXOffset - The default value is 0.  Use a value of 0 to
  //                      select the default.
  //     SampledYOffset - The default value is 0.  Use a value of 0 to
  //                      select the default.
  //
  // Succeeds if all of the following are true:
  // - The given dimensions exist within the StoredView.
  // 
  // If this method fails, the SampledXOffset and SampledYOffset
  // properties will not be changed.
  // 
  // This method will return the following codes:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_ILLEGAL_VALUE
  //   - The area specified by SampledHeight and SampledXOffset is
  //     outside the StoredView, or the area specified by SampledWidth
  //     and SampledYOffset is outside the StoredView.
  //
  STDMETHOD(SetSampledView) (THIS_
    // Number of pixels in vertical dimension of sampled view.
    /*[in]*/ aafUInt32  SampledHeight,

    // Number of pixels in horizontal dimension of sampled view.
    /*[in]*/ aafUInt32  SampledWidth,

    // Number of pixels from top left corner of sampled view. Optional.
    /*[in]*/ aafInt32  SampledXOffset,

    // Number of pixels from top left corner of sampled view. Optional.
    /*[in]*/ aafInt32  SampledYOffset) PURE;


  //***********************************************************
  //
  // GetSampledView()
  //
  // Gets the dimensions of sampled view.  Typically this includes
  // any VITC lines as well as the active picture area, but excludes
  // leading blank video lines.  The offset is specified relative to
  // the rectangle specified by Set/GetStoredView().
  //
  // Succeeds if all of the following are true:
  // - pSampledHeight, pSampledWidth, pSampledXOffset and
  //   pSampledYOffset are valid pointers
  // 
  // If any of the input parameters are NULL, the property will not
  // be returned.
  //
  // If this method fails, *pSampledHeight, *pSampledWidth,
  // *pSampledXOffset, and *pSampledYOffset will not be changed.
  // 
  // This method will return the following codes:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - any of pSampledHeight, pSampledWidth, pSampledXOffset, or
  //     pSampledYOffset are NULL.
  //
  STDMETHOD(GetSampledView) (THIS_
    // Number of pixels in vertical dimension of sampled view.
    /*[out]*/ aafUInt32 *  pSampledHeight,

    // Number of pixels in horizontal dimension of sampled view.
    /*[out]*/ aafUInt32 *  pSampledWidth,

    // Number of pixels from top left corner of sampled view. Optional.
    /*[out]*/ aafInt32 *  pSampledXOffset,

    // Number of pixels from top left corner of sampled view. Optional.
    /*[out]*/ aafInt32 *  pSampledYOffset) PURE;


  //***********************************************************
  //
  // SetDisplayView()
  //
  // Sets the dimension of display view.  Typically this includes
  // the active picture area, but excludes leading blank video lines
  // and any VITC lines.  The offset is specified relative to the
  // rectangle specified by Set/GetStoredView().
  // 
  // The following properties are optional:
  //
  //     DisplayHeight  - The default value is the storedHeight. Use
  //                      storedHeight to select the default.
  //     DisplayWidth   - The default value is the storedWidth. Use
  //                      storedWidth to select the default.
  //     DisplayXOffset - The default value is 0.  Use a value of 0 to
  //                      select the default.
  //     DisplayYOffset - The default value is 0.  Use a value of 0 to
  //                      select the default.
  //
  // Note that The specified display rectangle may exist outside the
  // SampledView or even the StoredView.
  //
  // If this method fails the DisplayHeight, DisplayWidth, DisplayXOffset and
  // DisplayYOffset properties will not be changed.
  // 
  // This method will return the following codes:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_ILLEGAL_VALUE
  //   - The area specified by DisplayHeight and DisplayXOffset is
  //     outside the StoredView, or the area specified by DisplayWidth
  //     and DisplayYOffset is outside the StoredView.
  //
  STDMETHOD(SetDisplayView) (THIS_
    // Number of pixels in vertical dimension of display view. Optional.
    /*[in]*/ aafUInt32  DisplayHeight,

    // Number of pixels in horizontal dimension of display view. Optional.
    /*[in]*/ aafUInt32  DisplayWidth,

    // Number of pixels from the top-left corner of the display view. Optional.
    /*[in]*/ aafInt32  DisplayXOffset,

    // Number pixels from the top-left corner of the display view. Optional.
    /*[in]*/ aafInt32  DisplayYOffset) PURE;


  //***********************************************************
  //
  // GetDisplayView()
  //
  // Gets the dimension of display view.  Typically this includes
  // the active picture area, but excludes leading blank video lines
  // and any VITC lines.  The offset is specified relative to the
  // rectangle specified by Set/GetStoredView().
  // 
  // Note that The specified display rectangle may exist outside the
  // SampledView or even the StoredView.
  //
  // Succeeds if all of the following are true:
  // - pDisplayHeight, pDisplayWidth, pDisplayXOffset and
  //   pDisplayYOffset are valid pointers.
  // 
  // If this method fails, *pDisplayHeight, *pDisplayWidth,
  // *pDisplayXOffset, and *pDisplayYOffset will not be changed.
  // 
  // This method will return the following codes:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - any of pDisplayHeight, pDisplayWidth, pDisplayXOffset, or
  //     pDisplayYOffset are NULL.
  //
  STDMETHOD(GetDisplayView) (THIS_
    // Number of pixels in vertical dimension of display view. Optional.
    /*[out]*/ aafUInt32 *  pDisplayHeight,

    // Number of pixels in horizontal dimension of display view. Optional.
    /*[out]*/ aafUInt32 *  pDisplayWidth,

    // Number of pixels from the top-left corner of the display view. Optional.
    /*[out]*/ aafInt32 *  pDisplayXOffset,

    // Number pixels from the top-left corner of the display view. Optional.
    /*[out]*/ aafInt32 *  pDisplayYOffset) PURE;


  //***********************************************************
  //
  // SetFrameLayout()
  //
  // Sets the frame layout.  The frame layout describes whether all
  // data for a complete sample is in one frame or is split into more
  // than/ one field.
  //
  // Values are:
  //
  //    kNoLayout       - Default; not a valid value.
  //    kFullFrame      - Each frame contains a full sample in
  //                      progressive scan lines.
  //    kSeparateFields - Each sample consists of two fields, which
  //                      when interlaced produce a full sample.
  //    kOneField       - Each sample consists of two interlaced
  //                      fields, but only one field is stored in the
  //                      data stream.
  //    kMixedFields    - Similar to FullFrame, except the two fields
  //                      may have been sampled at different times.
  // 
  // Succeeds if all of the following are true:
  // - frameLayout is a valid value
  // 
  // If this method fails, the Frame Layout property will not be
  // changed.
  // 
  // This method will return the following codes:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_ILLEGAL_VALUE
  //   - FrameLayout is not a valid value.
  //
  STDMETHOD(SetFrameLayout) (THIS_
    // layout of the frame
    /*[in]*/ aafFrameLayout_t  FrameLayout) PURE;


  //***********************************************************
  //
  // GetFrameLayout()
  //
  // Gets the frame layout.  The frame layout describes whether all
  // data for a complete sample is in one frame or is split into more
  // than one field.
  // 
  // Values are:
  //
  //    kNoLayout       - Default; not a valid value.
  //    kFullFrame      - Each frame contains a full sample in
  //                      progressive scan lines.
  //    kSeparateFields - Each sample consists of two fields, which
  //                      when interlaced produce a full sample.
  //    kOneField       - Each sample consists of two interlaced
  //                      fields, but only one field is stored in the
  //                      data stream.
  //    kMixedFields    - Similar to FullFrame, except the two fields
  //                      may have been sampled at different times.
  // 
  // Succeeds if all of the following are true:
  // - pFrameLayout is a valid pointer
  // 
  // If this method fails, *pFrameLayout will not be changed.
  // 
  // This method will return the following codes:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pFrameLayout is NULL.
  //
  STDMETHOD(GetFrameLayout) (THIS_
    // layout of the frame
    /*[out]*/ aafFrameLayout_t *  pFrameLayout) PURE;


  //***********************************************************
  //
  // SetVideoLineMap()
  //
  // Sets the VideoLineMap property.  The video line map specifies the
  // scan line in the analog source that corresponds to the beginning
  // of each digitized field.  For single-field video, there is 1
  // value in the array.  For interleaved video, there are 2 values
  // in the array.
  // 
  // Succeeds if all of the following are true:
  // - pVideoLineMap is a valid pointer
  // 
  // If this method fails, the Video Line Map property will not be
  // changed.
  // 
  // This method will return the following codes:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pVideoLineMap is NULL.
  //
  STDMETHOD(SetVideoLineMap) (THIS_
    // The number of elements in the array
    /*[in]*/ aafUInt32  numberElements,

    // Array to hold the Video Line Map information
    /*[in, size_is(numberElements)]*/ aafInt32 *  pVideoLineMap) PURE;


  //***********************************************************
  //
  // GetVideoLineMap()
  //
  // Gets the VideoLineMap property.  The video line map specifies the
  // scan line in the analog source that corresponds to the beginning of each
  // digitized field.  For single-field video, there is 1 value in the array.
  // For interleaved video, there are 2 values in the array.
  //
  // The values are written to the array specified by pVideoLineMap,
  // which is of size numberElements.  The required size may be found
  // by calling GetVideoLineMapSize().
  // 
  // Succeeds if all of the following are true:
  // - pVideoLineMap is a valid pointer.
  // - numberElements indicates the array is large enough to hold the
  //   data.
  // 
  // If this method fails, videoLineMap will not be changed.
  // 
  // This method will return the following codes:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pNumberElements is NULL.
  //
  // AAFRESULT_SMALLBUF
  //   - numberElements indicates that the array is too small to hold
  //     the data.
  //
  STDMETHOD(GetVideoLineMap) (THIS_
    // The number of elements in the array
    /*[in]*/ aafUInt32  numberElements,

    // Array to hold the Video Line Map information
    /*[out, size_is(numberElements)]*/ aafInt32 *  pVideoLineMap) PURE;


  //***********************************************************
  //
  // GetVideoLineMapSize()
  //
  // Get the number of elements in the VideoLineMap property array.
  // 
  // Succeeds if all of the following are true:
  // - pNumberElements is a valid pointer
  // 
  // If this method fails, *pNumberElements will not be changed.
  // 
  // This method will return the following codes:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pNumberElements is NULL.
  //
  STDMETHOD(GetVideoLineMapSize) (THIS_
    // The number of elements in the array
    /*[out]*/ aafUInt32 *  pNumberElements) PURE;


  //***********************************************************
  //
  // SetImageAspectRatio()
  //
  // Sets the Image Aspect Ratio property.  This ratio describes the
  // ratio between the horizontal size and the vertical size in the
  // intended final image.
  //
  // Succeeds if all of the following are true:
  // - 
  // 
  // If this method fails, the Image Access Ratio property will not be
  // changed.
  // 
  // This method will return the following codes:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  STDMETHOD(SetImageAspectRatio) (THIS_
    // Ratio between horizontal and vertical size
    /*[in]*/ aafRational_t  ImageAspectRatio) PURE;


  //***********************************************************
  //
  // GetImageAspectRatio()
  //
  // Gets the Image Aspect Ratio property.  This ratio describes the
  // ratio between the horizontal size and the vertical size in the
  // intended final image.
  //
  // Succeeds if all of the following are true:
  // - pImageAspectRatio is a valid pointer
  // 
  // If this method fails, *pImageAspectRatio will not be changed.
  // 
  // This method will return the following codes:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pImageAspectRatio is NULL.
  //
  STDMETHOD(GetImageAspectRatio) (THIS_
    // Ratio between horizontal and vertical size
    /*[out]*/ aafRational_t *  pImageAspectRatio) PURE;


  //***********************************************************
  //
  // SetAlphaTransparency()
  //
  // Sets the AlphaTransparency property.  This property is optional.
  //
  // Valid values:
  //	kMaxValueTransparent - means the maximum Alpha value is
  //                           transparent
  //    kMinValueTransparent - means the minimum Alpha value is
  //                           transparent
  //
  // Succeeds if all of the following are true:
  // - AlphaTransparency is a valid value.
  // 
  // If this method fails, the AlphaTransparency property will not be
  // changed.
  // 
  // This method will return the following codes:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_ILLEGAL_VALUE
  //   - AlphaTransparency is not a valid value.
  //
  STDMETHOD(SetAlphaTransparency) (THIS_
    // Alpha Transparency value.
    /*[in]*/ aafAlphaTransparency_t  AlphaTransparency) PURE;


  //***********************************************************
  //
  // GetAlphaTransparency()
  //
  // Gets the AlphaTransparency property.  This property is optional.
  //
  // Valid values:
  //	kMaxValueTransparent - means the maximum Alpha value is transparent
  //    kMinValueTransparent - means the minimum Alpha value is transparent
  //
  // Succeeds if all of the following are true:
  // - pAlphaTransparency is a valid pointer
  // 
  // If this method fails, pAlphaTransparency not be changed.
  // 
  // This method will return the following codes:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pAlphaTransparency is NULL.
  //
  STDMETHOD(GetAlphaTransparency) (THIS_
    // Alpha Transparency value.
    /*[out]*/ aafAlphaTransparency_t *  pAlphaTransparency) PURE;


  //***********************************************************
  //
  // SetGamma()
  //
  // Sets the Gamma property.  Specifies the expected output gamma
  // setting on the video display device.
  //
  // Succeeds if all of the following are true:
  // - 
  // 
  // If this method fails, the Gamma property will not be
  // changed.
  // 
  // This method will return the following codes:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  STDMETHOD(SetGamma) (THIS_
    // Optional
    /*[in]*/ aafUID_t  Gamma) PURE;


  //***********************************************************
  //
  // GetGamma()
  //
  // Gets the Gamma property.  Specifies the expected output gamma
  // setting on the video display device.
  //
  // Succeeds if all of the following are true:
  // - pGamma is a valid pointer
  // 
  // If this method fails, pGamma will not be changed.
  // 
  // This method will return the following codes:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pGamma is NULL.
  //
  STDMETHOD(GetGamma) (THIS_
    // Optional.
    /*[out]*/ aafUID_t *  pGamma) PURE;


  //***********************************************************
  //
  // SetImageAlignmentFactor()
  //
  // Sets the ImageAlignmentFactor property.  Specifies the alignment
  // when storing the digital essence.  For example, a value of 16
  // means that the image is stored on 16-byte boundaries.  The
  // starting point for a field will always be a multiple of 16 bytes.
  // If the field does not end on a 16-byte boundary, it is padded
  // out to the next 16-byte boundary.
  //
  // Succeeds if all of the following are true:
  // 
  // If this method fails, the ImageAlignmentFactor property will not be
  // changed.
  // 
  // This method will return the following codes:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  STDMETHOD(SetImageAlignmentFactor) (THIS_
    // Optional.
    /*[in]*/ aafUInt32  ImageAlignmentFactor) PURE;


  //***********************************************************
  //
  // GetImageAlignmentFactor()
  //
  // Gets the ImageAlignmentFactor property.  Specifies the alignment when
  // storing the digital essence.  For example, a value of 16 means that the image
  // is stored on 16-byte boundaries.  The starting point for a field will always
  // be a multiple of 16 bytes.  If the field does not end on a 16-byte boundary,
  // it is padded out to the next 16-byte boundary.
  //
  //
  // Succeeds if all of the following are true:
  // - pImageAlignmentFactor is a valid pointer
  // 
  // If this method fails, pImageAlignmentFactor will not be changed.
  // 
  // This method will return the following codes:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pImageAlignmentFactor is NULL.
  //
  STDMETHOD(GetImageAlignmentFactor) (THIS_
    // Optional.
    /*[out]*/ aafUInt32 *  pImageAlignmentFactor) PURE;

  END_INTERFACE
};
#endif // __IAAFDigitalImageDescriptor_INTERFACE_DEFINED__



// IAAFCDCIDescriptor

// ************************
//
// Interface IAAFCDCIDescriptor
//
// ************************



#ifndef __IAAFCDCIDescriptor_INTERFACE_DEFINED__
#define __IAAFCDCIDescriptor_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFCDCIDescriptor;

#undef  INTERFACE
#define INTERFACE   IAAFCDCIDescriptor

DECLARE_INTERFACE_(IAAFCDCIDescriptor, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFCDCIDescriptor methods *** */

  //***********************************************************
  //
  // Initialize()
  //
  // Initializes a newly allocated, empty
  // IAAFCDCIDescriptor-supporting object.  This method must be called
  // after allocation, and before any other method can be called.
  //
  // Succeeds if:
  // - Initialize() has not yet been called on this object.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_ALREADY_INITIALIZED
  //   - Initialize() has already been called on this object.
  STDMETHOD(Initialize) (THIS) PURE;


  //***********************************************************
  //
  // SetComponentWidth()
  //
  // Sets the ComponentWidth property.  Specifies the number of bits
  // used to store each component.  Typical values can be 8, 10,
  // 12, 14, or 16, but others are permitted by the reference
  // implementation.  Each component in a sample is packed
  // contiguously; the sample is filled with the number of bits
  // specified by the optional PaddingBits property.  If  the
  // PaddingBits property is omitted, samples are packed
  // contiguously.
  //
  // If this method fails, the ComponentWidth property will not be
  // changed.
  // 
  // This method will return the following codes:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  STDMETHOD(SetComponentWidth) (THIS_
    // Number of bits.
    /*[in]*/ aafInt32  ComponentWidth) PURE;


  //***********************************************************
  //
  // GetComponentWidth()
  //
  // Gets the ComponentWidth property.  Specifies the number of bits
  // used to store each component.  Typical values can be 8, 10,
  // 12, 14, or 16, but others are permitted by the reference
  // implementation.  Each component in a sample is packed
  // contiguously; the sample is filled with the number of bits
  // specified by the optional PaddingBits property.  If the
  // PaddingBits property is omitted, samples are packed
  // contiguously.
  //
  // Succeeds if all of the following are true:
  // - pComponentWidth is a valid pointer.
  // 
  // If this method fails, *pComponentWidth will not be changed.
  // 
  // This method will return the following codes:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pComponentWidth arg is NULL.
  //
  STDMETHOD(GetComponentWidth) (THIS_
    // Address to store the number of bits.
    /*[out]*/ aafInt32 *  pComponentWidth) PURE;


  //***********************************************************
  //
  // SetHorizontalSubsampling()
  //
  // Sets the HorizontalSubsampling property.  Specifies the ratio of
  // luminance sampling to chrominance sampling in the horizontal direction.
  // For 4:2:2 video, the value is 2, which means that there are twice as
  // many luminance values as there are color-difference values.
  // Another typical value is 1; however other values are permitted by
  // the reference implementation.
  //
  // If this method fails, the HorizontalSubsampling property will
  // not be changed.
  // 
  // This method will return the following codes:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  STDMETHOD(SetHorizontalSubsampling) (THIS_
    // Integer value.
    /*[in]*/ aafUInt32  HorizontalSubsampling) PURE;


  //***********************************************************
  //
  // GetHorizontalSubsampling()
  //
  // Gets the HorizontalSubsampling property.  Specifies the ratio of
  // luminance sampling to chrominance sampling in the horizontal
  // direction.  For 4:2:2 video, the value is 2, which means that
  // there are twice as many luminance values as there are
  // color-difference values.  Another typical value is 1; however
  // other values are permitted by the reference implementation.
  //
  // Succeeds if all of the following are true:
  // - pHorizontalSubsampling is a valid pointer.
  // 
  // If this method fails, *pHorizontalSubsampling will not be
  // changed.
  // 
  // This method will return the following codes:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pHorizontalSubsampling arg is NULL.
  //
  STDMETHOD(GetHorizontalSubsampling) (THIS_
    // Address to store the integer value.
    /*[out]*/ aafUInt32 *  pHorizontalSubsampling) PURE;


  //***********************************************************
  //
  // SetVerticalSubsampling()
  //
  // Sets the VerticalSubsampling property.  Specifies the ratio of
  // luminance sampling to chrominance sampling in the vertical direction.
  // For 4:2:2 video, the value is 2, which means that there are twice as
  // many luminance values as there are color-difference values.
  // Another typical value is 1; however other values are permitted by
  // the reference implementation.
  //
  // If this method fails, the VerticalSubsampling property will
  // not be changed.
  // 
  // This method will return the following codes:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  STDMETHOD(SetVerticalSubsampling) (THIS_
    // Integer value.
    /*[in]*/ aafUInt32  VerticalSubsampling) PURE;


  //***********************************************************
  //
  // GetVerticalSubsampling()
  //
  // Gets the VerticalSubsampling property.  Specifies the ratio of
  // luminance sampling to chrominance sampling in the vertical
  // direction.  For 4:2:2 video, the value is 2, which means that
  // there are twice as many luminance values as there are
  // color-difference values.  Another typical value is 1; however
  // other values are permitted by the reference implementation.
  //
  // Succeeds if all of the following are true:
  // - pVerticalSubsampling is a valid pointer.
  // 
  // If this method fails, *pVerticalSubsampling will not be
  // changed.
  // 
  // This method will return the following codes:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pVerticalSubsampling arg is NULL.
  //
  STDMETHOD(GetVerticalSubsampling) (THIS_
    // Address to store the integer value.
    /*[out]*/ aafUInt32 *  pVerticalSubsampling) PURE;


  //***********************************************************
  //
  // SetColorSiting()
  //
  // Sets the ColorSiting property.  Specifies how to compute subsampled
  // chrominance values.
  //
  // Valid values are:
  //
  //     kCoSiting  - To calculate subsampled pixels, take the preceding's pixels
  //                  color value, discard the other color values and cosite the
  //                  color with the first luminance value.
  //
  //     kAveraging - To calculate subsampled pixels, take the average of the two
  //                  adjacent pixels' color values and site the color in the center
  //                  of the luminance pixels.
  //
  //     kThreeTap  - To calculate subsampled pixels, take 25 percent of the the previous
  //                  pixel's color value, 50 percent of the first value and 25 percent
  //                  of the second value.  For the first value in a row, use 75 percent
  //                  of that value since there is no previous value.  The kThreeTap value
  //                  is only meaningful when the HorizontalSubsampling propert has a value
  //                  of 2.
  //
  // This property is optional.  The default value is kCoSiting.
  //
  // Succeeds if all of the following are true:
  // - ColorSiting is valid
  //
  // If this method fails, the ColorSiting property will not be
  // changed.
  // 
  // This method will return the following codes:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  STDMETHOD(SetColorSiting) (THIS_
    // Color siting value.
    /*[in]*/ aafColorSiting_t  ColorSiting) PURE;


  //***********************************************************
  //
  // GetColorSiting()
  //
  // Gets the ColorSiting property.  Specifies how to compute
  // subsampled chrominance values.
  //
  // Valid values are:
  //
  //     kCoSiting  - To calculate subsampled pixels, take the
  //                  preceding's pixels color value, discard the
  //                  other color values and cosite the color with the
  //                  first luminance value.
  //
  //     kAveraging - To calculate subsampled pixels, take the
  //                  average of the two adjacent pixels' color values
  //                  and site the color in the center of the
  //                  luminance pixels.
  //
  //     kThreeTap  - To calculate subsampled pixels, take 25 percent
  //                  of the the previous pixel's color value, 50
  //                  percent of the first value and 25 percent of the
  //                  second value.  For the first value in a row,
  //                  use 75 percent of that value since there is no
  //                  previous value.  The kThreeTap value is only
  //                  meaningful when the HorizontalSubsampling
  //                  propert has a value of 2.
  //
  // Succeeds if all of the following are true:
  // - pColorSiting is a valid pointer.
  //
  // If this method fails, *pColorSiting will not be changed.
  // 
  // This method will return the following codes:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pColorSiting arg is NULL.
  //
  STDMETHOD(GetColorSiting) (THIS_
    // Address to store the color siting value.
    /*[out]*/ aafColorSiting_t *  pColorSiting) PURE;


  //***********************************************************
  //
  // SetBlackReferenceLevel()
  //
  // Sets the BlackReferenceLevel property.  Specifies the digital luminance
  // component component value associated with black.
  //
  // For CCIR-601/2, the value is 16 for 8-bit video and 64 for
  // 10-bit video.  For YUV, the value is 0.  These are typical
  // values; other values will not be disallowed by the reference
  // implementation.
  //
  // The same value is used in CDCI and RGBA when standard colorspace
  // conversion is used.
  //
  // This property is optional.  The default value is 0.
  //
  // If this method fails, the BlackReferenceLevel property will not
  // be changed.
  // 
  // This method will return the following codes:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  STDMETHOD(SetBlackReferenceLevel) (THIS_
    // Integer value.
    /*[in]*/ aafUInt32  BlackReferenceLevel) PURE;


  //***********************************************************
  //
  // GetBlackReferenceLevel()
  //
  // Gets the BlackReferenceLevel property.  Specifies the digital
  // luminance component value associated with black.
  //
  // For CCIR-601/2, the value is 16 for 8-bit video and 64 for
  // 10-bit video.  For YUV, the value is 0.  These are typical
  // values; other values will not be disallowed by the reference
  // implementation.
  //
  // The same value is used in CDCI and RGBA when standard colorspace
  // conversion is used.
  //
  // Succeeds if all of the following are true:
  // - pBlackReferenceLevel is a valid pointer.
  // 
  // If this method fails, *pBlackReferenceLevel will not be changed.
  // 
  // This method will return the following codes:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pBlackReferenceLevel arg is NULL.
  //
  STDMETHOD(GetBlackReferenceLevel) (THIS_
    // Address to store the integer value.
    /*[out]*/ aafUInt32 *  pBlackReferenceLevel) PURE;


  //***********************************************************
  //
  // SetWhiteReferenceLevel()
  //
  // Sets the WhiteReferenceLevel property.  Specifies the digital
  // luminance component component value associated with white.
  //
  // For CCIR-601/2, the value is 235 for 8-bit video and 940 for
  // 10-bit video.  For YUV, the value is 255 for 8-bit video and
  // 1023 for 10-bit video.  These are typical values; other values
  // will not be disallowed by the reference implementation.
  //
  // This property is optional.  The default value is the maximum
  // unsigned interger value for component size.
  //
  // If this method fails, the WhiteReferenceLevel property will not
  // be changed.
  // 
  // This method will return the following codes:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  STDMETHOD(SetWhiteReferenceLevel) (THIS_
    // Integer value.
    /*[in]*/ aafUInt32  WhiteReferenceLevel) PURE;


  //***********************************************************
  //
  // GetWhiteReferenceLevel()
  //
  // Gets the WhiteReferenceLevel property.  Specifies the digital
  // luminance component component value associated with white.
  //
  // For CCIR-601/2, the value is 235 for 8-bit video and 940 for
  // 10-bit video.  For YUV, the value is 255 for 8-bit video and
  // 1023 for 10-bit video.  These are typical values; other values
  // will not be disallowed by the reference implementation.
  //
  // Succeeds if all of the following are true:
  // - pWhiteReferenceLevel is a valid pointer.
  // 
  // If this method fails, *pWhiteReferenceLevel will not be changed.
  // 
  // This method will return the following codes:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pWhiteReferenceLevel arg is NULL.
  //
  STDMETHOD(GetWhiteReferenceLevel) (THIS_
    // Address to store the integer value.
    /*[out]*/ aafUInt32 *  pWhiteReferenceLevel) PURE;


  //***********************************************************
  //
  // SetColorRange()
  //
  // Sets the ColorRange property.  Specifies the range of allowable
  // digital chrominance component values.  Chrominance values are
  // unsigned and the range is centered on 128 for 8-bit video and 512
  // for 10-bit video.  This value is used for both chrominance
  // components.
  //
  // For CCIR-601/2, the range is 225 for 8-bit video and 897 for
  // 10-bit video.  For YUV, the range is 255 for 8-bit video and
  // 1023 for 10-bit video.  These are typical values; other values will
  // not be disallowed by the reference implementation.
  //
  // This property is optional.  The default value is the maximum
  // unsigned integer value for component size.
  //
  // Succeeds if all of the following are true:
  // 
  // If this method fails, the ColorRange property will not be
  // changed.
  // 
  // This method will return the following codes:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  STDMETHOD(SetColorRange) (THIS_
    // Integer value.
    /*[in]*/ aafUInt32  ColorRange) PURE;


  //***********************************************************
  //
  // GetColorRange()
  //
  // Gets the ColorRange property.  Specifies the range of allowable
  // digital chrominance component values.  Chrominance values are
  // unsigned and the range is centered on 128 for 8-bit video and 512
  // for 10-bit video.  This value is used for both chrominance
  // components.
  //
  // For CCIR-601/2, the range is 225 for 8-bit video and 897 for
  // 10-bit video.  For YUV, the range is 255 for 8-bit video and
  // 1023 for 10-bit video.  These are typical values; other values will
  // not be disallowed by the reference implementation.
  //
  // Succeeds if all of the following are true:
  // - pColorRange is a valid pointer.
  // 
  // If this method fails, *pColorRange will not be changed.
  // 
  // This method will return the following codes:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pColorRange arg is NULL.
  //
  STDMETHOD(GetColorRange) (THIS_
    // Address to store the integer value.
    /*[out]*/ aafUInt32 *  pColorRange) PURE;


  //***********************************************************
  //
  // SetPaddingBits()
  //
  // Sets the PaddingBits property.  Specifies the number of bits
  // padded to each pixel.
  //
  // This property is optional.  The default value is 0.
  //
  // If this method fails, the PaddingBits property will not be
  // changed.
  // 
  // This method will return the following codes:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  STDMETHOD(SetPaddingBits) (THIS_
    // Number of bits.
    /*[in]*/ aafInt16  PaddingBits) PURE;


  //***********************************************************
  //
  // GetPaddingBits()
  //
  // Gets the PaddingBits property.  Specifies the number of bits
  // padded to each pixel.
  //
  //
  // Succeeds if all of the following are true:
  // - pPaddingBits is a valid pointer.
  // 
  // If this method fails, pPaddingBits will not be changed.
  // 
  // This method will return the following codes:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pPaddingBits arg is NULL.
  //
  STDMETHOD(GetPaddingBits) (THIS_
    // Address to store the number of bits.
    /*[out]*/ aafInt16 *  pPaddingBits) PURE;

  END_INTERFACE
};
#endif // __IAAFCDCIDescriptor_INTERFACE_DEFINED__



// IAAFEssenceFormat

// ************************
//
// Interface IAAFEssenceFormat
//
// ************************



#ifndef __IAAFEssenceFormat_INTERFACE_DEFINED__
#define __IAAFEssenceFormat_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFEssenceFormat;

#undef  INTERFACE
#define INTERFACE   IAAFEssenceFormat

DECLARE_INTERFACE_(IAAFEssenceFormat, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFEssenceFormat methods *** */

  //***********************************************************
  //
  // AddFormatSpecifier()
  //
  // Appends a format specifier to the AAFEssenceFormat.  If an
  // essenceFormatCode has already been added, then this call
  // replaces the value, otherwise the value is appended.
  //
  // The value data is passed in as a void * through the "value"
  // argument.  The size of the value must be passed through the
  // valueSize argument.
  //
  STDMETHOD(AddFormatSpecifier) (THIS_
    // From aaddefuids.h
    /*[in]*/ aafUID_constref  essenceFormatCode,

    // Size of preallocated buffer
    /*[in]*/ aafInt32  valueSize,

    // Value data
    /*[in, size_is(valueSize)]*/ aafDataBuffer_t  value) PURE;


  //***********************************************************
  //
  // GetFormatSpecifier()
  //
  // The data value is returned in a preallocated buffer of size
  // valueSize.
  //
  // The actual number of bytes read is returned in bytesRead.  If the
  // buffer is not big enough to return the entire  value, an error
  // is returned.
  //
  STDMETHOD(GetFormatSpecifier) (THIS_
    // From aaddefuids.h
    /*[in]*/ aafUID_constref  essenceFormatCode,

    // Size of preallocated buffer
    /*[in]*/ aafInt32  valueSize,

    // Preallocated buffer to hold value
    /*[out, size_is(valueSize),length_is(*bytesRead)]*/ aafDataBuffer_t  value,

    // Number of actual bytes read
    /*[out]*/ aafInt32*  bytesRead) PURE;


  //***********************************************************
  //
  // NumFormatSpecifiers()
  //
  // The data value is returned in a preallocated buffer of size
  // valueSize.
  //
  STDMETHOD(NumFormatSpecifiers) (THIS_
    // The number of specifiers present.
    /*[out]*/ aafInt32*  numSpecifiers) PURE;


  //***********************************************************
  //
  // GetIndexedFormatSpecifier()
  //
  // The data value is returned in a preallocated buffer of size
  // valueSize.
  //
  STDMETHOD(GetIndexedFormatSpecifier) (THIS_
    // 0-based index
    /*[in]*/ aafInt32  index,

    // From aaddefuids.h
    /*[out]*/ aafUID_t*  essenceFormatCode,

    // Size of preallocated buffer
    /*[in]*/ aafInt32  valueSize,

    // Preallocated buffer to hold value
    /*[out, size_is(valueSize),length_is(*bytesRead)]*/ aafDataBuffer_t  value,

    // Number of actual bytes read
    /*[out]*/ aafInt32*  bytesRead) PURE;

  END_INTERFACE
};
#endif // __IAAFEssenceFormat_INTERFACE_DEFINED__



// IAAFEssenceGroup

// ************************
//
// Interface IAAFEssenceGroup
//
// ************************





#ifndef __IAAFEssenceGroup_INTERFACE_DEFINED__
#define __IAAFEssenceGroup_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFEssenceGroup;

#undef  INTERFACE
#define INTERFACE   IAAFEssenceGroup

DECLARE_INTERFACE_(IAAFEssenceGroup, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFEssenceGroup methods *** */

  //***********************************************************
  //
  // SetStillFrame()
  //
  // This method sets the still frame property on a essence group to
  // be the source clip passed as the stillFrame argument.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pStillFrame is null.
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  STDMETHOD(SetStillFrame) (THIS_
    // Still Frame source clip 
    /*[in]*/ IAAFSourceClip * pStillFrame) PURE;
    

  //***********************************************************
  //
  // GetStillFrame()
  //
  // Gets the still frame property on a essence group.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppStillFrame is null.
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  STDMETHOD(GetStillFrame) (THIS_
    // Still Frame source clip 
    /*[out]*/ IAAFSourceClip ** ppStillFrame) PURE;


  //***********************************************************
  //
  // AppendChoice()
  //
  // Append another choice to this AAFEssenceGroup.
  // 
  // Succeeds if all of the following are true:
  // - the pChoice pointer is valid.
  // 
  // If this method fails no state will be changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pChoice is null.
  //
  STDMETHOD(AppendChoice) (THIS_
    // Source clip to add as a choice 
    /*[in]*/ IAAFSegment * pChoice) PURE;


  //***********************************************************
  //
  // PrependChoice()
  //
  // Prepend another choice to this AAFEssenceGroup.
  // 
  // Succeeds if all of the following are true:
  // - the pChoice pointer is valid.
  // 
  // If this method fails no state will be changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pChoice is null.
  //
  STDMETHOD(PrependChoice) (THIS_
    // Source clip to add as a choice
    /*[in]*/ IAAFSegment * pChoice) PURE;


  //***********************************************************
  //
  // InsertChoiceAt()
  //
  // Insert another choice to this AAFEssenceGroup at the given
  // index.  Choices already existing at the given and higher indices
  // will be moved up by one index to accommodate.
  // 
  // Succeeds if all of the following are true:
  // - the pChoice pointer is valid.
  // - index is less than or equal to the value returned by
  //   CountChoices().
  // 
  // If this method fails no state will be changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pChoice is null.
  //
  // AAFRESULT_BADINDEX
  //   - index is greater than the value returned by
  //     CountChoices().
  //
  STDMETHOD(InsertChoiceAt) (THIS_
    // place to insert new choice
    /*[in]*/ aafUInt32  index,

    // Source clip to add as a choice
    /*[in]*/ IAAFSegment * pChoice) PURE;


  //***********************************************************
  //
  // CountChoices()
  //
  // Returns the number of choices attached to this AAFEssenceGroup.,
  // excepting the still frame.
  // 
  // Succeeds if all of the following are true:
  // - the pCount pointer is valid.
  // 
  // If this method fails nothing is written to *pCount.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pCount is null.
  //
  STDMETHOD(CountChoices) (THIS_
    // The number of representations contained within.
    /*[out]*/ aafUInt32*   pCount) PURE;


  //***********************************************************
  //
  // GetChoiceAt()
  //
  // Given an index, returns the corresponding source clip choice.
  // 
  // Succeeds if all of the following are true:
  // - the ppChoice pointer is valid.
  // 
  // If this method fails nothing will be written to *ppChoice.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_MISSING_INDEX
  //   - The given index value is not present.
  //
  // AAFRESULT_NULL_PARAM
  //   - ppChoice arg is NULL.
  //
  STDMETHOD(GetChoiceAt) (THIS_
    // The 0-based index into the array
    /*[in]*/ aafUInt32  index,

    // The representation at that index
    /*[out]*/ IAAFSegment  ** ppChoice) PURE;


  //***********************************************************
  //
  // RemoveChoiceAt()
  //
  // Removes the choice at the given index.  Items already existing at
  // higher indices will be moved down by one index to accommodate.
  // 
  // Succeeds if all of the following are true:
  // - the ppChoice pointer is valid.
  // - index is less than the value returned by CountChoices().
  // 
  // If this method fails no state will be changed.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppChoice arg is NULL.
  //
  // AAFRESULT_BADINDEX
  //   - index is greater than or equal to the value returned by
  //     CountChoices().
  //
  STDMETHOD(RemoveChoiceAt) (THIS_
    // The 0-based index into the array
    /*[in]*/ aafUInt32  index) PURE;

  END_INTERFACE
};
#endif // __IAAFEssenceGroup_INTERFACE_DEFINED__



// IAAFFiller

// ************************
//
// Interface IAAFFiller
//
// ************************




#ifndef __IAAFFiller_INTERFACE_DEFINED__
#define __IAAFFiller_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFFiller;


#undef  INTERFACE
#define INTERFACE   IAAFFiller

DECLARE_INTERFACE_(IAAFFiller, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFFiller methods *** */

  //***********************************************************
  //
  // Initialize()
  //
  // This function will create a new filler object with the given
  // property values.  Length is specified in units of the edit rate
  // of the containing timeline mob slot.
  // 
  // Succeeds if all of the following are true:
  // - this object has not yet been initialized.
  // - the length is valid.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_ALREADY_INITIALIZED
  //   - Initialize() has already been called on this object.
  //
  // AAFRESULT_NULL_PARAM
  //   - pDataDef is null.
  //
  // AAFRESULT_BAD_LENGTH
  //   - length is negative.
  //
  STDMETHOD(Initialize) (THIS_
    // Data Definition Object
    /*[in]*/ IAAFDataDef * pDataDef,

    // Length Property Value
    /*[in]*/ aafLength_t  length) PURE;

  END_INTERFACE
};
#endif // __IAAFFiller_INTERFACE_DEFINED__



// IAAFFindSourceInfo

// ************************
//
// Interface IAAFFindSourceInfo
//
// ************************

 
/***********************************************\
*	Stub only.   Implementation not yet added	*
\***********************************************/






#ifndef __IAAFFindSourceInfo_INTERFACE_DEFINED__
#define __IAAFFindSourceInfo_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFFindSourceInfo;

#undef  INTERFACE
#define INTERFACE   IAAFFindSourceInfo

DECLARE_INTERFACE_(IAAFFindSourceInfo, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFFindSourceInfo methods *** */


  //***********************************************************
  //
  // GetMob()
  //
  // // This function returns the mob found by the function
  // which generated this IAAFFindSourceInfo as a result.
  //
  // Succeeds if all of the following are true:
  // - the ppMob pointer is valid.
  // 
  // If this method fails nothing will be written to *ppMob.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULLOBJECT
  //   - There is no valid mob referenced
  //
  // AAFRESULT_NULL_PARAM
  //   - ppMob arg is NULL.
  //
  STDMETHOD(GetMob) (THIS_
    // The final media object referenced
    /*[out]*/ IAAFMob ** ppMob) PURE;

  //***********************************************************
  //
  // GetSourceReference()
  //
  // // This function returns the source reference found by the function
  // which generated this IAAFFindSourceInfo as a result.
  //
  // Note: the 3 properties that make up the "source
  // reference" are sourceID, sourceTrackID, and startTime.
  //
  // Succeeds if all of the following are true:
  // - This object has already been Initialize()d.
  // - the pSourceRef pointer is valid.
  // 
  // If this method fails nothing will be written to *pSourceRef.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pSourceRef arg is NULL.
  //
  STDMETHOD(GetSourceReference) (THIS_
    // Source Reference
    /*[out]*/ aafSourceRef_t *  pSourceRef) PURE;

  //***********************************************************
  //
  // GetLength()
  //
  // Gets the  of this component.
  // This function returns the duration in edit units of the result.
  //	
  // Succeeds if all of the following are true:
  // - the pLength pointer is valid.
  // - the optional length property is present for this object.
  //
  // This method deals with an optional property, which will only be
  // present for time-varying media.
  // 
  // If this method fails nothing will be written to *pLength.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pLength arg is NULL.
  //
  // AAFRESULT_BAD_PROP
  //   - the optional length property is not present for this object.
  //
  STDMETHOD(GetLength) (THIS_
    // Length of this component
    /*[retval][out]*/ aafLength_t *  pLength) PURE;

  //***********************************************************
  //
  // GetEditRate()
  //
  // This method will get the edit rate for this result.
  // 
  // Succeeds if all of the following are true:
  // - the pEditRate pointer is valid.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pEditRate arg is NULL.
  //
  STDMETHOD(GetEditRate) (THIS_
    // Edit rate property value
    /*[out,retval]*/ aafRational_t *  pEditRate) PURE;


  END_INTERFACE
};
#endif // __IAAFFindSourceInfo_INTERFACE_DEFINED__



// IAAFOperationGroup

// ************************
//
// Interface IAAFOperationGroup
//
// ************************












#ifndef __IAAFOperationGroup_INTERFACE_DEFINED__
#define __IAAFOperationGroup_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFOperationGroup;

#undef  INTERFACE
#define INTERFACE   IAAFOperationGroup

DECLARE_INTERFACE_(IAAFOperationGroup, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFOperationGroup methods *** */

  //***********************************************************
  //
  // Initialize()
  //
  // Initializes an operation group object with the given property
  // values.
  //
  // This function takes an already created operation definition
  // object as an argument.  To add slots to the operation group, call
  // AddNewSlot.  To add renderings, call SetRender.
  //
  STDMETHOD(Initialize) (THIS_
    // Data Definition Object
    /*[in]*/ IAAFDataDef * pDataDef,

    // Length property value
    /*[in]*/ aafLength_t  length,

    // Operation Definition object
    /*[in]*/ IAAFOperationDef * operationDef) PURE;


  //***********************************************************
  //
  // GetOperationDefinition()
  //
  // Returns the operation definition for this invocation.
  // 
  // Succeeds if all of the following are true:
  // - the ppOperationDef pointer is valid.
  // 
  // If this method fails nothing will be written to *ppOperationDef.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  //
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_PROP_NOT_PRESENT
  //   - This property does not exist in the file.
  //
  // AAFRESULT_NULL_PARAM
  //   - ppOperationDef arg is NULL.
  //
  STDMETHOD(GetOperationDefinition) (THIS_
    // Operation definition object
    /*[out]*/ IAAFOperationDef ** ppOperationDef) PURE;

  //***********************************************************
  //
  // SetOperationDefinition()
  //
  // This function sets the operation definition for the given operation
  // group.
  // 
  // Succeeds if all of the following are true:
  // - the pOperationDef pointer is valid.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pOperationDef arg is NULL.
  //
  STDMETHOD(SetOperationDefinition) (THIS_
    // Operation definition object
    /*[in]*/ IAAFOperationDef * pOperationDef) PURE;

  //***********************************************************
  //
  // GetRender()
  //
  // Returns the segment that represents the optional rendering on an
  // operation group object.  Working and final renderings are handled
  // by using an IAAFEssenceGroup as the segment. 
  // 
  // Succeeds if all of the following are true:
  // - the ppSourceRef pointer is valid.
  // 
  // If this method fails nothing will be written to *ppSourceRef.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  //
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_PROP_NOT_PRESENT
  //   - This property does not exist in the file.
  //
  // AAFRESULT_NULL_PARAM
  //   - ppSourceRef arg is NULL.
  //
  STDMETHOD(GetRender) (THIS_
    // Final rendering segment
    /*[out]*/ IAAFSourceReference ** ppSourceRef) PURE;


  //***********************************************************
  //
  // IsATimeWarp()
  //
  // This boolean function returns whether or not an operation group
  // is a timewarp effect.
  // 
  // Succeeds if all of the following are true:
  // - the pIsTimeWarp pointer is valid.
  // 
  // If this method fails nothing will be written to *pIsTimeWarp.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pIsTimeWarp arg is NULL.
  //
  STDMETHOD(IsATimeWarp) (THIS_
    // Returned boolean value
    /*[out, retval]*/ aafBoolean_t *  pIsTimeWarp) PURE;


  //***********************************************************
  //
  // GetBypassOverride()
  //
  // Returns the optional bypass override propertyvalue from the input
  // operation def object.
  // 
  // Succeeds if all of the following are true:
  // - the pBypassOverride pointer is valid.
  // 
  // If this method fails nothing will be written to *pBypassOverride.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_PROP_NOT_PRESENT
  //   - This property does not exist in the file.
  //
  // AAFRESULT_NULL_PARAM
  //   - pBypassOverride arg is NULL.
  //
  STDMETHOD(GetBypassOverride) (THIS_
    // Bypass override property value
    /*[out]*/ aafUInt32 *  pBypassOverride) PURE;


  //***********************************************************
  //
  // CountSourceSegments()
  //
  // Returns the number of media sources to the operation group.
  //
  // Succeeds if all of the following are true:
  // - the pResult pointer is valid.
  // 
  // If this method fails nothing will be written to *pResult.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pResult arg is NULL.
  //
  STDMETHOD(CountSourceSegments) (THIS_
    // Number of source media segments in the operation group
    /*[out]*/ aafUInt32 *  pResult) PURE;


  //***********************************************************
  //
  // IsValidTranOperation()
  //
  // Verifies that the input operation group object can be used in a
  // transition.
  // 
  // Succeeds if all of the following are true:
  // - the pValidTransition pointer is valid.
  // 
  // If this method fails nothing will be written to *pValidTransition.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pValidTransition arg is NULL.
  //
  STDMETHOD(IsValidTranOperation) (THIS_
    // TRUE if the operation group is valid in a transition
    /*[out]*/ aafBoolean_t *  pValidTransition) PURE;


  //***********************************************************
  //
  // CountParameters()
  //
  // Returns the number of parameters in the operation group.
  //
  // Succeeds if all of the following are true:
  // - the pResult pointer is valid.
  // 
  // If this method fails nothing will be written to *pResult.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pResult arg is NULL.
  //
  STDMETHOD(CountParameters) (THIS_
    // Number of parameter slots in the operation group
    /*[out]*/ aafUInt32 *  pResult) PURE;


  //***********************************************************
  //
  // AddParameter()
  //
  // Adds a new parameter object.
  //
  // Succeeds if all of the following are true:
  // - the pValue pointer is valid.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_DUPLICATE_PARAMETER
  //   - The given argID is already present.
  //
  // AAFRESULT_NULL_PARAM
  //   - pValue arg is NULL.
  //
  STDMETHOD(AddParameter) (THIS_
    // Parameter to place in operation group slot
    /*[in]*/ IAAFParameter * pParameter) PURE;


  //***********************************************************
  //
  // AppendInputSegment()
  //
  // Appends another input segment to an operation group.
  // 
  // Succeeds if all of the following are true:
  // - the pSegment pointer is valid.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_DUPLICATE_INDEX
  //   - The given index value is already present.
  //
  // AAFRESULT_NULL_PARAM
  //   - pSegment arg is NULL.
  //
  STDMETHOD(AppendInputSegment) (THIS_
    // Segment to place in operation group
    /*[in]*/ IAAFSegment * pSegment) PURE;


  //***********************************************************
  //
  // PrependInputSegment()
  //
  // Prepends another input segment to an operation group.
  // 
  // Succeeds if all of the following are true:
  // - the pSegment pointer is valid.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_DUPLICATE_INDEX
  //   - The given index value is already present.
  //
  // AAFRESULT_NULL_PARAM
  //   - pSegment arg is NULL.
  //
  STDMETHOD(PrependInputSegment) (THIS_
    // Segment to place in operation group
    /*[in]*/ IAAFSegment * pSegment) PURE;


  //***********************************************************
  //
  // InsertInputSegmentAt()
  //
  // Inserts an input segment to an operation group at the given
  // index.  The existing segments at the given and higher indices are
  // moved up by one to make room.
  // 
  // Succeeds if all of the following are true:
  // - the pSegment pointer is valid.
  // - the index is not greater than the value returned by
  //   CountInputSegments().
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_DUPLICATE_INDEX
  //   - The given index value is already present.
  //
  // AAFRESULT_BAD_INDEX
  //   - index is greater than the value returned by
  //     CountInputSegments().
  //
  // AAFRESULT_NULL_PARAM
  //   - pSegment arg is NULL.
  //
  STDMETHOD(InsertInputSegmentAt) (THIS_
    // index to place this segment
    /*[in]*/ aafUInt32  index,

    // Segment to place in operation group
    /*[in]*/ IAAFSegment * pSegment) PURE;


  //***********************************************************
  //
  // SetRender()
  //
  // This function sets the final rendering for the given operation
  // group to the input source clip.  (Multiple renderings may exist if
  // the source clip refers to a master mob that contains a Essence
  // group.)
  // 
  // Succeeds if all of the following are true:
  // - the ppSourceRef pointer is valid.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - ppSourceRef arg is NULL.
  //
  STDMETHOD(SetRender) (THIS_
    // A segment containing a representation of the rendering
    /*[in]*/ IAAFSourceReference * ppSourceRef) PURE;


  //***********************************************************
  //
  // SetBypassOverride()
  //
  // This function sets the optional bypass override property on the
  // given operation group object.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  STDMETHOD(SetBypassOverride) (THIS_
    // Bypass override
    /*[in]*/ aafUInt32  bypassOverride) PURE;


  //***********************************************************
  //
  // GetParameters()
  //
  // returns an enumerator across all parameters.
  // 
  // Succeeds if all of the following are true:
  // - the ppEnum pointer is valid.
  // 
  // If this method fails nothing will be written to *ppEnum.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppEnum arg is NULL.
  //
  STDMETHOD(GetParameters) (THIS_
    // Parameter enumerator
    /*[out]*/ IEnumAAFParameters ** ppEnum) PURE;


  //***********************************************************
  //
  // LookupParameter()
  //
  // Given an argID, returns the corresponding parameter slot and
  // parameter slot value.
  // 
  // Succeeds if all of the following are true:
  // - the ppParameter pointer is valid.
  // 
  // If this method fails nothing will be written to *ppParameter.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_MISSING_PARAMETER
  //   - The given argID is not present.
  //
  // AAFRESULT_NULL_PARAM
  //   - ppParameter arg is NULL.
  //
  STDMETHOD(LookupParameter) (THIS_
    // Arg ID
    /*[in]*/ aafArgIDType_constref  argID,

    // Parameter object
    /*[out]*/ IAAFParameter ** ppParameter) PURE;


  //***********************************************************
  //
  // GetInputSegmentAt()
  //
  // Given an index, returns the corresponding input segment.
  // Working and final renderings are handled by using an
  // IAAFEssenceGroup as the segment.
  // 
  // Succeeds if all of the following are true:
  // - the ppInputSegment pointer is valid.
  // 
  // If this method fails nothing will be written to *ppInputSegment.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_MISSING_INDEX
  //   - The given index value is not present.
  //
  // AAFRESULT_NULL_PARAM
  //   - ppInputSegment arg is NULL.
  //
  STDMETHOD(GetInputSegmentAt) (THIS_
    // 0-based index into the effet inputs
    /*[in]*/ aafUInt32  index,

    // Input segment
    /*[out]*/ IAAFSegment ** ppInputSegment) PURE;


  //***********************************************************
  //
  // RemoveInputSegmentAt()
  //
  // Removes the segment at the given index.  Existing segments at
  // higher indices are moved down by one to accommodate.
  // 
  // Succeeds if all of the following are true:
  // - index is less than the result of CountInputSegments().
  // 
  // If this method fails no state will be changed.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_MISSING_INDEX
  //   - The given index value is not present.
  //
  STDMETHOD(RemoveInputSegmentAt) (THIS_
    // 0-based index into the effect inputs
    /*[in]*/ aafUInt32  index) PURE;

  END_INTERFACE
};
#endif // __IAAFOperationGroup_INTERFACE_DEFINED__



// IAAFGPITrigger

// ************************
//
// Interface IAAFGPITrigger
//
// ************************





#ifndef __IAAFGPITrigger_INTERFACE_DEFINED__
#define __IAAFGPITrigger_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFGPITrigger;

#undef  INTERFACE
#define INTERFACE   IAAFGPITrigger

DECLARE_INTERFACE_(IAAFGPITrigger, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFGPITrigger methods *** */


  //***********************************************************
  //
  // GetActiveState()
  //
  // Sets *pActiveState to AAFTrue it the event is on otherwise
  // sets it to AAFFalse.
  //
  // Succeeds if:
  // - The pActiveState pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - The pActiveState pointer is NULL.
  //
  STDMETHOD(GetActiveState) (THIS_
    // pointer to the result
    /*[out, retval]*/ aafBoolean_t *  pActiveState) PURE;


  //***********************************************************
  //
  // SetActiveState()
  //
  // Set to AAFTrue to turn the trigger on or AAFFalse
  // to turn the trigger off.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  STDMETHOD(SetActiveState) (THIS_
    // the active state of the trigger
    /*[in]*/ aafBoolean_t  ActiveState) PURE;


  END_INTERFACE
};
#endif // __IAAFGPITrigger_INTERFACE_DEFINED__



// IAAFHeader

// ************************
//
// Interface IAAFHeader
//
// ************************










#ifndef __IAAFHeader_INTERFACE_DEFINED__
#define __IAAFHeader_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFHeader;

#undef  INTERFACE
#define INTERFACE   IAAFHeader

DECLARE_INTERFACE_(IAAFHeader, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFHeader methods *** */
  //***********************************************************
  //
  // LookupMob()
  //
  // Looks up the Mob that matches the given mob id and puts it into
  // the ppMob argument.  The returned mob interface is AddRef()ed
  // before it is returned.
  // 
  // Succeeds if all of the following are true:
  // - the ppMob pointer is valid.
  // 
  // If this method fails nothing will be written to *ppMob.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppMob is null
  //
  // AAFRESULT_MOB_NOT_FOUND
  //   - the requested mob wasn't found.
  //
  STDMETHOD(LookupMob) (THIS_
    // The Mob ID
    /*[in, ref]*/ aafMobID_constref  mobID,

    // Matching Mob
    /*[out,retval]*/ IAAFMob ** ppMob) PURE;


  //***********************************************************
  //
  // CountMobs()
  //
  // Writes the number of matches for the given mob kind into the
  // *pNumMobs argument.
  // 
  // Succeeds if all of the following are true:
  // - the pNumMobs pointer is valid.
  // 
  // If this method fails nothing will be written to *pNumMobs.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pNumMobs is null.
  //
  STDMETHOD(CountMobs) (THIS_
    // The mob kind to count
    /*[in]*/ aafMobKind_t  mobKind,

    // Total number of mobs of kind mobKind
    /*[out, retval]*/ aafNumSlots_t *  pResult) PURE;


  //***********************************************************
  //
  // GetMobs()
  //
  // Places an enumerator for mobs that apply to the criteria into the
  // *ppEnum argument.  If pSearchCriteria is null, all mobs are
  // returned.   The searchTag field of pSearchCriteria, and exactly
  // ONE of the fields in the union (tags.mobID, tags.name, etc. )
  // must be set.  Only one search criterion may be specified.  The
  // returned enumerator is AddRef()ed before it is returned.
  // 
  // Succeeds if all of the following are true:
  // - the ppEnum pointer is valid.
  // 
  // If this method fails nothing will be written to *ppEnum.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppEnum is null.
  //
  STDMETHOD(GetMobs) (THIS_
    // Search Criteria for enumeration
    /*[in]*/ aafSearchCrit_t *  pSearchCriteria,

    // Mob Enumeration
    /*[out, retval]*/ IEnumAAFMobs ** ppEnum) PURE;


  //***********************************************************
  //
  // AddMob()
  //
  // Appends the given mob to the header.  If the given mob is already
  // contained this method will do nothing and will return success.
  // 
  // Succeeds if all of the following are true:
  // - the pMob pointer is valid.
  // - the given mob is not already part of this collection.
  // 
  // If this method fails no state will be changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pMob is null.
  //
  // AAFRESULT_DUPLICATE_MOBID
  //   - the given mob is already contained.
  //
  STDMETHOD(AddMob) (THIS_
    // Mob to add
    /*[in]*/ IAAFMob * pMob) PURE;


  //***********************************************************
  //
  // RemoveMob()
  //
  // // Removes the given mob from the header.
  //
  // Succeeds if all of the following are true:
  // - the pMob pointer is valid.
  // - the given mob is currently in the collection.
  // 
  // If this method fails no state will be changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pMob is null.
  //
  // AAFRESULT_MOB_NOT_FOUND
  //   - the given mob is not already contained.
  //
  STDMETHOD(RemoveMob) (THIS_
    // Mob to remove
    /*[in]*/ IAAFMob * pMob) PURE;


  //***********************************************************
  //
  // CountEssenceData()
  //
  // Writes the total number of essence data into the *pNumEssenceData
  // argument.
  // 
  // Succeeds if all of the following are true:
  // - the pNumEssenceData pointer is valid.
  // 
  // If this method fails nothing will be written to
  // *pNumEssenceData.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pNumEssenceData is null.
  //
  STDMETHOD(CountEssenceData) (THIS_
    // Total number of essence data
    /*[out, retval]*/ aafUInt32 *  pResult) PURE;


  //***********************************************************
  //
  // IsEssenceDataPresent()
  //
  // // 
  // Succeeds if all of the following are true:
  // - the pResult pointer is valid.
  // 
  // If this method fails no state will be changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pResult is null.
  //
  STDMETHOD(IsEssenceDataPresent) (THIS_
    // A Unique File Mob ID
    /*[in, ref]*/ aafMobID_constref  fileMobID,

    // The Essence File Format
    /*[in]*/ aafFileFormat_t  fmt,

    // True if the essence is found
    /*[out,retval]*/ aafBoolean_t *  pResult) PURE;


  //***********************************************************
  //
  // EnumEssenceData()
  //
  // Places an enumerator for essence that applies to the criteria
  // into the *ppEnum argument.  The returned enumerator is
  // AddRef()ed before it is returned.
  // 
  // Succeeds if all of the following are true:
  // - the pMediaCriteria pointer is valid.
  // - the ppEnum pointer is valid.
  // 
  // If this method fails nothing will be written to *ppEnum.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - either pMediaCriteria or ppEnum is null.
  //
  STDMETHOD(EnumEssenceData) (THIS_
    // Essence Enumeration
    /*[out,retval]*/ IEnumAAFEssenceData ** ppEnum) PURE;


  //***********************************************************
  //
  // AddEssenceData()
  //
  // Appends the given essence data object to the header.
  // 
  // NOTE! Stub only.   Implementation not yet added.
  //
  // Succeeds if all of the following are true:
  // - the pEssenceData pointer is valid.
  // 
  // If this method fails no state will be changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_DUPLICATE_MOBID
  //   - The given mob has already been added.  The validation is done by comparing
  //		mobIDs, which should be unique.
  //
  // AAFRESULT_NULL_PARAM
  //   - pEssenceData is null.
  //
  STDMETHOD(AddEssenceData) (THIS_
    // Essence data object to append
    /*[in]*/ IAAFEssenceData * pEssenceData) PURE;

  //***********************************************************
  //
  // RemoveEssenceData()
  //
  // // Removes the given EssenceData from the header.
  //
  // Succeeds if all of the following are true:
  // - the pEssenceData pointer is valid.
  // - the given EssenceData is currently in the collection.
  // 
  // If this method fails no state will be changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pEssenceData is null.
  //
  // AAFRESULT_ESSENCE_NOT_FOUND
  //   - the given EssenceData is not already contained.
  //
  STDMETHOD(RemoveEssenceData) (THIS_
    // EssenceData to remove
    /*[in]*/ IAAFEssenceData * pEssenceData) PURE;

  //***********************************************************
  //
  // LookupEssenceData()
  //
  // Looks up the EssenceData that matches the given mob id and puts it into
  // the ppEssenceData argument.  The returned EssenceData interface is AddRef()ed
  // before it is returned.
  // 
  // Succeeds if all of the following are true:
  // - the ppEssenceData pointer is valid.
  // 
  // If this method fails nothing will be written to *ppEssenceData.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppEssenceData is null
  //
  // AAFRESULT_MOB_NOT_FOUND
  //   - the requested EssenceData wasn't found.
  //
  STDMETHOD(LookupEssenceData) (THIS_
    // The Mob ID
    /*[in, ref]*/ aafMobID_constref  mobID,

    // Matching EssenceData
    /*[out,retval]*/ IAAFEssenceData ** ppEssenceData) PURE;

  //***********************************************************
  //
  // GetDictionary()
  //
  // Places the dictionary that contains all types of aaf definition
  // objects into the *ppDictionary argument.  The returned dictionary
  // is AddRef()ed before it is returned.  Note that the dictionary
  // is automatically created when the header object is created.
  // 
  // Succeeds if all of the following are true:
  // - the ppDictionary pointer is valid.
  // 
  // If this method fails no state will be changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppDictionary is null.
  //
  STDMETHOD(GetDictionary) (THIS_
    // The AAF Dictionary
    /*[out, retval]*/ IAAFDictionary ** ppDictionary) PURE;


  //***********************************************************
  //
  // GetLastIdentification()
  //
  // Places the identification of the last entity that modified the
  // file into the *ppIdentification argument.  The returned
  // identification is AddRef()ed before it is returned.
  // 
  // Succeeds if all of the following are true:
  // - the ppIdentification pointer is valid.
  // 
  // If this method fails no state will be changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppIdentification is null.
  //
  STDMETHOD(GetLastIdentification) (THIS_
    // Indentification Object
    /*[out,retval]*/ IAAFIdentification ** ppIdentification) PURE;


  //***********************************************************
  //
  // LookupIdentification()
  //
  // Places the Identification that matches the given generation into
  // the *ppIdentification argument.  The returned identification is
  // AddRef()ed before it is returned.
  // 
  // Succeeds if all of the following are true:
  // - the ppIdentification pointer is valid.
  // - the given generation was found.
  // 
  // If this method fails no state will be changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppIdentification is null.
  //
  // AAFRESULT_OBJECT_NOT_FOUND
  //   - the given generation was not found..
  //
  STDMETHOD(LookupIdentification) (THIS_
    // Unique Generation ID
    /*[in, ref]*/ aafUID_constref  generation,

    // Indentification Object
    /*[out,retval]*/ IAAFIdentification ** ppIdentification) PURE;


  //***********************************************************
  //
  // CountIdentifications()
  //
  // Writes the number of identification objects into the *pResult
  // argument.
  // 
  // Succeeds if all of the following are true:
  // - the pResult pointer is valid.
  // 
  // If this method fails nothing will be written to *pResult.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pResult is null.
  //
  STDMETHOD(CountIdentifications) (THIS_
    // Total number of identification objects
    /*[out, retval]*/ aafUInt32 *  pResult) PURE;


  //***********************************************************
  //
  // GetIdentifications()
  //
  // Places an enumerator for all Identifications criteria into	the
  // *ppEnum argument.  The returned enumerator is AddRef()ed before
  // it is returned.
  // 
  // NOTE! Stub only.   Implementation not yet added.
  //
  // Succeeds if all of the following are true:
  // - the ppEnum pointer is valid.
  // 
  // If this method fails nothing will be written to *ppEnum.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppEnum is null.
  //
  STDMETHOD(GetIdentifications) (THIS_
    // Indentification Enumeration
    /*[out,retval]*/ IEnumAAFIdentifications ** ppEnum) PURE;


  //***********************************************************
  //
  // AppendIdentification()
  //
  // Appends the given Identification class to the header.  This
  // method does not attempt to identify duplicate identifications, so
  // it will succeed even if an identical identification has already
  // been appended.
  // 
  // Succeeds if all of the following are true:
  // - the pIdent pointer is valid.
  // 
  // If this method fails no state will be changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pIdent is null.
  //
  STDMETHOD(AppendIdentification) (THIS_
    // Identification to append
    /*[in]*/ IAAFIdentification * pIdent) PURE;


  //***********************************************************
  //
  // GetIdentificationAt()
  //
  // Retrieves the indexed identification from the header.
  // 
  // Succeeds if all of the following are true:
  // - the ppIdentification pointer is valid.
  // - index is less than the value returned by CountIdentifications().
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppIdent is null.
  //
  // AAFRESULT_BADINDEX
  //   - index is greater than or equal to result of
  //     CountIdentifications().
  //
  STDMETHOD(GetIdentificationAt) (THIS_
    // Index of identification to retrieve
    /*[in]*/ aafUInt32  index,

    // Retrieved identification
    /*[out, retval]*/ IAAFIdentification ** ppIdentification) PURE;


  //***********************************************************
  //
  // GetRefImplVersion()
  //
  // Return the version of the Reference Implementation currently
  // running on this machine, which implements these interfaces.
  // 
  // Succeeds if all of the following are true:
  // - the pVersion pointer is valid.
  // 
  // If this method fails nothing is written to *pVersion.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pVersion is null.
  //
  STDMETHOD(GetRefImplVersion) (THIS_
    // The Reference Implementation Version
    /*[out, retval]*/ aafProductVersion_t *  pVersion) PURE;


  //***********************************************************
  //
  // GetFileRevision()
  //
  // Return the File Revision property.
  // 
  // NOTE! Stub only.   Implementation not yet added.
  //
  // Succeeds if all of the following are true:
  // - the pRevision pointer is valid.
  // 
  // If this method fails nothing is written to *pRevision.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pRevision is null.
  //
  STDMETHOD(GetFileRevision) (THIS_
    // The File Version
    /*[out, retval]*/ aafVersionType_t *  pRevision) PURE;


  //***********************************************************
  //
  // GetLastModified()
  //
  // Return the Last Modified property.
  // 
  // NOTE! Stub only.   Implementation not yet added.
  //
  // Succeeds if all of the following are true:
  // - the pTimeStamp pointer is valid.
  // 
  // If this method fails nothing is written to *pTimeStamp.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pTimeStamp is null.
  //
  STDMETHOD(GetLastModified) (THIS_
    // The modification date-time stamp
    /*[out, retval]*/ aafTimeStamp_t *  pTimeStamp) PURE;


  //***********************************************************
  //
  // GetContentStorage()
  //
  // Places the Content Storage object attached to the header into the
  // *ppStorage argument.
  //
  // The returned content storage object is
  // AddRef()ed before it is returned.
  //
  // Succeeds if all of the following are true:
  // - the ppStorage pointer is valid.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - ppStorage is null.
  //
  STDMETHOD(GetContentStorage) (THIS_
    // Returned Content Storage object
    /*[out]*/ IAAFContentStorage ** ppStorage) PURE;






  END_INTERFACE
};
#endif // __IAAFHeader_INTERFACE_DEFINED__


// IAAFIdentification

// ************************
//
// Interface IAAFIdentification
//
// ************************



#ifndef __IAAFIdentification_INTERFACE_DEFINED__
#define __IAAFIdentification_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFIdentification;

#undef  INTERFACE
#define INTERFACE   IAAFIdentification

DECLARE_INTERFACE_(IAAFIdentification, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFIdentification methods *** */

  //***********************************************************
  //
  // Initialize()
  //
  // Initializes a newly allocated IAAFIdentification-supporting
  // object.  This method must be called after allocation, and before
  // any other method can be called.
  //
  // This method fills in the mandatory properties of the object.  The
  // values of the following required properties are set based on the
  // information given in arguments to this method:
  // - companyName
  // - productname
  // - productVersionString
  // - productID
  // 
  // The following mandatory properties will be filled in
  // automatically by the reference implementation:
  // - date
  // - generationAUID
  //
  // Succeeds if:
  // - Initialize() has not yet been called on this object.
  // - companyName is a valid pointer
  // - productName is a valid pointer
  // - productVersionString is a valid pointer
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_ALREADY_INITIALIZED
  //   - Initialize() has already been called on this object.
  //
  // AAFRESULT_NULL_PARAM
  //   - companyName, productName, or productVersionString is NULL.
  //
  STDMETHOD(Initialize) (THIS_
    // company name string
    /*[in]*/ aafCharacter_constptr  companyName,

    // product name string
    /*[in]*/ aafCharacter_constptr  productName,

    // product version string
    /*[in]*/ aafCharacter_constptr  productVersionString,

    // product identification
    /*[in]*/ aafUID_constref  productID) PURE;


  //***********************************************************
  //
  // GetCompanyName()
  //
  // Gets the Company Name string property.
  // 
  // Writes the CompanyName property, with a trailing null
  // character, into the pCompanyName buffer.  The
  // buffer is allocated by the caller.  The size of the buffer is
  // given by bufSize.  If the CompanyName property has not yet
  // been set, a zero-length string will be written (that is,
  // only the trailing null character). 
  // 
  // Caller may call GetCompanyNameBufLen() to determine the
  // required buffer size.
  // 
  // If this method fails nothing will be written to
  // *pCompanyName.
  // 
  // Succeeds if:
  // - The pCompanyName pointer is valid.
  // - bufSize indicates that the buffer is large enough to hold
  //   CompanyName.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pCompanyName arg is NULL.
  //
  // AAFRESULT_SMALL_BUF
  //   - bufSize indicates that the allocated buffer is not large
  //     enough to hold CompanyName.
  //
  STDMETHOD(GetCompanyName) (THIS_
    // buffer into which CompanyName is to be written
    /*[out, string, size_is(bufSize)]*/ aafCharacter *  pCompanyName,

    // size of *pCompanyName buffer in bytes
    /*[in]*/ aafUInt32  bufSize) PURE;


  //***********************************************************
  //
  // GetCompanyNameBufLen()
  //
  // Returns size of buffer (in bytes) required for GetCompanyName().
  // 
  // Succeeds if:
  // - The pBufSize pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pBufSize arg is NULL.
  //
  STDMETHOD(GetCompanyNameBufLen) (THIS_
    // size of required buffer, in bytes
    /*[out]*/ aafUInt32 *  pBufSize) PURE;


  //***********************************************************
  //
  // GetProductName()
  //
  // Gets the Product Name string property.
  // 
  // Writes the ProductName property, with a trailing null
  // character, into the pProductName buffer.  The
  // buffer is allocated by the caller.  The size of the buffer is
  // given by bufSize.  If the ProductName property has not yet
  // been set, a zero-length string will be written (that is,
  // only the trailing null character). 
  // 
  // Caller may call GetProductNameBufLen() to determine the
  // required buffer size.
  // 
  // If this method fails nothing will be written to
  // *pProductName.
  // 
  // Succeeds if:
  // - The pProductName pointer is valid.
  // - bufSize indicates that the buffer is large enough to hold
  //   ProductName.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pProductName arg is NULL.
  //
  // AAFRESULT_SMALL_BUF
  //   - bufSize indicates that the allocated buffer is not large
  //     enough to hold ProductName.
  //
  STDMETHOD(GetProductName) (THIS_
    // buffer into which ProductName is to be written
    /*[out, string, size_is(bufSize)]*/ aafCharacter *  pProductName,

    // size of *pProductName buffer in bytes
    /*[in]*/ aafUInt32  bufSize) PURE;


  //***********************************************************
  //
  // GetProductNameBufLen()
  //
  // Returns size of buffer (in bytes) required for GetProductName().
  // 
  // Succeeds if:
  // - The pBufSize pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pBufSize arg is NULL.
  //
  STDMETHOD(GetProductNameBufLen) (THIS_
    // size of required buffer, in bytes
    /*[out]*/ aafUInt32 *  pBufSize) PURE;


  //***********************************************************
  //
  // GetProductVersionString()
  //
  // Gets the Product Version string property.
  // 
  // Writes the ProductVersionString property, with a trailing null
  // character, into the pProductVersionString buffer.  The
  // buffer is allocated by the caller.  The size of the buffer is
  // given by bufSize.  If the ProductVersionString property has not yet
  // been set, a zero-length string will be written (that is,
  // only the trailing null character). 
  // 
  // Caller may call GetProductVersionStringBufLen() to determine the
  // required buffer size.
  // 
  // If this method fails nothing will be written to
  // *pProductVersionString.
  // 
  // Succeeds if:
  // - The pProductVersionString pointer is valid.
  // - bufSize indicates that the buffer is large enough to hold
  //   ProductVersionString.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pProductVersionString arg is NULL.
  //
  // AAFRESULT_SMALL_BUF
  //   - bufSize indicates that the allocated buffer is not large
  //     enough to hold ProductVersionString.
  //
  STDMETHOD(GetProductVersionString) (THIS_
    // buffer into which ProductVersionString is to be written
    /*[out, string, size_is(bufSize)]*/ aafCharacter *  pProductVersionString,

    // size of *pProductVersionString buffer in bytes
    /*[in]*/ aafUInt32  bufSize) PURE;


  //***********************************************************
  //
  // GetProductVersionStringBufLen()
  //
  // Returns size of buffer (in bytes) required for GetProductVersionString().
  // 
  // Succeeds if:
  // - The pBufSize pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pBufSize arg is NULL.
  //
  STDMETHOD(GetProductVersionStringBufLen) (THIS_
    // size of required buffer, in bytes
    /*[out]*/ aafUInt32 *  pBufSize) PURE;


  //***********************************************************
  //
  // GetProductVersion()
  //
  // Gets the Product Version property associated with this
  // identification object and places it into *pVersion.
  // 
  // Succeeds if all of the following are true:
  // - the pVersion pointer is valid.
  // 
  // If this method fails, nothing will be written to *pVersion.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pVersion arg is NULL.
  //
  STDMETHOD(GetProductVersion) (THIS_
    // The Product Version
    /*[out]*/ aafProductVersion_t *  pVersion) PURE;


  //***********************************************************
  //
  // SetProductVersion()
  //
  // Set the Product Version property to the value specified in
  // pVersion.  A copy is made of the data so the caller retains
  // ownership of the *pVersion struct and is responsible for
  // de-allocating it.
  // 
  // If this method fails the Product Version property will not be
  // changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  STDMETHOD(SetProductVersion) (THIS_
    // The Product Version
    /*[in]*/ aafProductVersion_constref  version) PURE;


  //***********************************************************
  //
  // GetProductID()
  //
  // Obtains the Product ID, which is the identification number
  // assigned to the application and vendor of the application which
  // attached this object to the AAF file.  This ID is written into
  // the caller-allocated aafUID_t specified by the pProductID
  // argument.
  // 
  // Succeeds if all of the following are true:
  // - the pProductID pointer is valid.
  // 
  // If this method fails nothing will be written to *pProductID.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pProductID arg is NULL.
  //
  STDMETHOD(GetProductID) (THIS_
    // The Product ID
    /*[out]*/ aafUID_t *  pProductID) PURE;


  //***********************************************************
  //
  // GetDate()
  //
  // Writes the Date-time Stamp property into the caller-allocated
  // aafTimeStamp_t specified by the pTimeStamp argument.  The
  // date-time stamp recorded in this object corresponds to the time
  // that this file was created or modified upon the occasion that
  // this object was added to the file.
  //
  // Note: This is a read-only property.
  // 
  // Succeeds if all of the following are true:
  // - the pTimeStamp pointer is valid.
  // 
  // If this method fails nothing will be written to *pTimeStamp.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pTimeStamp arg is NULL.
  //
  STDMETHOD(GetDate) (THIS_
    // The date-time stamp
    /*[out]*/ aafTimeStamp_t *  pTimestamp) PURE;


  //***********************************************************
  //
  // GetRefImplVersion()
  //
  // Obtains the version of the Reference Implementation which
  // created this identification object and writes it into the
  // caller-allocated aafProductVersion_t specified by the pVersion
  // argument.
  //
  // Note: This is a read-only property.
  // 
  // Succeeds if all of the following are true:
  // - the pVersion pointer is valid.
  // 
  // If this method fails nothing will be written to *pVersion.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pVersion arg is NULL.
  //
  STDMETHOD(GetRefImplVersion) (THIS_
    // The Reference Implementation Version
    /*[out]*/ aafProductVersion_t *  pVersion) PURE;


  //***********************************************************
  //
  // GetPlatform()
  //
  // Gets the Platform string property.
  //
  // This information is provided only to allow diagnostic printing of
  // platform information to be read by humans.  The format of the
  // strings is not guaranteed to remain the same for a given
  // platform.  Having said that, the possible values currently
  // returned are:
  // - "Win32" for Intel/Win32 platforms
  // - "MacOS" for MacOS platforms
  // - "Unknown" for unknown platforms
  // 
  // Writes the Platform property, with a trailing null
  // character, into the pPlatform buffer.  The
  // buffer is allocated by the caller.  The size of the buffer is
  // given by bufSize.  If the Platform property has not yet
  // been set, a zero-length string will be written (that is,
  // only the trailing null character). 
  // 
  // Caller may call GetPlatformBufLen() to determine the
  // required buffer size.
  // 
  // If this method fails nothing will be written to
  // *pPlatform.
  // 
  // Succeeds if:
  // - The pPlatform pointer is valid.
  // - bufSize indicates that the buffer is large enough to hold
  //   Platform.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pPlatform arg is NULL.
  //
  // AAFRESULT_SMALL_BUF
  //   - bufSize indicates that the allocated buffer is not large
  //     enough to hold Platform.
  //
  STDMETHOD(GetPlatform) (THIS_
    // buffer into which Platform is to be written
    /*[out, string, size_is(bufSize)]*/ aafCharacter *  pPlatform,

    // size of *pPlatform buffer in bytes
    /*[in]*/ aafUInt32  bufSize) PURE;


  //***********************************************************
  //
  // GetPlatformBufLen()
  //
  // Returns size of buffer (in bytes) required for GetPlatform().
  // 
  // Succeeds if:
  // - The pBufSize pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pBufSize arg is NULL.
  //
  STDMETHOD(GetPlatformBufLen) (THIS_
    // size of required buffer, in bytes
    /*[out]*/ aafUInt32 *  pBufSize) PURE;


  //***********************************************************
  //
  // GetGenerationID()
  //
  // Obtains the generation of this AAF file, which was generated at
  // the time this identification object was created.  If a file was
  // opened for modification by many applications in its lifetime,
  // then there will be multiple Identification objects.  This is
  // written into the caller-allocated aafUID_t specified by the
  // pGeneration argument.
  // 
  // Note: This is a read-only property.
  // 
  // Succeeds if all of the following are true:
  // - the pGeneration pointer is valid.
  // 
  // If this method fails nothing will be written to *pGeneration.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pGeneration arg is NULL.
  //
  STDMETHOD(GetGenerationID) (THIS_
    // The unique generation
    /*[out]*/ aafUID_t *  pGeneration) PURE;

  END_INTERFACE
};
#endif // __IAAFIdentification_INTERFACE_DEFINED__



// IAAFInterpolationDef

// ************************
//
// Interface IAAFInterpolationDef
//
// ************************




#ifndef __IAAFInterpolationDef_INTERFACE_DEFINED__
#define __IAAFInterpolationDef_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFInterpolationDef;

#undef  INTERFACE
#define INTERFACE   IAAFInterpolationDef

DECLARE_INTERFACE_(IAAFInterpolationDef, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFInterpolationDef methods *** */

  //***********************************************************
  //
  // Initialize()
  //
  // Init all fields of a definition object.
  //
  STDMETHOD(Initialize) (THIS_
    // AUID for new DeObject
    /*[in, ref]*/ aafUID_constref  id,

    // Name for new DefObject
    /*[in, string]*/ aafCharacter_constptr  pName,

    // Description for new DefObject
    /*[in, string]*/ aafCharacter_constptr  pDescription) PURE;



  END_INTERFACE
};
#endif // __IAAFInterpolationDef_INTERFACE_DEFINED__



// IAAFKLVData

// ************************
//
// Interface IAAFKLVData
//
// ************************




#ifndef __IAAFKLVData_INTERFACE_DEFINED__
#define __IAAFKLVData_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFKLVData;

#undef  INTERFACE
#define INTERFACE   IAAFKLVData

DECLARE_INTERFACE_(IAAFKLVData, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFKLVData methods *** */

  //***********************************************************
  //
  // Initialize()
  //
  // Initializes a new KLVData object to be interpreted using the
  // given given key.  The key must have been registered using dictionary->RegisterKLVDataKey()
  // in order to use the byte swapping functionality of the type model.
  //
  // This method must be called after allocation, and before
  // any other method can be called.
  //
  // Succeeds if:
  // - Initialize() has not yet been called on this object.
  // - pName is a valid pointer.
  // - pTypeDef is a valid pointer and registered
  // - pValue is a valid pointer
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_ALREADY_INITIALIZED
  //   - This object has already had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pTypeDef or pValue arg is NULL.
  // AAFRESULT_NOT_VALID_KEY
  //   - The  given key must not resolve to a builtin type.  For most purposes, use
  //     IAAFTypeDefRename to rename an existing type.
  //
  // 
  //
  STDMETHOD(Initialize) (THIS_
    // Key of the following value data
    /*[in]*/ aafUID_t  key,

    // Length of preallocated buffer
    /*[in]*/ aafUInt32  length,

    // buffer containing value
    /*[in, size_is(length)]*/ aafDataBuffer_t  pValue) PURE;

  //***********************************************************
  //
  // GetKey()
  //
  // Returns the type definition for this invocation.
  // 
  // Succeeds if all of the following are true:
  // - the pKey pointer is valid.
  // 
  // If this method fails nothing will be written to *pKey.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  //
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_PROP_NOT_PRESENT
  //   - This property does not exist in the file.
  //
  // AAFRESULT_NULL_PARAM
  //   - pKey arg is NULL.
  //
  STDMETHOD(GetKey) (THIS_
    // The key of this object
    /*[out]*/ aafUID_t*  pKey) PURE;


  //***********************************************************
  //
  // GetValue()
  //
  // Writes the value into the pValue buffer.  The buffer is allocated
  // by the caller, and the size of the buffer is given by
  // valueSize.
  // 
  // Caller may call GetValueBufLen() to determine the
  // required buffer size.
  // 
  // Succeeds if all of the following are true:
  // - the pValue pointer is valid.
  // - valueSize indicates the buffer is large enough to hold the name.
  // 
  // If this method fails nothing will be written to *pValue.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pValue arg is NULL.
  //
  // AAFRESULT_SMALLBUF
  //   - valueSize indicates the buffer is too small to hold the value.
  //
  STDMETHOD(GetValue) (THIS_
    // Size of preallocated buffer
    /*[in]*/ aafUInt32  valueSize,

    // Preallocated buffer to hold value
    /*[out, size_is(valueSize), length_is(*bytesRead)]*/ aafDataBuffer_t  pValue,

    // Number of actual bytes read
    /*[out]*/ aafUInt32 *  bytesRead) PURE;


  //***********************************************************
  //
  // GetValueBufLen()
  //
  // Returns the length of buffer required for the GetValue() method.
  // The value is placed into the location specified by pLen.
  //
  // Succeeds if all of the following are true:
  // - the pLen pointer is valid.
  //
  // If this method fails nothing will be written to *pLen.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pLen arg is NULL.
  //
  STDMETHOD(GetValueBufLen) (THIS_
    // Pointer to an variable used to return the length
    /*[out]*/ aafUInt32 *  pLen) PURE;

  //***********************************************************
  //
  // SetValue()
  //
  // The data value is set from a buffer of size valueSize and type.
  //
  // Succeeds if all of the following are true:
  // - the pValue pointer is valid.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pValue is null.
  //
  STDMETHOD(SetValue) (THIS_
    // Size of preallocated buffer
    /*[in]*/ aafUInt32  valueSize,

    // buffer containing value
    /*[in, size_is(valueSize)]*/ aafDataBuffer_t  pValue) PURE;


  END_INTERFACE
};
#endif // __IAAFKLVData_INTERFACE_DEFINED__



// IAAFLocator

// ************************
//
// Interface IAAFLocator
//
// ************************



#ifndef __IAAFLocator_INTERFACE_DEFINED__
#define __IAAFLocator_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFLocator;

#undef  INTERFACE
#define INTERFACE   IAAFLocator

DECLARE_INTERFACE_(IAAFLocator, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFLocator methods *** */

  //***********************************************************
  //
  // SetPath()
  //
  // Sets the Path string property.
  //
  // Set the Path property to the value specified in
  // pPath.  A copy is made of the data so the caller
  // retains ownership of the *pPath buffer and is
  // responsible for de-allocating it.  There is no pre-set limit to
  // the length of the name, other than available system memory or
  // disk space.
  // 
  // Succeeds if all of the following are true:
  // - the pPath pointer is valid.
  // 
  // If this method fails the Path property will not be
  // changed.
  // 
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pPath arg is NULL.
  //
  STDMETHOD(SetPath) (THIS_
    // buffer from which Path is to be read
    /*[in, string]*/ aafCharacter_constptr  pPath) PURE;


  //***********************************************************
  //
  // GetPath()
  //
  // Gets the Path string property.
  // 
  // Writes the Path property, with a trailing null
  // character, into the pPath buffer.  The
  // buffer is allocated by the caller.  The size of the buffer is
  // given by bufSize.  If the Path property has not yet
  // been set, a zero-length string will be written (that is,
  // only the trailing null character). 
  // 
  // Caller may call GetPathBufLen() to determine the
  // required buffer size.
  // 
  // If this method fails nothing will be written to
  // *pPath.
  // 
  // Succeeds if:
  // - The pPath pointer is valid.
  // - bufSize indicates that the buffer is large enough to hold
  //   Path.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pPath arg is NULL.
  //
  // AAFRESULT_SMALL_BUF
  //   - bufSize indicates that the allocated buffer is not large
  //     enough to hold Path.
  //
  STDMETHOD(GetPath) (THIS_
    // buffer into which Path is to be written
    /*[out, string, size_is(bufSize)]*/ aafCharacter *  pPath,

    // size of *pPath buffer in bytes
    /*[in]*/ aafUInt32  bufSize) PURE;


  //***********************************************************
  //
  // GetPathBufLen()
  //
  // Returns size of buffer (in bytes) required for GetPath().
  // 
  // Succeeds if:
  // - The pBufSize pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pBufSize arg is NULL.
  //
  STDMETHOD(GetPathBufLen) (THIS_
    // size of required buffer, in bytes
    /*[out]*/ aafUInt32 *  pBufSize) PURE;

  END_INTERFACE
};
#endif // __IAAFLocator_INTERFACE_DEFINED__



// IAAFMasterMob

// ************************
//
// Interface IAAFMasterMob
//
// ************************









#ifndef __IAAFMasterMob_INTERFACE_DEFINED__
#define __IAAFMasterMob_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFMasterMob;

#undef  INTERFACE
#define INTERFACE   IAAFMasterMob

DECLARE_INTERFACE_(IAAFMasterMob, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFMasterMob methods *** */
  //***********************************************************
  //
  // Initialize()
  //
  // Initializes a newly allocated, empty IAAFMasterMob-supporting
  // object.  This method must be called after allocation, and before
  // any other method can be called.
  //
  // Succeeds if:
  // - Initialize() has not yet been called on this object.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_ALREADY_INITIALIZED
  //   - Initialize() has already been called on this object.
  STDMETHOD(Initialize) (THIS) PURE;


  //***********************************************************
  //
  // AddMasterSlot()
  //
  // This function adds a slot to the specified Master Mob that
  // references the specified a slot in the specified Source Mob. The
  // new slot in the Master Mob contains a Source Clip that specifies
  // the Source Mob in its source reference properties.  Typically this
  // is done automatically by passing the Master Mob handle to
  // AAFMedia::Create, but this function allows you to add it later.
  //
  // Note: If pSlotName is passed in with zero length, then the
  // slot is not assigned a name.  Slot names are not used by the
  // SDK, and exist only so the user can name slots.
  // 
  // Succeeds if all of the following are true:
  // (more conditions here)
  // 
  // If this method fails no state is changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - One or more of the following parameters are NULL pSourceMob,
  //     pSlotName, and pDataDef.
  //
  // AAFRESULT_INVALID_DATADEF
  //   - The data kind of the source MOB slot to be added to the Master
  //     Mob does not match what is specfied in pDataDef.
  //
  // AAFRESULT_SLOT_NOTFOUND
  //   - The specified Source Mob slot was not found.
  //
  // AAFRESULT_SLOT_EXISTS
  //   - The specified Master slot ID already exists.
  //
  STDMETHOD(AddMasterSlot) (THIS_
    // Data kind of new slot.  Requires a data kind valid for a media
	// stream. Valid data kinds are:
    // - DDEF_Picture
    // - DDEF_Sound
    /*[in]*/ IAAFDataDef * pDataDef,

    // Slot ID of the Source Mob slot to be added to the Master Mob
    /*[in]*/ aafSlotID_t  sourceSlotID,

    // Source Mob containing the slot to be added to the Master Mob
    /*[in]*/ IAAFSourceMob * pSourceMob,

    // SlotID assigned to the new Master Mob slot
    /*[in]*/ aafSlotID_t  masterSlotID,

    // Name to assign to new slot in Master Mob
    /*[in, string]*/ aafCharacter_constptr  pSlotName) PURE;


  //***********************************************************
  //
  // GetTapeName()
  //
  // Finds the tape Source Mob associated with a Master Mob slot
  // and writes the name of the tape, which is stored in the
  // Mobs Name property, into the pTapeName buffer.  The buffer is
  // allocated by the caller.  The size of the buffer is given by
  // bufSize.  If the property name has not yet been set, a
  // zero-length string will be written (that is, only the trailing
  // null character).
  // 
  // Caller may call GetTapeNameBufLen() to determine the required
  // buffer size.
  // 
  // NOTE! Stub only.   Implementation not yet added.
  //
  // Succeeds if all of the following are true:
  // - the pTapeName pointer is valid.
  // - the specified master slot was found.
  // - the specified master slot contains a tape mob.
  // - bufSize indicates the buffer is large enough to hold the name.
  // 
  // If this method fails nothing will be written to *pTapeName.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pTapeName arg is NULL.
  //
  // AAFRESULT_SLOT_NOTFOUND
  //   - The specified Master Slot was not found.
  //
  // AAFRESULT_NOT_TAPEMOB
  //   - The specified Master Slot does not contain a Tape MOB.
  //
  // AAFRESULT_SMALLBUF
  //   - bufSize indicates the buffer is too small to hold the string.
  //
  STDMETHOD(GetTapeName) (THIS_
    // SlotID of the Master Mob slot
    /*[in]*/ aafUInt32  masterSlotID,

    // The returned name
    /*[out, size_is(bufSize), string]*/ aafCharacter *  pTapeName,

    // the size of the pTapeName buffer
    /*[in]*/ aafUInt32  bufSize) PURE;


  //***********************************************************
  //
  // GetTapeNameBufLen()
  //
  // Returns the length of buffer required for the GetTapeName()
  // method.  The value is placed into the location specified by
  // pLen.  The value will include space required for the trailing
  // null character.
  //
  // NOTE! Stub only.   Implementation not yet added.
  //
  // Succeeds if all of the following are true:
  // - the pLen pointer is valid.
  //
  // If this method fails nothing will be written to *pLen.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pLen arg is NULL.
  //
  // AAFRESULT_SLOT_NOTFOUND
  //   - The specified Master Slot was not found.
  //
  // AAFRESULT_NOT_TAPEMOB
  //   - The specified Master Slot does not contain a Tape MOB.
  //
  STDMETHOD(GetTapeNameBufLen) (THIS_
    // SlotID of the Master Mob slot
    /*[in]*/ aafUInt32  masterSlotID,

    // required buffer length
    /*[out]*/ aafUInt32 *  pLen) PURE;


  //***********************************************************
  //
  // GetNumRepresentations()
  //
  // This function returns the number of media representations
  // available for the specified SlotID on a specified Master
  // Mob. This function is meant to work with
  // GetRepresentationSourceClip, so that you can iterate through
  // all of the choices yourself.  In most cases, you can use
  // GetCriteriaSourceClip to handle multiple
  // representations.  This function and
  // GetRepresentationSourceClip are lower-level functions.
  //
  // Succeeds if all of the following are true:
  // - the pNumReps pointer is valid.
  //
  // If this method fails nothing will be written to *pNumReps.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pNumReps arg is NULL.
  //
  // AAFRESULT_SLOT_NOTFOUND
  //   - The Master Slot specified by slotID was not found.
  //
  STDMETHOD(GetNumRepresentations) (THIS_
    // SlotID
    /*[in]*/ aafSlotID_t  slotID,

    // number of representations
    /*[out, retval]*/ aafNumSlots_t *  pNumReps) PURE;


  //***********************************************************
  //
  // GetRepresentation()
  //
  // This method returns the indexed media representation for the
  // specified Master Mob, SlotID, and index.  This call is meant to
  // work with GetNumRepresentations, so that you can iterate through
  // all of the choices yourself.  This method uses an integer index,
  // not an iterator.  The function GetRepresentationSourceClip takes
  // an index between 1 and the number of representations
  // [inclusive], and returns the indexed Source Mob. You can make
  // calls to functions such as AAFMedia::GetVideoInfo and
  // AAFMedia::IsMediaContiguous to determine which media is the best
  // fit.
  //
  // The returned source clip is AddRef()ed before it is returned.
  //
  // NOTE! Stub only.   Implementation not yet added.
  //
  // Succeeds if all of the following are true:
  // - the ppSourceClip pointer is valid.
  //
  // If this method fails nothing will be written to *ppSourceClip.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - ppSourceClip arg is NULL.
  //
  // AAFRESULT_SLOT_NOTFOUND
  //   - The specified Master Slot was not found.
  //
  // AAFRESULT_BADINDEX
  //   - No Source Mob at specified index.
  //
  STDMETHOD(GetRepresentation) (THIS_
    // Slot ID
    /*[in]*/ aafSlotID_t  slotID,

    // Index of requested representation
    /*[in]*/ aafUInt32  index,

    // Requested Source Clip
    /*[out]*/ IAAFSegment ** ppSourceClip) PURE;


  //***********************************************************
  //
  // GetCriteriaSegment()
  //
  // Returns the Segment on the specified slot of a Master Mob
  // that references the Source Mob that best meets the specified
  // criteria.  This function will work whether multiple media
  // representations exist or not.
  //
  // The returned segment is AddRef()ed before it is returned.
  //
  // NOTE! Stub only.   Implementation not yet added.
  //
  // Succeeds if all of the following are true:
  // - the ppSegment pointer is valid.
  //
  // If this method fails nothing will be written to *ppSegment.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - ppSegment arg is NULL.
  //
  // AAFRESULT_SLOT_NOTFOUND
  //   - The specified Master Slot was not found.
  //
  STDMETHOD(GetCriteriaSegment) (THIS_
    // Slot ID
    /*[in]*/ aafSlotID_t  slotID,

    // Index of requested representation.  Note: the
	// aafMediaCriteria_t is defined as the following structure:
    // typedef struct
    // {
    //	aafCriteriaType_t type;
    //	aafCriteriaProc_t proc;
    // } aafMediaCriteria_t;
	//
    // The type field can have one of the following values:
    // typedef enum
    // {
    //	kAAFAnyRepresentation = 0,
    //	kAAFFastestRepresentation,
    //	kAAFBestFidelityRepresentation,
    //	kAAFSmallestRepresentation,
    //	kAAFUseRepresentationProc
    // } aafCriteriaType_t;
    /*[in]*/ aafMediaCriteria_t *  pCriteria,

    // Requested Segment
    /*[out]*/ IAAFSegment ** ppSegment) PURE;


  //***********************************************************
  //
  // AppendPhysSourceRef()
  //
  // Connects this Source Mob with the physical Source Mob that
  // describes the previous generation of essence, appending it to
  // existing Mob data.  If a physical Source Mob, such as a File
  // Source Mob or tape Source Mob, references another physical
  // Source Mob as its ancestor, with no pulldown, then this
  // function makes the connection between the two.
  //
  // Functionally, this is a helper function to create a slot with an
  // AAFSourceClip referencing a particular piece of media.  This
  // function takes many parameters because the components of an
  // aafSourceRef_t have been broken out as separate parameters.
  //
  // The ancestor of an AAFSourceMob with an AAFFileDescriptor is often an
  // AAFTapeDescriptor or NIL.
  //
  // Succeeds if all of the following are true:
  // - the pSourceRefObj pointer is valid.
  // - the pEssenceKind pointer is valid.
  // (other conditions here)
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pSourceRefObj or pEssenceKind is null.
  //
  // (other codes here.)
  //
  STDMETHOD(AppendPhysSourceRef) (THIS_
    // Edit rate of slot to contain reference
    /*[in]*/ aafRational_t  editrate,

    // SlotID of slot to contain reference
    /*[in]*/ aafSlotID_t  aMobSlot,

    // Data kind of slot to contain reference.  Requires a data kind
	// valid for a essence stream.  Valid data kinds are:
    // - Picture
    // - Sound
    /*[in]*/ IAAFDataDef * pEssenceKind,

    // Reference to a Physical Source Mob
    /*[in]*/ aafSourceRef_t  ref,

    // Length of the Source Clip
    /*[in]*/ aafLength_t  srcRefLength) PURE;


  //***********************************************************
  //
  // NewPhysSourceRef()
  //
  // Connects this Source Mob with the physical Source Mob that
  // describes the previous generation of essence, replacing any
  // existing Mob data.  If a physical Source Mob, such as a File
  // Source Mob or tape Source Mob, references another physical
  // Source Mob as its ancestor, with no pulldown, then this
  // function makes the connection between the two.
  //
  // Functionally, this is a helper function to create a slot with an
  // AAFSourceClip referencing a particular piece of media.  This
  // function takes many parameters because the components of an
  // aafSourceRef_t have been broken out as separate parameters.
  //
  // The ancestor of an AAFSourceMob with an AAFFileDescriptor is often an
  // AAFTapeDescriptor or NIL.
  //
  // Succeeds if all of the following are true:
  // - the pSourceRefObj pointer is valid.
  // - the pEssenceKind pointer is valid.
  // (other conditions here)
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pSourceRefObj or pEssenceKind is null.
  //
  // (other codes here.)
  //
  STDMETHOD(NewPhysSourceRef) (THIS_
    // Edit rate of slot to contain reference
    /*[in]*/ aafRational_t  editrate,

    // SlotID of slot to contain reference
    /*[in]*/ aafSlotID_t  aMobSlot,

    // Data kind of slot to contain reference.  Requires a data kind
	// valid for a essence stream.  Valid data kinds are:
    // - Picture
    // - Sound
    /*[in]*/ IAAFDataDef * pEssenceKind,

    // Reference to a Physical Source Mob
    /*[in]*/ aafSourceRef_t  ref,

    // Length of the Source Clip
    /*[in]*/ aafLength_t  srcRefLength) PURE;


  //***********************************************************
  //
  // CreateEssence()
  //
  // Creates a single channel stream of essence.  Convenience
  // functions exist to create audio or video essence, and a separate
  // call (MultiCreate) exists to create interleaved audio and video
  // data.
  //
  // The essence handle from this call can be used with
  // WriteDataSamples  and possibly WriteDataLines, but NOT with
  // WriteMultiSamples.
  // 
  // If you are creating the essence, and then attaching it to a
  // master mob, then the "masterMob" field may be left NULL.  For
  // video, the sampleRate should be the edit rate of the file mob.
  // For audio, the sample rate should be the actual samples per
  // second.
  //
  STDMETHOD(CreateEssence) (THIS_
    // 
    /*[in]*/ aafSlotID_t  masterSlotID,

    // create essence of this type
    /*[in]*/ IAAFDataDef * pMediaKind,

    // using this codec
    /*[in, ref]*/ aafUID_constref  codecID,

    // with this edit rate
    /*[in]*/ aafRational_t  editRate,

    // with this sample rate
    /*[in]*/ aafRational_t  samplerate,

    // optionally compressing it
    /*[in]*/ aafCompressEnable_t  Enable,

    // Optionally create the file HERE.
    /*[in]*/ IAAFLocator * destination,

    // with this format
    /*[in, ref]*/ aafUID_constref  fileFormat,

    // Return an essence access on the essence.
    /*[out]*/ IAAFEssenceAccess ** access) PURE;


  //***********************************************************
  //
  // CreateMultiEssence()
  //
  // Creates a multi-channel interleaved stream of essence.  The
  // essence handle from this call can be used with WriteDataSamples
  // or WriteMultiSamples but NOT with or WriteDataLines.
  // 
  // If you are creating the essence, and then attaching it to a
  // master mob, then the "masterMob" field may be left NULL.
  //
  STDMETHOD(CreateMultiEssence) (THIS_
    // using this codec
    /*[in, ref]*/ aafUID_constref  codecID,

    // this many channels
    /*[in]*/ aafUInt16  arrayElemCount,

    // using these definitions
    /*[in,ref,size_is(arrayElemCount)]*/ aafmMultiCreate_t *  mediaArray,

    // optionally compressing it
    /*[in]*/ aafCompressEnable_t  Enable,

    // Optionally create the file HERE.
    /*[in]*/ IAAFLocator * destination,

    // with this format
    /*[in, ref]*/ aafUID_constref  fileFormat,

    // Return an essence access on the essence.
    /*[out]*/ IAAFEssenceMultiAccess**  access) PURE;


  //***********************************************************
  //
  // OpenEssence()
  //
  // Opens a single channel of a file mob.  If the essence is
  // interleaved, then it will be di-interleaved when samples are
  // read.  This routine follows the locator, and may call the locator
  // failure callback if the essence can not be found.  If the failure
  // callback finds the essence, then this routine will return
  // normally.
  // 
  // The essence handle from this call can be used with
  // ReadDataSamples  and possibly ReadDataLines, but NOT with
  // ReadMultiSamples.
  // 
  // NOTE: If a locator is followed, then essencePtr may reference
  // ANOTHER file object, which must be closed on file close.
  //
  STDMETHOD(OpenEssence) (THIS_
    // On this slot
    /*[in]*/ aafSlotID_t  slotID,

    // using this essence criteria
    /*[in]*/ aafMediaCriteria_t*  mediaCrit,

    // ReadOnly or Append
    /*[in]*/ aafMediaOpenMode_t  openMode,

    // optionally decompressing
    /*[in]*/ aafCompressEnable_t  compEnable,

    // Return an essence access on the essence.
    /*[out]*/ IAAFEssenceAccess ** access) PURE;
	

  //***********************************************************
  //
  // OpenMultiEssence()
  //
  // Opens a all channels associated with a file mob.  This routine
  // follows the locator, and may call the locator failure callback if
  // the essence can not be found.  If the failure callback finds the
  // essence, then this routine will return normally.
  //
  // The essence handle from this call can be used with
  // WriteMultiSamples but NOT with WriteDataSamples.
  //
  STDMETHOD(OpenMultiEssence) (THIS_
    // On this slot
    /*[in]*/ aafSlotID_t  slotID,

    // using this essence criteria
    /*[in]*/ aafMediaCriteria_t*  mediaCrit,

    // ReadOnly or Append
    /*[in]*/ aafMediaOpenMode_t  openMode,

    // optionally decompressing
    /*[in]*/ aafCompressEnable_t  compEnable,

    // Return an essence access on the essence.
    /*[out]*/ IAAFEssenceMultiAccess**  access) PURE;


  //***********************************************************
  //
  // CountChannels()
  //
  // Takes an opaque handle, a master mob reference, and a slot ID
  // so that it may be called before the essence is opened.
  //
  // Returns the number of interleaved essence channels of a given
  // type in the essence stream referenced by the given file mob.
  //
  // If the data format is not interleaved, then the answer will
  // always be zero or one.  This function correctly returns zero for
  // essence types not handled by a given codec, and handles codecs
  // which work with multiple essence types.
  //
  STDMETHOD(CountChannels) (THIS_
    // On this slot
    /*[in]*/ aafSlotID_t  slotID,

    // using this essence criteria
    /*[in]*/ aafMediaCriteria_t*  mediaCrit,

    // for this essence type
    /*[in]*/ IAAFDataDef * pMediaKind,

    // How many channels?
    /*[out]*/ aafUInt16*  numCh) PURE;




  END_INTERFACE
};
#endif // __IAAFMasterMob_INTERFACE_DEFINED__


// IAAFMetaDefinition

// ************************
//
// Interface IAAFMetaDefinition
//
// ************************





#ifndef __IAAFMetaDefinition_INTERFACE_DEFINED__
#define __IAAFMetaDefinition_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFMetaDefinition;

#undef  INTERFACE
#define INTERFACE   IAAFMetaDefinition

DECLARE_INTERFACE_(IAAFMetaDefinition, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFMetaDefinition methods *** */


  //***********************************************************
  //
  // Initialize()
  //
  // Init all fields of a meta definition object.
  //
  STDMETHOD(Initialize) (THIS_
    // AUID for new DeObject
    /*[in, ref]*/ aafUID_constref  id,

    // Name for new Meta Definition
    /*[in, string]*/ aafCharacter_constptr  pName,

    // the Description of this meta definition
    /*[in, string]*/ aafCharacter_constptr  pDescription) PURE;


  //***********************************************************
  //
  // GetAUID()
  //
  // Gets the AUID for this object.
  //
  STDMETHOD(GetAUID) (THIS_
    // Pointer to an AUID reference
    /*[retval,out]*/ aafUID_t *  pAuid) PURE;

  //***********************************************************
  //
  // SetName()
  //
  // Sets the Name of this definition.
  //
  // Set the Name property to the value specified in
  // pName.  A copy is made of the data so the caller
  // retains ownership of the *pName buffer and is
  // responsible for de-allocating it.  There is no pre-set limit to
  // the length of the name, other than available system memory or
  // disk space.
  // 
  // Succeeds if all of the following are true:
  // - the pName pointer is valid.
  // 
  // If this method fails the Name property will not be
  // changed.
  // 
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pName arg is NULL.
  //
  STDMETHOD(SetName) (THIS_
    // buffer from which Name is to be read
    /*[in, string]*/ aafCharacter_constptr  pName) PURE;


  //***********************************************************
  //
  // GetName()
  //
  // Gets the Name of this definition.
  // 
  // Writes the Name property, with a trailing null
  // character, into the pName buffer.  The
  // buffer is allocated by the caller.  The size of the buffer is
  // given by bufSize.  If the Name property has not yet
  // been set, a zero-length string will be written (that is,
  // only the trailing null character). 
  // 
  // Caller may call GetNameBufLen() to determine the
  // required buffer size.
  // 
  // If this method fails nothing will be written to
  // *pName.
  // 
  // Succeeds if:
  // - The pName pointer is valid.
  // - bufSize indicates that the buffer is large enough to hold
  //   Name.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pName arg is NULL.
  //
  // AAFRESULT_SMALL_BUF
  //   - bufSize indicates that the allocated buffer is not large
  //     enough to hold Name.
  //
  STDMETHOD(GetName) (THIS_
    // buffer into which Name is to be written
    /*[out, string, size_is(bufSize)]*/ aafCharacter *  pName,

    // size of *pName buffer in bytes
    /*[in]*/ aafUInt32  bufSize) PURE;


  //***********************************************************
  //
  // GetNameBufLen()
  //
  // Returns size of buffer (in bytes) required for GetName().
  // 
  // Succeeds if:
  // - The pBufSize pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pBufSize arg is NULL.
  //
  STDMETHOD(GetNameBufLen) (THIS_
    // size of required buffer, in bytes
    /*[out]*/ aafUInt32 *  pBufSize) PURE;

  //***********************************************************
  //
  // SetDescription()
  //
  // Sets the Description of this definition.
  //
  // Set the Description property to the value specified in
  // pDescription.  A copy is made of the data so the caller
  // retains ownership of the *pDescription buffer and is
  // responsible for de-allocating it.  There is no pre-set limit to
  // the length of the name, other than available system memory or
  // disk space.
  // 
  // Succeeds if all of the following are true:
  // - the pDescription pointer is valid.
  // 
  // If this method fails the Description property will not be
  // changed.
  // 
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pDescription arg is NULL.
  //
  STDMETHOD(SetDescription) (THIS_
    // buffer from which Description is to be read
    /*[in, string]*/ aafCharacter_constptr  pDescription) PURE;


  //***********************************************************
  //
  // GetDescription()
  //
  // Gets the Description of this definition.
  // 
  // Writes the Description property, with a trailing null
  // character, into the pDescription buffer.  The
  // buffer is allocated by the caller.  The size of the buffer is
  // given by bufSize.  If the Description property has not yet
  // been set, a zero-length string will be written (that is,
  // only the trailing null character). 
  // 
  // Caller may call GetDescriptionBufLen() to determine the
  // required buffer size.
  // 
  // If this method fails nothing will be written to
  // *pDescription.
  // 
  // Succeeds if:
  // - The pDescription pointer is valid.
  // - bufSize indicates that the buffer is large enough to hold
  //   Description.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pDescription arg is NULL.
  //
  // AAFRESULT_SMALL_BUF
  //   - bufSize indicates that the allocated buffer is not large
  //     enough to hold Description.
  //
  STDMETHOD(GetDescription) (THIS_
    // buffer into which Description is to be written
    /*[out, string, size_is(bufSize)]*/ aafCharacter *  pDescription,

    // size of *pDescription buffer in bytes
    /*[in]*/ aafUInt32  bufSize) PURE;


  //***********************************************************
  //
  // GetDescriptionBufLen()
  //
  // Returns size of buffer (in bytes) required for GetDescription().
  // 
  // Succeeds if:
  // - The pBufSize pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pBufSize arg is NULL.
  //
  STDMETHOD(GetDescriptionBufLen) (THIS_
    // size of required buffer, in bytes
    /*[out]*/ aafUInt32 *  pBufSize) PURE;


  END_INTERFACE
};
#endif // __IAAFMetaDefinition_INTERFACE_DEFINED__



// IAAFMob

// ************************
//
// Interface IAAFMob
//
// ************************












#ifndef __IAAFMob_INTERFACE_DEFINED__
#define __IAAFMob_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFMob;

#undef  INTERFACE
#define INTERFACE   IAAFMob

DECLARE_INTERFACE_(IAAFMob, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFMob methods *** */

  //***********************************************************
  //
  // GetMobID()
  //
  // This method returns the unique Mob ID associated with this mob.
  //
  // Succeeds if all of the following are true:
  // - the pMobID pointer is valid.
  // 
  // If this method fails nothing will be written to *pMobID.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pMobID arg is NULL.
  //
  STDMETHOD(GetMobID) (THIS_
    // The unique media object id
    /*[out]*/ aafMobID_t *  pMobID) PURE;


  //***********************************************************
  //
  // SetMobID()
  //
  // // When a mob is initially created, the Reference Implementation
  // internally creates a mobID for the new mob.  This method should
  // be used to change the mob's identity to an explicit mobID.
  // 
  // If this method fails no state will be changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  STDMETHOD(SetMobID) (THIS_
    // New Mob ID
    /*[in, ref]*/ aafMobID_constref  mobID) PURE;


  //***********************************************************
  //
  // SetName()
  //
  // Sets the Mob Name string property.
  //
  // Set the Name property to the value specified in
  // pName.  A copy is made of the data so the caller
  // retains ownership of the *pName buffer and is
  // responsible for de-allocating it.  There is no pre-set limit to
  // the length of the name, other than available system memory or
  // disk space.
  // 
  // Succeeds if all of the following are true:
  // - the pName pointer is valid.
  // 
  // If this method fails the Name property will not be
  // changed.
  // 
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pName arg is NULL.
  //
  STDMETHOD(SetName) (THIS_
    // buffer from which Name is to be read
    /*[in, string]*/ aafCharacter_constptr  pName) PURE;


  //***********************************************************
  //
  // GetName()
  //
  // Gets the Mob Name string property.
  // 
  // Writes the Name property, with a trailing null
  // character, into the pName buffer.  The
  // buffer is allocated by the caller.  The size of the buffer is
  // given by bufSize.  If the Name property has not yet
  // been set, a zero-length string will be written (that is,
  // only the trailing null character). 
  // 
  // Caller may call GetNameBufLen() to determine the
  // required buffer size.
  // 
  // If this method fails nothing will be written to
  // *pName.
  // 
  // Succeeds if:
  // - The pName pointer is valid.
  // - bufSize indicates that the buffer is large enough to hold
  //   Name.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pName arg is NULL.
  //
  // AAFRESULT_SMALL_BUF
  //   - bufSize indicates that the allocated buffer is not large
  //     enough to hold Name.
  //
  STDMETHOD(GetName) (THIS_
    // buffer into which Name is to be written
    /*[out, string, size_is(bufSize)]*/ aafCharacter *  pName,

    // size of *pName buffer in bytes
    /*[in]*/ aafUInt32  bufSize) PURE;


  //***********************************************************
  //
  // GetNameBufLen()
  //
  // Returns size of buffer (in bytes) required for GetName().
  // 
  // Succeeds if:
  // - The pBufSize pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pBufSize arg is NULL.
  //
  STDMETHOD(GetNameBufLen) (THIS_
    // size of required buffer, in bytes
    /*[out]*/ aafUInt32 *  pBufSize) PURE;


  //***********************************************************
  //
  // CountSlots()
  //
  // This method returns the number of slots contained by this mob.
  //
  // Succeeds if all of the following are true:
  // - the pNumSlots pointer is valid.
  // 
  // If this method fails nothing will be written to *pNumSlots.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pNumSlots arg is NULL.
  //
  STDMETHOD(CountSlots) (THIS_
    // Number of slots
    /*[out]*/ aafNumSlots_t *  pNumSlots) PURE;


  //***********************************************************
  //
  // AppendSlot()
  //
  // Appends the given mob slot to the mob.
  // 
  // NOTE! Stub only.   Implementation not yet added.
  //
  // Succeeds if all of the following are true:
  // - the pSlot pointer is valid.
  // 
  // If this method fails no state will be changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pSlot is null.
  //
  STDMETHOD(AppendSlot) (THIS_
    // slot to append
    /*[in]*/ IAAFMobSlot * pSlot) PURE;


  //***********************************************************
  //
  // PrependSlot()
  //
  // Prepends the given mob slot to the mob.
  // 
  // NOTE! Stub only.   Implementation not yet added.
  //
  // Succeeds if all of the following are true:
  // - the pSlot pointer is valid.
  // 
  // If this method fails no state will be changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pSlot is null.
  //
  STDMETHOD(PrependSlot) (THIS_
    // slot to prepend
    /*[in]*/ IAAFMobSlot * pSlot) PURE;


  //***********************************************************
  //
  // InsertSlotAt()
  //
  // Inserts the given slot into this mob at the given index.  All
  // existing slots at the given and higher index will be moved up one
  // index to accommodate.
  // 
  // NOTE! Stub only.   Implementation not yet added.
  //
  // Succeeds if all of the following are true:
  // - the pSlot pointer is valid.
  // - index is less than or equal to the result obtained by
  //   CountSlots().
  // 
  // If this method fails no state will be changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pSlot is null.
  //
  // AAFRESULT_BADINDEX
  //   - index is greater than the result obtained from CountSlots().
  //
  STDMETHOD(InsertSlotAt) (THIS_
    // index where slot is to be inserted
    /*[in]*/ aafUInt32  index,

    // slot to insert
    /*[in]*/ IAAFMobSlot * pSlot) PURE;


  //***********************************************************
  //
  // RemoveSlotAt()
  //
  // Removes the slot at the given index.  All existing slots at
  // indices higher than the given index will be moved down one index
  // to accommodate.
  // 
  // NOTE! Stub only.   Implementation not yet added.
  //
  // Succeeds if all of the following are true:
  // - index is less than the result obtained by CountSlots().
  // 
  // If this method fails no state will be changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_BADINDEX
  //   - index is not less than the result obtained from
  //     CountSlots().
  //
  STDMETHOD(RemoveSlotAt) (THIS_
    // index of slot to be removed
    /*[in]*/ aafUInt32  index) PURE;


  //***********************************************************
  //
  // GetSlotAt()
  //
  // Returns the indexed slot in *ppSlot.
  // 
  // NOTE! Stub only.   Implementation not yet added.
  //
  // Succeeds if all of the following are true:
  // - ppSlot is a valid pointer.
  // - index is less than the result obtained by CountSlots().
  // 
  // If this method fails no state will be changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppSlot is null.
  //
  // AAFRESULT_BADINDEX
  //   - index is not less than the result obtained from
  //     CountSlots().
  //
  STDMETHOD(GetSlotAt) (THIS_
    // index of slot to be obtained
    /*[in]*/ aafUInt32  index,

    // the returned slot
    /*[out, retval]*/ IAAFMobSlot ** ppSlot) PURE;


  //***********************************************************
  //
  // GetSlots()
  //
  // return an enumeration for all mob slots.  The returned
  // enumerator is AddRef()ed before it is returned.
  // 
  // Succeeds if all of the following are true:
  // - the ppEnum pointer is valid.
  // 
  // If this method fails nothing will be written to *ppEnum.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppEnum is null.
  //
  STDMETHOD(GetSlots) (THIS_
    // Mob Slot Enumeration
    /*[out]*/ IEnumAAFMobSlots ** ppEnum) PURE;


  //***********************************************************
  //
  // GetModTime()
  //
  // This method will return the modification time for this mob.
  //
  // Succeeds if all of the following are true:
  // - the pLastModified pointer is valid.
  // 
  // If this method fails nothing will be written to *pLastModified.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pLastModified arg is NULL.
  //
  STDMETHOD(GetModTime) (THIS_
    // Modified Time
    /*[out]*/ aafTimeStamp_t *  pLastModified) PURE;


  //***********************************************************
  //
  // SetModTime()
  //
  // This method sets the modification time on a mob.  The
  // modification time is initially set to the time that the mob
  // was created.  The Reference Implementation does not maintain the
  // modification time every time that a mob has been updated.
  // Therefore, this method should be called explicitly to change the
  // modification time.
  // 
  // If this method fails no state will be changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  STDMETHOD(SetModTime) (THIS_
    // New Modification Time
    /*[in, ref]*/ aafTimeStamp_constref  modTime) PURE;


  //***********************************************************
  //
  // GetCreateTime()
  //
  // This method will return the creation time for this mob.
  //
  // Succeeds if all of the following are true:
  // - the pCreationTime pointer is valid.
  // 
  // If this method fails nothing will be written to *pCreationTime.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pCreationTime arg is NULL.
  //
  STDMETHOD(GetCreateTime) (THIS_
    // Creation Time
    /*[out]*/ aafTimeStamp_t *  pCreationTime) PURE;


  //***********************************************************
  //
  // SetCreateTime()
  //
  // This method sets the creation time on a mob.  The
  // creation time is initially set to the time that the mob
  // was created.
  // Therefore, this method should be called explicitly to change the
  // creation time.
  // 
  // If this method fails no state will be changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  STDMETHOD(SetCreateTime) (THIS_
    // New Creation Time
    /*[in, ref]*/ aafTimeStamp_constref  createTime) PURE;


  //***********************************************************
  //
  // AppendComment()
  //
  // Creates a user-defined comment and appends it to the specified
  // Mob.  A Mob comment is implemented as a AAFTaggedValue object of type 
  // WCharString.
  // 
  // Succeeds if all of the following are true:
  // - the pCategory pointer is valid.
  // - the pComment pointer is valid.
  // 
  // If this method fails no state will be changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - either pCategory or pComment args is NULL.
  //
  STDMETHOD(AppendComment) (THIS_
    // Comment heading
    /*[in,string]*/ aafCharacter *  pCategory,

    // Comment value
    /*[in, string]*/ aafCharacter_constptr  pComment) PURE;


  //***********************************************************
  //
  // CountComments()
  //
  // return total number of comments attached to this mob.
  //
  // Succeeds if all of the following are true:
  // - the pNumComments pointer is valid.
  // 
  // If this method fails nothing will be written to *pNumComments.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pNumComments arg is NULL.
  //
  STDMETHOD(CountComments) (THIS_
    // Number  of Mob Comments
    /*[out]*/ aafUInt32 *  pNumComments) PURE;


  //***********************************************************
  //
  // GetComments()
  //
  // return the enumeration for all mob comments.  The returned
  // enumerator is AddRef()ed before it is returned.  Mob comments are 
  // implemented as AAFTaggedValue of type WCharString.   The enumerator
  // is implemented as a EnumAAAFTaggedValues.
  // 
  // Succeeds if all of the following are true:
  // - the ppEnum pointer is valid.
  // 
  // If this method fails nothing will be written to *ppEnum.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppEnum is null.
  //
  STDMETHOD(GetComments) (THIS_
    // Mob Comments
    /*[out]*/ IEnumAAFTaggedValues ** ppEnum) PURE;


  //***********************************************************
  //
  // RemoveComment()
  //
  // // Removes the given comment from this mob.
  // 
  // Succeeds if all of the following are true:
  // - the pComment pointer is valid.
  // - the given comment is present in the mob.
  // 
  // If this method fails no state will be changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pComment is null.
  //
  // AAFRESULT_OBJECT_NOT_FOUND
  //   - the given comment is not in this mob.
  //
  STDMETHOD(RemoveComment) (THIS_
    // Comment to remove
    /*[in]*/ IAAFTaggedValue * pComment) PURE;


  //***********************************************************
  //
  // AppendNewTimelineSlot()
  //
  // This method creates a new timeline mob slot with the given
  // property values and appends it to the input mob.
  // 
  // The returned mob slot is AddRef()ed before it is returned.
  //
  // Succeeds if all of the following are true:
  // - the pSegment pointer is valid.
  // - the pSlotName pointer is valid.
  // - the ppNewSlot pointer is valid.
  // 
  // If this method fails no state will be changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - any of pSegment, pSlotName, or ppNewSlot arguments is null.
  //
  STDMETHOD(AppendNewTimelineSlot) (THIS_
    // Edit rate property value
    /*[in]*/ aafRational_t  editRate,

    // Segment to append as slot component
    /*[in]*/ IAAFSegment * pSegment,

    // new slot ID
    /*[in]*/ aafSlotID_t  slotID,

    // new slot name
    /*[in, string]*/ aafCharacter_constptr  pSlotName,

    // The slot origin
    /*[in]*/ aafPosition_t  origin,

    // Newly created slot
    /*[out]*/ IAAFTimelineMobSlot ** ppNewSlot) PURE;


  //***********************************************************
  //
  // GetMobInfo()
  //
  // This method will get all mob property information is a single call.
  //
  // Caller may call GetNameBufLen() to determine the required pName
  // buffer size.
  // 
  // NOTE! Stub only.   Implementation not yet added.
  //
  // Succeeds if all of the following are true:
  // - the pLastModified pointer is valid.
  // - the pCreationTime pointer is valid.
  // - the pName pointer is valid.
  // 
  // If this method fails nothing will be written to *pLastModified,
  // *pCreationTime, or *pName.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - any of pLastModified, pCreationTime, or pName arguments is NULL.
  //
  // AAFRESULT_SMALLBUF
  //   - bufSize indicates the buffer is too small to hold the string.
  //
  STDMETHOD(GetMobInfo) (THIS_
    // Modified Time
    /*[out]*/ aafTimeStamp_t *  pLastModified,

    // Creation Time
    /*[out]*/ aafTimeStamp_t *  pCreationTime,

    // Mob Name
    /*[out, size_is(bufSize), string]*/ aafCharacter *  pName,

    // size of the supplied buffer.
    /*[in]*/ aafInt32  bufSize) PURE;


  //***********************************************************
  //
  // OffsetToMobTimecode()
  //
  // This method will determine the timecode at the given offset into
  // the given timecode segment, and will return it in *pResult.  If
  // pTcSeg is NULL, will search for the slot containing a timecode
  // segment and will use that instead.
  //
  // NOTE! Stub only.   Implementation not yet added.
  //
  // Succeeds if all of the following are true:
  // - the pTcSeg pointer is valid.
  // - the pOffset pointer is valid.
  // - the pResult pointer is valid.
  // - Timecode track exists.
  // 
  // If this method fails nothing will be written to *pResult.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - either pOffset or pResult argument is NULL.
  //
  // AAFRESULT_TIMECODE_NOT_FOUND
  //   - timecode track wasn't found.
  //
  STDMETHOD(OffsetToMobTimecode) (THIS_
    // Timecode Segment
    /*[in]*/ IAAFSegment * pTcSeg,

    // Offset into segment in edit units for that segment's mob slot
    /*[in]*/ aafPosition_t *  pOffset,

    // The resulting timecode
    /*[out]*/ aafTimecode_t *  pResult) PURE;


  //***********************************************************
  //
  // LookupSlot()
  //
  // The method will find the mob slot for the given slot id.
  //
  // The returned mob slot is AddRef()ed before it is returned.
  //
  // Succeeds if all of the following are true:
  // - the ppDestSlot pointer is valid.
  // - the given slot ID is found.
  // 
  // If this method fails nothing will be written to *ppDestSlot.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppDestSlot arg is NULL.
  //
  STDMETHOD(LookupSlot) (THIS_
    // The requested slot id
    /*[in]*/ aafSlotID_t  slotId,

    // The requested slot
    /*[out]*/ IAAFMobSlot ** ppDestSlot) PURE;


  //***********************************************************
  //
  // ChangeRef()
  //
  // Finds all Source Clips in the specified Mob that refer to the
  // specified old Mob, and changes the references to point to the
  // new Mob.
  //
  // This function traverses through the entire structure of the input
  // Mob looking for Source Clips, and changes the sourceID property
  // on all Source Clips with oldMobID to newMobID.
  //
  // NOTE! Stub only.   Implementation not yet added.
  //
  // If this method fails no state will be changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  STDMETHOD(ChangeRef) (THIS_
    // Old Mob ID reference in source clip
    /*[in, ref]*/ aafMobID_constref  oldMobID,

    // New Mob ID reference in source clip
    /*[in, ref]*/ aafMobID_constref  newMobID) PURE;


  //***********************************************************
  //
  // CloneExternal()
  //
  // Clones the specified Source Mob, and optionally all dependent
  // Mobs, to an external file, keeping the same MobID.  A pointer
  // to the newly created destination mob is returned in *ppDestMob.
  // 
  // This function clones the specified Source Mob in the source file
  // into a destination Mob, with the same MobID, in the destination
  // file.  If resolveDependencies is kFollowDepend, the function
  // also clones all Mobs referenced by the specified Source Mob.  If
  // includeMedia is kIncludeMedia, the function also copies the
  // media data associated with the Source Mob, returns the
  // destination Mob, and clones all private data.
  //
  // If the media data is not in the file, the function does not
  // attempt to find it in another file and clone it.  Both AAF files
  // must be open before you call this function and both must have the
  // same AAF Version number.
  //
  // The returned mob is AddRef()ed before it is returned.
  //
  // NOTE! Stub only.   Implementation not yet added.
  //
  // Succeeds if all of the following are true:
  // - the pDestFile pointer is valid.
  // - the ppDestMob pointer is valid.
  // 
  // If this method fails no state will be changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - either pDestFile or ppDestMob arguments is NULL.
  //
  STDMETHOD(CloneExternal) (THIS_
    // Whether to clone dependent mobs
    /*[in]*/ aafDepend_t  resolveDependencies,

    // Whether to include media data
    /*[in]*/ aafIncMedia_t  includeMedia,

    // Destination AAF File
    /*[in]*/ IAAFFile * pDestFile,

    // Destination Mob
    /*[out]*/ IAAFMob ** ppDestMob) PURE;


  //***********************************************************
  //
  // Copy()
  //
  // This function copies the specified Mob into a destination Mob in
  // the same AAF file. The new Mob is returned through the destMob
  // parameter. The function gives the destination Mob a new MobID and
  // the name specified in the destMobName parameter. The function
  // also copies all private data.
  // 
  // The returned mob is AddRef()ed before it is returned.
  //
  // NOTE! Stub only.   Implementation not yet added.
  //
  // Succeeds if all of the following are true:
  // - the pDestMobName pointer is valid.
  // - the ppDestMob pointer is valid.
  // 
  // If this method fails no state will be changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - either pDestMobName or pDestMob arguments is NULL.
  //
  STDMETHOD(Copy) (THIS_
    // Optional Input. The name to be assigned to the new copy of the
	// Mob.  The destMobName argument is optional. Specify a NULL
	// value if no destination Mob name is desired.
    /*[in, string]*/ aafCharacter_constptr  pDestMobName,

    // Destination Mob
    /*[out]*/ IAAFMob ** ppDestMob) PURE;

  //***********************************************************
  //
  // AppendKLVData()
  //
  // Appends a pre-existing KLV Data object to the specified
  // Mob.
  // 
  // Succeeds if all of the following are true:
  // - the pKLV pointer is valid.
  // 
  // If this method fails no state will be changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - the pData arg is NULL.
  //
  STDMETHOD(AppendKLVData) (THIS_
    // KLV object
    /*[in]*/ IAAFKLVData * pData) PURE;


  //***********************************************************
  //
  // CountKLVData()
  //
  // return total number of KLV data objects attached to this mob.
  //
  // Succeeds if all of the following are true:
  // - the pNumData pointer is valid.
  // 
  // If this method fails nothing will be written to *pNumComments.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pNumData arg is NULL.
  //
  STDMETHOD(CountKLVData) (THIS_
    // Number  of KLV data objects
    /*[out]*/ aafUInt32 *  pNumData) PURE;


  //***********************************************************
  //
  // GetKLVData()
  //
  // return the enumeration for all KLV data objects on this mob.  The returned
  // enumerator is AddRef()ed before it is returned.  The enumerator
  // is implemented as a EnumAAFKLVData.
  // 
  // Succeeds if all of the following are true:
  // - the ppEnum pointer is valid.
  // 
  // If this method fails nothing will be written to *ppEnum.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppEnum is null.
  //
  STDMETHOD(GetKLVData) (THIS_
    // KLV data objects
    /*[out]*/ IEnumAAFKLVData ** ppEnum) PURE;


  //***********************************************************
  //
  // RemoveKLVData()
  //
  // // Removes the given KLV data object from this mob.
  // 
  // Succeeds if all of the following are true:
  // - the pData pointer is valid.
  // - the given KLV data object is present in the mob.
  // 
  // If this method fails no state will be changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pData is null.
  //
  // AAFRESULT_OBJECT_NOT_FOUND
  //   - the given KLV data object is not in this mob.
  //
  STDMETHOD(RemoveKLVData) (THIS_
    // KLV data object to remove
    /*[in]*/ IAAFKLVData * pData) PURE;

  END_INTERFACE
};
#endif // __IAAFMob_INTERFACE_DEFINED__



// IAAFMobSlot

// ************************
//
// Interface IAAFMobSlot
//
// ************************





#ifndef __IAAFMobSlot_INTERFACE_DEFINED__
#define __IAAFMobSlot_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFMobSlot;

#undef  INTERFACE
#define INTERFACE   IAAFMobSlot

DECLARE_INTERFACE_(IAAFMobSlot, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFMobSlot methods *** */

  //***********************************************************
  //
  // GetSegment()
  //
  // This method will get the segment for this mob slot and place an
  // interface for it into the **ppResult argument.  If a segment
  // exists, the result will be AddRef()ed.  If not, the result will
  // be NULL.
  //
  // Succeeds if all of the following are true:
  // - the pResult pointer is valid.
  // 
  // If this method fails nothing will be written to *pResult.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pResult arg is NULL.
  //
  STDMETHOD(GetSegment) (THIS_
    // Segment property value
    /*[out,retval]*/ IAAFSegment ** ppResult) PURE;


  //***********************************************************
  //
  // SetName()
  //
  // Sets the Mob Slot Name string property.
  //
  // Set the Name property to the value specified in
  // pName.  A copy is made of the data so the caller
  // retains ownership of the *pName buffer and is
  // responsible for de-allocating it.  There is no pre-set limit to
  // the length of the name, other than available system memory or
  // disk space.
  // 
  // Succeeds if all of the following are true:
  // - the pName pointer is valid.
  // 
  // If this method fails the Name property will not be
  // changed.
  // 
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pName arg is NULL.
  //
  STDMETHOD(SetName) (THIS_
    // buffer from which Name is to be read
    /*[in, string]*/ aafCharacter_constptr  pName) PURE;


  //***********************************************************
  //
  // GetName()
  //
  // Gets the Mob Slot Name string property.
  // 
  // Writes the Name property, with a trailing null
  // character, into the pName buffer.  The
  // buffer is allocated by the caller.  The size of the buffer is
  // given by bufSize.  If the Name property has not yet
  // been set, a zero-length string will be written (that is,
  // only the trailing null character). 
  // 
  // Caller may call GetNameBufLen() to determine the
  // required buffer size.
  // 
  // If this method fails nothing will be written to
  // *pName.
  // 
  // Succeeds if:
  // - The pName pointer is valid.
  // - bufSize indicates that the buffer is large enough to hold
  //   Name.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pName arg is NULL.
  //
  // AAFRESULT_SMALL_BUF
  //   - bufSize indicates that the allocated buffer is not large
  //     enough to hold Name.
  //
  STDMETHOD(GetName) (THIS_
    // buffer into which Name is to be written
    /*[out, string, size_is(bufSize)]*/ aafCharacter *  pName,

    // size of *pName buffer in bytes
    /*[in]*/ aafUInt32  bufSize) PURE;


  //***********************************************************
  //
  // GetNameBufLen()
  //
  // Returns size of buffer (in bytes) required for GetName().
  // 
  // Succeeds if:
  // - The pBufSize pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pBufSize arg is NULL.
  //
  STDMETHOD(GetNameBufLen) (THIS_
    // size of required buffer, in bytes
    /*[out]*/ aafUInt32 *  pBufSize) PURE;


  //***********************************************************
  //
  // GetPhysicalNum()
  //
  // Returns information about the physical output channel associated
  // with the  Slot.
  //
  // This function returns the physical slot number of the specified
  // slot. The physical slot number identifies the physical slot
  // associated with the media.  For File Source Mobs that describe
  // stereo audio media, the left channel should have a PhysicalSlot
  // of 1 and the right channel should have a Physical-Slot of 2.
  //
  // The function returns an error if the object specified in the slot
  // parameter is not a slot.
  //
  // Succeeds if all of the following are true:
  // - the pDatadef pointer is valid.
  // - the object in the slot parameter is a slot.
  // 
  // If this method fails nothing will be written to *pResult.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pDatadef arg is NULL.
  //
  // AAFRESULT_SLOT_NOT_FOUND
  //   - object specified is not a slot.
  //
  STDMETHOD(GetPhysicalNum) (THIS_
    // The physical slot number property value
    /*[out,retval]*/ aafUInt32 *  pResult) PURE;


  //***********************************************************
  //
  // GetDataDef()
  //
  // This method will return the Data Definition object
  // associated with the segment in this Mob Slot.  Common
  // DataDefinitions are DDEF_Picture, DDEF_Sound, DDEF_Timecode,
  // and DDEF_Edgecode.
  //
  // Succeeds if all of the following are true:
  // - the ppResult pointer is valid.
  // 
  // If this method fails nothing will be written to *ppResult.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppResult arg is NULL.
  //
  STDMETHOD(GetDataDef) (THIS_
    // Data Definition AUID
    /*[out,retval]*/ IAAFDataDef ** ppResult) PURE;


  //***********************************************************
  //
  // GetSlotID()
  //
  // This method will return the slot id of this mob slot.
  //
  // Succeeds if all of the following are true:
  // - the pResult pointer is valid.
  // 
  // If this method fails nothing will be written to *pResult.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pResult arg is NULL.
  //
  STDMETHOD(GetSlotID) (THIS_
    // Slot id of the Mob Slot
    /*[out,retval]*/ aafSlotID_t *  pResult) PURE;


  //***********************************************************
  //
  // SetSegment()
  //
  // This method will set the segment for this mob slot.  If a segment
  // already exists for this mob slot, it will be discarded.
  // 
  // Always succeeds.
  // 
  // If this method fails no state will be changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  STDMETHOD(SetSegment) (THIS_
    // Segment property value
    /*[in]*/ IAAFSegment * pSegment) PURE;


  //***********************************************************
  //
  // SetPhysicalNum()
  //
  // // This function sets the physical slot number of the specified
  // slot.  The physical slot number identifies the physical slot
  // associated with the media.  For File Source Mobs that describe
  // stereo audio media, the left channel should have a PhysicalSlot
  // of 1 and the right channel should have a Physical-Slot of 2.
  //
  // The function returns an error if the Mob Slot passed in is not a
  // slot.
  // 
  // Succeeds if all of the following are true:
  // - the Mob Slot passed in is a slot.
  // 
  // If this method fails no state will be changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.
  //
  // AAFRESULT_SLOT_NOT_FOUND
  //   - object specified is not a slot.
  //
  STDMETHOD(SetPhysicalNum) (THIS_
    // The physical slot number property value
    /*[in]*/ aafUInt32  number) PURE;


  //***********************************************************
  //
  // SetSlotID()
  //
  // This method will set the slot id of this mob slot.
  // 
  // Always succeeds.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  STDMETHOD(SetSlotID) (THIS_
    // Slot id of the Mob Slot
    /*[in]*/ aafSlotID_t  value) PURE;

  END_INTERFACE
};
#endif // __IAAFMobSlot_INTERFACE_DEFINED__



// IAAFNestedScope

// ************************
//
// Interface IAAFNestedScope
//
// ************************






#ifndef __IAAFNestedScope_INTERFACE_DEFINED__
#define __IAAFNestedScope_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFNestedScope;

#undef  INTERFACE
#define INTERFACE   IAAFNestedScope

DECLARE_INTERFACE_(IAAFNestedScope, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFNestedScope methods *** */

  //***********************************************************
  //
  // AppendSegment()
  //
  // Append another input segment to the list of source segments.  The
  // last segment added will be used as the output of the nested
  // scope, and usually contains operations whose inputs are scope
  // references.
  // 
  // Succeeds if all of the following are true:
  // - the pSegment pointer is valid.
  // 
  // If this method fails no state will be changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pSegment is null.
  //
  STDMETHOD(AppendSegment) (THIS_
    // Pointer to segment to be added
    /*[in]*/ IAAFSegment * pSegment) PURE;


  //***********************************************************
  //
  // PrependSegment()
  //
  // Prepend another input segment to the list of source segments.
  // 
  // Succeeds if all of the following are true:
  // - the pSegment pointer is valid.
  // 
  // If this method fails no state will be changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pSegment is null.
  //
  STDMETHOD(PrependSegment) (THIS_
    // Pointer to segment to be added
    /*[in]*/ IAAFSegment * pSegment) PURE;


  //***********************************************************
  //
  // InsertSegmentAt()
  //
  // Insert an input segment to the list of source segments at the
  // given index.  Segments already existing at the given and higher
  // indices will be moved up one index to accommodate.
  // 
  // Succeeds if all of the following are true:
  // - the pSegment pointer is valid.
  // - index is less than or equal to the value returned by
  //   CountSegments().
  // 
  // If this method fails no state will be changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pSegment is null.
  //
  // AAFRESULT_BADINDEX
  //   - index is greater than the value returned by
  //     CountSegments().
  //
  STDMETHOD(InsertSegmentAt) (THIS_
    // index where segment is to be inserted
    /*[in]*/ aafUInt32  index,

    // Pointer to segment to be added
    /*[in]*/ IAAFSegment * pSegment) PURE;


  //***********************************************************
  //
  // RemoveSegmentAt()
  //
  // Removes the indexed segment.  Segments already existing at
  // indices greater than the given index will be moved down by one
  // index to accommodate.
  // 
  // Succeeds if all of the following are true:
  // - the pSegment pointer is valid.
  // - index is less than the value returned by CountSegments().
  // 
  // If this method fails no state will be changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pSegment is null.
  //
  // AAFRESULT_BADINDEX
  //   - index is greater than or equal to the value returned by
  //     CountSegments().
  //
  STDMETHOD(RemoveSegmentAt) (THIS_
    // index of segment to be removed
    /*[in]*/ aafUInt32  index) PURE;


  //***********************************************************
  //
  // CountSegments()
  //
  // Returns the number of source segments currently contained.
  // 
  // Succeeds if all of the following are true:
  // - the pResult pointer is valid.
  // 
  // If this method fails no value will be written to *pResult.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pResult is null.
  //
  STDMETHOD(CountSegments) (THIS_
    // number of segments contained
    /*[out, retval]*/ aafUInt32 *  pResult) PURE;


  //***********************************************************
  //
  // GetSegmentAt()
  //
  // Retrieves the indexed segment.
  // 
  // Succeeds if all of the following are true:
  // - the ppEnum pointer is valid.
  // - index is less than the value returned by CountSegments().
  // 
  // If this method fails nothing will be written to *ppSegment.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppEnum is null.
  //
  // AAFRESULT_BADINDEX
  //   - index is greater than or equal to the value returned by
  //     CountSegments().
  //
  STDMETHOD(GetSegmentAt) (THIS_
    // index of segment to retrieve
    /*[in]*/ aafUInt32  index,

    // retrieved segment
    /*[out, retval]*/ IAAFSegment ** ppSegment) PURE;


  //***********************************************************
  //
  // GetSegments()
  //
  // Return an enumerator for the ordered list of AAFSegments which
  // make up the nested scope.
  // 
  // Succeeds if all of the following are true:
  // - the ppEnum pointer is valid.
  // 
  // If this method fails nothing will be written to *ppEnum.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppEnum is null.
  //
  STDMETHOD(GetSegments) (THIS_
    // Slots - segment list  enumeration
    /*[out, retval]*/ IEnumAAFSegments ** ppEnum) PURE;

  END_INTERFACE
};
#endif // __IAAFNestedScope_INTERFACE_DEFINED__



// IAAFNetworkLocator

// ************************
//
// Interface IAAFNetworkLocator
//
// ************************



#ifndef __IAAFNetworkLocator_INTERFACE_DEFINED__
#define __IAAFNetworkLocator_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFNetworkLocator;

#undef  INTERFACE
#define INTERFACE   IAAFNetworkLocator

DECLARE_INTERFACE_(IAAFNetworkLocator, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFNetworkLocator methods *** */

  //***********************************************************
  //
  // Initialize()
  //
  // Initializes a newly allocated, empty
  // IAAFNetworkLocator-supporting object.  This method must be called
  // after allocation, and before any other method can be called.
  //
  // Succeeds if:
  // - Initialize() has not yet been called on this object.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_ALREADY_INITIALIZED
  //   - Initialize() has already been called on this object.
  STDMETHOD(Initialize) (THIS) PURE;










  END_INTERFACE
};
#endif // __IAAFNetworkLocator_INTERFACE_DEFINED__



// IAAFObject

// ************************
//
// Interface IAAFObject
//
// ************************











#ifndef __IAAFObject_INTERFACE_DEFINED__
#define __IAAFObject_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFObject;

#undef  INTERFACE
#define INTERFACE   IAAFObject

DECLARE_INTERFACE_(IAAFObject, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFObject methods *** */

  //***********************************************************
  //
  // GetGeneration()
  //
  // Gets the generation of this object, which is represented by an
  // AAFIdentification object.  This is used to detect when an object
  // has been modified.
  //
  // This method will succeed if generation tracking is enabled for
  // this object.  Call EnableGenerationTrackint() and
  // DisableGenerationTrackint() to control generation tracking for
  // this object.  Call IsGenerationTracked() to determine if
  // generation tracking is currently enabled for this object.
  //
  // Succeeds if all of the following are true:
  // - the given pGeneration pointer is valid.
  // - generation tracking is enabled for this object.
  // - this object is attached to a file.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppGeneration arg is NULL.
  //
  // AAFRESULT_INVALID_PARAM
  //   - Generation tracking is not enabled for this object.
  //
  // AAFRESULT_OBJECT_NOT_ATTACHED
  //   - This object is not attached to a file from which generation
  //     information can be obtained..
  //
  STDMETHOD(GetGeneration) (THIS_
    // AAFIdentification object corresponding to this object's
    // Generation ID
    /*[out]*/ IAAFIdentification ** ppGeneration) PURE;


  //***********************************************************
  //
  // GetGenerationAUID()
  //
  // Shortcut to get the AUID representing the Identification
  // representing this object's generation.  (Can also be obtained by
  // calling this->GetGeneration(&pIdent), and using its result to
  // call pIdent->GetAuid()).
  //
  // This method will succeed if generation tracking is enabled for
  // this object.  Call EnableGenerationTrackint() and
  // DisableGenerationTrackint() to control generation tracking for
  // this object.  Call IsGenerationTracked() to determine if
  // generation tracking is currently enabled for this object.
  //
  // Succeeds if all of the following are true:
  // - the given pResult pointer is valid.
  // - generation tracking is enabled for this object.
  // - this object is attached to a file.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pResult arg is NULL.
  //
  // AAFRESULT_INVALID_PARAM
  //   - Generation tracking is not enabled for this object.
  //
  // AAFRESULT_OBJECT_NOT_ATTACHED
  //   - This object is not attached to a file from which generation
  //     information can be obtained..
  //
  STDMETHOD(GetGenerationAUID) (THIS_
    // AUID corresponding to this object's Generation ID
    /*[out]*/ aafUID_t *  pResult) PURE;


  //***********************************************************
  //
  // GetDefinition()
  //
  // Returns the class definition which describes this object
  // instance.
  //
  // Succeeds if all of the following are true:
  // - the given ppClassDef pointer is valid.
  //
  // Note! Use care when dealing with the object class.  Among the
  // pitfalls to be avoided is that tests for equality will not
  // reflect inheritance.  This becomes important if an unknown
  // non-builtin (that is, user defined) object class ID is obtained.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppClassDef arg is NULL.
  //
  STDMETHOD(GetDefinition) (THIS_
    // class definition of which this object is an instance.
    /*[out]*/ IAAFClassDef ** ppClassDef) PURE;


  //***********************************************************
  //
  // GetProperties()
  //
  // Returns an enumerator across all properties actually contained in
  // this object.  Each property is represented by an IAAFProperty
  // interface.
  // 
    // *ppEnum is AddRef()ed before it is returned.
  // 
  // Succeeds if all of the following are true:
  // - the ppEnum pointer is valid.
  // 
  // If this method fails nothing will be written to *ppEnum.
  // 
  // Note! This is a low-level method which allows direct access to
  // properties.  If such access is done, any semantic checking (such
  // as that which is performed in all other named property Get/Set
  // methods) is not done here.  Users must use this method at their
  // own risk.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppEnum arg is NULL.
  //
  STDMETHOD(GetProperties) (THIS_
    // Property Enumeration
    /*[out, retval]*/ IEnumAAFProperties ** ppEnum) PURE;


  //***********************************************************
  //
  // CountProperties()
  //
  // Returns the number of properties currently present in this
  // object.  This is the same number as will be accessed through
  // GetProperties().
  // 
  // Note! This is a low-level method which allows direct access to
  // properties.  If such access is done, any semantic checking (such
  // as that which is performed in all other named property Get/Set
  // methods) is not done here.  Users must use this method at their
  // own risk.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pCount arg is NULL.
  //
  STDMETHOD(CountProperties) (THIS_
    // count of properties present in this object
    /*[out]*/ aafUInt32 *  pCount) PURE;


  //***********************************************************
  //
  // GetPropertyValue()
  //
  // Returns the requested Property Value.  The desired property data
  // is identified by the given property definition.
  // 
  // Note! This is a low-level method which allows direct access to
  // properties.  If such access is done, any semantic checking (such
  // as that which is performed in all other named property Get/Set
  // methods) is not done here.  Users must use this method at their
  // own risk.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pPropDef or ppPropVal arg is NULL.
  //
  // AAFRESULT_ILLEGAL_PROPERTY
  //   - named property illegal for this object's class.
  //
  // AAFRESULT_PROP_NOT_PRESENT
  //   - named property is optional, but not present in this class.
  //
  STDMETHOD(GetPropertyValue) (THIS_
    // property definition indentifying desired property
    /*[in]*/ IAAFPropertyDef * pPropDef,

    // returned AAFPropertyValue
    /*[out]*/ IAAFPropertyValue ** ppPropVal) PURE;


  //***********************************************************
  //
  // SetPropertyValue()
  //
  // Sets the value of the given property to the given value.  If the
  // selected property is optional but not yet present, will make the
  // property present before setting its value.
  //
  // Note! This is a low-level method which allows direct access to
  // properties.  If such access is done, any semantic checking (such
  // as that which is performed in all other named property Get/Set
  // methods) is not done here.  Users must use this method at their
  // own risk.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pPropDef or ppPropVal arg is NULL.
  //
  // AAFRESULT_ILLEGAL_PROPERTY
  //   - named property illegal for this object's class.
  //
  // AAFRESULT_PROP_NOT_PRESENT
  //   - named property is optional, but not present in this class.
  //
  STDMETHOD(SetPropertyValue) (THIS_
    // property definition indentifying desired property
    /*[in]*/ IAAFPropertyDef * pPropDef,

    // value to set.
    /*[in]*/ IAAFPropertyValue * pPropVal) PURE;


  //***********************************************************
  //
  // IsPropertyPresent()
  //
  // Sets *pResultReturns true in if named property is legal and is
  // present; sets it to false if it is legal and is absent.
  // 
  // Note! This is a low-level method which allows direct access to
  // properties.  If such access is done, any semantic checking (such
  // as that which is performed in all other named property Get/Set
  // methods) is not done here.  Users must use this method at their
  // own risk.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pResult arg is NULL.
  //
  // AAFRESULT_ILLEGAL_PROPERTY
  //   - named property illegal for this object's class.
  //
  STDMETHOD(IsPropertyPresent) (THIS_
    // property definition indentifying desired property
    /*[in]*/ IAAFPropertyDef * pPropDef,

    // true if present; false if not present
    /*[out]*/ aafBoolean_t*  pResult) PURE;


  //***********************************************************
  //
  // RemoveOptionalProperty()
  //
  // Removes the property if named property is legal and is
  // optional and present.
  // 
  // Note! This is a low-level method which allows direct access to
  // properties.  If such access is done, any semantic checking (such
  // as that which is performed in all other named property Get/Set
  // methods) is not done here.  Users must use this method at their
  // own risk.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pResult arg is NULL.
  //
  // AAFRESULT_ILLEGAL_PROPERTY
  //   - named property illegal for this object's class.
  //
  STDMETHOD(RemoveOptionalProperty) (THIS_
    // property definition indentifying desired property
    /*[in]*/ IAAFPropertyDef * pPropDef) PURE;


  //***********************************************************
  //
  // CreateOptionalPropertyValue()
  //
  // Returns the requested Property Value.  The desired property data
  // is identified by the given optional property definition.
  // 
  // Note! This is a low-level method which allows direct access to
  // properties.  If such access is done, any semantic checking (such
  // as that which is performed in all other named property Get/Set
  // methods) is not done here.  Users must use this method at their
  // own risk.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pPropDef or ppPropVal arg is NULL.
  //
  // AAFRESULT_ILLEGAL_PROPERTY
  //   - named property illegal for this object's class.
  //
  // AAFRESULT_PROP_ALREADY_PRESENT
  //   - named property is optional, but already present in this class.
  //
  STDMETHOD(CreateOptionalPropertyValue) (THIS_
    // property definition indentifying desired property
    /*[in]*/ IAAFPropertyDef * pPropDef,

    // returned AAFPropertyValue
    /*[out]*/ IAAFPropertyValue ** ppPropVal) PURE;


  //***********************************************************
  //
  // GetDictionary()
  //
  // Returns the dictionary for this object instance.
  //
  // Succeeds if all of the following are true:
  // - the given ppDictionary pointer is valid.
  //
  // Note! Use care when dealing with the object class.  Among the
  // pitfalls to be avoided is that tests for equality will not
  // reflect inheritance.  This becomes important if an unknown
  // non-builtin (that is, user defined) object class ID is obtained.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppClassDef arg is NULL.
  //
  STDMETHOD(GetDictionary) (THIS_
    // A pointer to an Dictionary pointer
    /*[out, retval]*/ IAAFDictionary ** ppDictionary) PURE;


  //***********************************************************
  //
  // EnableGenerationTracking()
  //
  // Calling this method will cause generation tracking to be enabled
  // for this object.  Generation information will then be available
  // through the GetGeneration() and GetGenerationAUID() methods.
  // 
  // Calling the DisableGenerationTracking() method will disable
  // generation tracking for this object.
  // 
  // Generation tracking is disabled by default.
  //
  // This method always succeeds, even if generation tracking is
  // already enabled.
  // 
  // This method will return the following result:
  //  - AAFRESULT_SUCCESS
  STDMETHOD(EnableGenerationTracking) (THIS) PURE;


  //***********************************************************
  //
  // DisableGenerationTracking()
  //
  // Calling this method will cause generation tracking to be disabled
  // for this object.  Generation information will then not be
  // available through the GetGeneration() and GetGenerationAUID()
  // methods.
  // 
  // Calling the EnableGenerationTracking() method will enable
  // generation tracking for this object.
  // 
  // Generation tracking is disabled by default.
  //
  // This method always succeeds, even if generation tracking is
  // already disbled.
  // 
  // This method will return the following result:
  //  - AAFRESULT_SUCCESS
  STDMETHOD(DisableGenerationTracking) (THIS) PURE;


  //***********************************************************
  //
  // IsGenerationTracked()
  //
  // This method will set *pResult to AAFTrue if generations are
  // being tracked for this object.  A result of AAFTrue indicates
  // that generation information will be available through the
  // GetGeneration() and GetGenerationAUID() methods.
  // 
  // Calling the EnableGenerationTracking() method will enable
  // generation tracking for this object; calling the
  // DisableGenerationTracking() method will disable generation
  // tracking for this object.
  // 
  // Generation tracking is disabled by default.
  //
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pResult arg is NULL.
  //
  STDMETHOD(IsGenerationTracked) (THIS_
    // set to true if generations are tracked; false otherwise
    /*[out]*/ aafBoolean_t *  pResult) PURE;

  END_INTERFACE
};
#endif // __IAAFObject_INTERFACE_DEFINED__



// IAAFParameter

// ************************
//
// Interface IAAFParameter
//
// ************************




 

#ifndef __IAAFParameter_INTERFACE_DEFINED__
#define __IAAFParameter_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFParameter;

#undef  INTERFACE
#define INTERFACE   IAAFParameter

DECLARE_INTERFACE_(IAAFParameter, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFParameter methods *** */


  //***********************************************************
  //
  // GetParameterDefinition()
  //
  // Places the parameter definition of the operation parameter into
  // the *ppParmDef argument.  The length of an operation parameter is
  // in the same edit units and has the same value as the
  // IAAFOperationGroup enclosing this parameter.
  //
  // Succeeds if all of the following are true:
  // - the ppParmDef pointer is valid.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - ppParmDef is null.
  //
  STDMETHOD(GetParameterDefinition) (THIS_
    // New parameter definition
    /*[out,retval]*/ IAAFParameterDef ** ppParmDef) PURE;

  //***********************************************************
  //
  // GetTypeDefinition()
  //
  // Places the IAAFTypeDefinition of the data value inside this
  // parameter into the *ppTypeDef argument.  The data value is the
  // value of the parameter.  It is often an integer or rational, and
  // may change over time.  An example of a value would be the
  // "level" parameter of a video dissolve, which has control
  // points with a value of zero (0 percent B material) at the
  // start, to one (100 percent B material) at the end.  The data
  // value will actually be stored in either AAFConstantValue or one
  // of the AAFControlPoints inside of an AAFVaryingValue.
  //
  // The definition is stored in the base class because it should be
  // constant for all control points inside of a varying value.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - ppTypeDef is null.
  //
  STDMETHOD(GetTypeDefinition) (THIS_
    // Type Definition of the data value inside of this object
    /*[out,retval]*/ IAAFTypeDef ** ppTypeDef) PURE;

  END_INTERFACE
};
#endif // __IAAFParameter_INTERFACE_DEFINED__



// IAAFParameterDef

// ************************
//
// Interface IAAFParameterDef
//
// ************************


 

#ifndef __IAAFParameterDef_INTERFACE_DEFINED__
#define __IAAFParameterDef_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFParameterDef;

#undef  INTERFACE
#define INTERFACE   IAAFParameterDef

DECLARE_INTERFACE_(IAAFParameterDef, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFParameterDef methods *** */

  //***********************************************************
  //
  // Initialize()
  //
  // Init all fields of a definition object.
  //
  STDMETHOD(Initialize) (THIS_
    // AUID for new DeObject
    /*[in, ref]*/ aafUID_constref  id,

    // Name for new DefObject
    /*[in, string]*/ aafCharacter_constptr  pName,

    // Description for new DefObject
    /*[in, string]*/ aafCharacter_constptr  pDescription,

    // The type definition for all parameters that use this definition
    /*[in]*/ IAAFTypeDef * pType) PURE;


  //***********************************************************
  //
  // GetTypeDefinition()
  //
  // Places the AAFTypeDef object attached to this IAAFParameterDef
  // into the *ppTypeDef argument.  If none exists yet, NULL is
  // placed into the *ppTypeDef argument.
  //
  // The returned AAFTypeDef object, if it exists, is AddRef()ed
  // before it is returned.
  //
  // Succeeds if all of the following are true:
  // - the ppTypeDef pointer is valid.
  // - A valid AAFTypeDef exists.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - ppTypeDef is null.
  //
  // AAFRESULT_NO_ESSENCE_DESC
  //   - There is no AAFTypeDef.  There has to be one of some
  //     kind for this to be a valid operation definition.
  //
  STDMETHOD(GetTypeDefinition) (THIS_
    // Pointer to a type definition
    /*[retval,out]*/ IAAFTypeDef ** ppTypeDef) PURE;


  //***********************************************************
  //
  // SetDisplayUnits()
  //
  // Sets the Display Units string property.
  //
  // Set the DisplayUnits property to the value specified in
  // pDisplayUnits.  A copy is made of the data so the caller
  // retains ownership of the *pDisplayUnits buffer and is
  // responsible for de-allocating it.  There is no pre-set limit to
  // the length of the name, other than available system memory or
  // disk space.
  // 
  // Succeeds if all of the following are true:
  // - the pDisplayUnits pointer is valid.
  // 
  // If this method fails the DisplayUnits property will not be
  // changed.
  // 
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pDisplayUnits arg is NULL.
  //
  STDMETHOD(SetDisplayUnits) (THIS_
    // buffer from which DisplayUnits is to be read
    /*[in, string]*/ aafCharacter_constptr  pDisplayUnits) PURE;


  //***********************************************************
  //
  // GetDisplayUnits()
  //
  // Gets the Display Units string property.
  // 
  // Writes the DisplayUnits property, with a trailing null
  // character, into the pDisplayUnits buffer.  The
  // buffer is allocated by the caller.  The size of the buffer is
  // given by bufSize.  If the DisplayUnits property has not yet
  // been set, a zero-length string will be written (that is,
  // only the trailing null character). 
  // 
  // Caller may call GetDisplayUnitsBufLen() to determine the
  // required buffer size.
  // 
  // If this method fails nothing will be written to
  // *pDisplayUnits.
  // 
  // Succeeds if:
  // - The pDisplayUnits pointer is valid.
  // - bufSize indicates that the buffer is large enough to hold
  //   DisplayUnits.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pDisplayUnits arg is NULL.
  //
  // AAFRESULT_SMALL_BUF
  //   - bufSize indicates that the allocated buffer is not large
  //     enough to hold DisplayUnits.
  //
  STDMETHOD(GetDisplayUnits) (THIS_
    // buffer into which DisplayUnits is to be written
    /*[out, string, size_is(bufSize)]*/ aafCharacter *  pDisplayUnits,

    // size of *pDisplayUnits buffer in bytes
    /*[in]*/ aafUInt32  bufSize) PURE;


  //***********************************************************
  //
  // GetDisplayUnitsBufLen()
  //
  // Returns size of buffer (in bytes) required for GetDisplayUnits().
  // 
  // Succeeds if:
  // - The pBufSize pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pBufSize arg is NULL.
  //
  STDMETHOD(GetDisplayUnitsBufLen) (THIS_
    // size of required buffer, in bytes
    /*[out]*/ aafUInt32 *  pBufSize) PURE;

  END_INTERFACE
};
#endif // __IAAFParameterDef_INTERFACE_DEFINED__



// IAAFProperty

// ************************
//
// Interface IAAFProperty
//
// ************************






#ifndef __IAAFProperty_INTERFACE_DEFINED__
#define __IAAFProperty_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFProperty;

#undef  INTERFACE
#define INTERFACE   IAAFProperty

DECLARE_INTERFACE_(IAAFProperty, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFProperty methods *** */

  //***********************************************************
  //
  // GetDefinition()
  //
  // Returns the definition of this property.
  //
  // Succeeds if:
  // - This object has already been Initialize()d.
  // - The ppPropDef pointer is valid.
  // - The associated property definition can be found in the
  //   dictionary.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - ppPropDef arg is NULL.
  //
  // AAFRESULT_BAD_PROP
  //   - The definition for this property could not be found in the
  //     dictionary.
  //
  STDMETHOD(GetDefinition) (THIS_
    // This property's definition
    /*[out]*/ IAAFPropertyDef ** ppPropDef) PURE;


  //***********************************************************
  //
  // GetValue()
  //
  // Returns the Property Value object associated with this property.
  //
  // Succeeds if:
  // - This object has already been Initialize()d.
  // - The ppPval pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - ppValue arg is NULL.
  //
  // AAFRESULT_PROP_NOT_PRESENT
  //   - The given property is optional and not present.
  //
  STDMETHOD(GetValue) (THIS_
    // The Property Value object associated with this property.
    /*[out]*/ IAAFPropertyValue ** ppValue) PURE;

  END_INTERFACE
};
#endif // __IAAFProperty_INTERFACE_DEFINED__



// IAAFPropertyDef

// ************************
//
// Interface IAAFPropertyDef
//
// ************************




 

#ifndef __IAAFPropertyDef_INTERFACE_DEFINED__
#define __IAAFPropertyDef_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFPropertyDef;

#undef  INTERFACE
#define INTERFACE   IAAFPropertyDef

DECLARE_INTERFACE_(IAAFPropertyDef, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFPropertyDef methods *** */

  //***********************************************************
  //
  // GetTypeDef()
  //
  // Returns a reference to this property's type definition.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pResult is null.
  //
  STDMETHOD(GetTypeDef) (THIS_
    // definition of type contained by this property
    /*[out]*/ IAAFTypeDef ** ppTypeDef) PURE;


  //***********************************************************
  //
  // GetName()
  //
  // Gets the human-legible name.
  // 
  // Writes the Name property, with a trailing null
  // character, into the pName buffer.  The
  // buffer is allocated by the caller.  The size of the buffer is
  // given by bufSize.  If the Name property has not yet
  // been set, a zero-length string will be written (that is,
  // only the trailing null character). 
  // 
  // Caller may call GetNameBufLen() to determine the
  // required buffer size.
  // 
  // If this method fails nothing will be written to
  // *pName.
  // 
  // Succeeds if:
  // - The pName pointer is valid.
  // - bufSize indicates that the buffer is large enough to hold
  //   Name.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pName arg is NULL.
  //
  // AAFRESULT_SMALL_BUF
  //   - bufSize indicates that the allocated buffer is not large
  //     enough to hold Name.
  //
  STDMETHOD(GetName) (THIS_
    // buffer into which Name is to be written
    /*[out, string, size_is(bufSize)]*/ aafCharacter *  pName,

    // size of *pName buffer in bytes
    /*[in]*/ aafUInt32  bufSize) PURE;


  //***********************************************************
  //
  // GetNameBufLen()
  //
  // Returns size of buffer (in bytes) required for GetName().
  // 
  // Succeeds if:
  // - The pBufSize pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pBufSize arg is NULL.
  //
  STDMETHOD(GetNameBufLen) (THIS_
    // size of required buffer, in bytes
    /*[out]*/ aafUInt32 *  pBufSize) PURE;


  //***********************************************************
  //
  // GetIsOptional()
  //
  // Sets *pIsOptional to AAFTrue for properties that are optional.
  // Sets it to AAFFalse for properties that are mandatory.
  //
  // Succeeds if:
  // - The pIsOptional pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
    // NOTE! Stub only.   Implementation not yet added.
  //

  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - The pIsOptional pointer is NULL.
  //
  STDMETHOD(GetIsOptional) (THIS_
    // pointer to the result
    /*[out, retval]*/ aafBoolean_t *  pIsOptional) PURE;

  //***********************************************************
  //
  // GetIsUniqueIdentifier()
  //
  // Sets *pIsUniqueIdentifier to AAFTrue for properties that are optional.
  // Sets it to AAFFalse for properties that are mandatory.
  //
  // Succeeds if:
  // - The pIsUniqueIdentifier pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
    // NOTE! Stub only.   Implementation not yet added.
  //

  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - The pIsUniqueIdentifier pointer is NULL.
  //
  STDMETHOD(GetIsUniqueIdentifier) (THIS_
    // pointer to the result
    /*[out, retval]*/ aafBoolean_t *  pIsUniqueIdentifier) PURE;




  //***********************************************************
  //
  // SetDescription()
  //
  // Sets the description of the property definition.
  //
  // Set the Description property to the value specified in
  // pDescription.  A copy is made of the data so the caller
  // retains ownership of the *pDescription buffer and is
  // responsible for de-allocating it.  There is no pre-set limit to
  // the length of the name, other than available system memory or
  // disk space.
  // 
  // Succeeds if all of the following are true:
  // - the pDescription pointer is valid.
  // 
  // If this method fails the Description property will not be
  // changed.
  // 
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pDescription arg is NULL.
  //
  STDMETHOD(SetDescription) (THIS_
    // buffer from which Description is to be read
    /*[in, string]*/ aafCharacter_constptr  pDescription) PURE;


  //***********************************************************
  //
  // GetDescription()
  //
  // Gets the description of the property definition.
  // 
  // Writes the Description property, with a trailing null
  // character, into the pDescription buffer.  The
  // buffer is allocated by the caller.  The size of the buffer is
  // given by bufSize.  If the Description property has not yet
  // been set, a zero-length string will be written (that is,
  // only the trailing null character). 
  // 
  // Caller may call GetDescriptionBufLen() to determine the
  // required buffer size.
  // 
  // If this method fails nothing will be written to
  // *pDescription.
  // 
  // Succeeds if:
  // - The pDescription pointer is valid.
  // - bufSize indicates that the buffer is large enough to hold
  //   Description.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pDescription arg is NULL.
  //
  // AAFRESULT_SMALL_BUF
  //   - bufSize indicates that the allocated buffer is not large
  //     enough to hold Description.
  //
  STDMETHOD(GetDescription) (THIS_
    // buffer into which Description is to be written
    /*[out, string, size_is(bufSize)]*/ aafCharacter *  pDescription,

    // size of *pDescription buffer in bytes
    /*[in]*/ aafUInt32  bufSize) PURE;


  //***********************************************************
  //
  // GetDescriptionBufLen()
  //
  // Returns size of buffer (in bytes) required for GetDescription().
  // 
  // Succeeds if:
  // - The pBufSize pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pBufSize arg is NULL.
  //
  STDMETHOD(GetDescriptionBufLen) (THIS_
    // size of required buffer, in bytes
    /*[out]*/ aafUInt32 *  pBufSize) PURE;


  END_INTERFACE
};
#endif // __IAAFPropertyDef_INTERFACE_DEFINED__



// IAAFPropertyValue

// ************************
//
// Interface IAAFPropertyValue
//
// ************************




#ifndef __IAAFPropertyValue_INTERFACE_DEFINED__
#define __IAAFPropertyValue_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFPropertyValue;

#undef  INTERFACE
#define INTERFACE   IAAFPropertyValue

DECLARE_INTERFACE_(IAAFPropertyValue, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFPropertyValue methods *** */

  //***********************************************************
  //
  // GetType()
  //
  // Returns the type definition associated with this property value.
  // If this Property Value is not of a recognized type (such as from
  // a damaged or incorrectly construct file) this method will return
  // a raw access type which can be used to access the property data
  // in a raw manner.
  //
  // Succeeds if:
  // - The ppTypeDef pointer is valid.
  // - The associated type definition can be found in the dictionary.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppTypeDef arg is NULL.
  //
  STDMETHOD(GetType) (THIS_
    // The type definition associated with this property value
    /*[out]*/ IAAFTypeDef ** ppTypeDef) PURE;


  //***********************************************************
  //
  // IsDefinedType()
  //
  // Returns false if this property value's type is not (necessarily)
  // the one which was defined for it.  That may be the case if this
  // property value was read from a damaged file where type
  // information was not available; in that case GetType() will return
  // the raw access type for this value.
  //
  // If this property value's type is the one which was defined for
  // it, this method will return true and GetType() will return that
  // defined type for this value.
  //
  // Succeeds if:
  // - The pIsDefined pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pIsDefined arg is NULL.
  //
  STDMETHOD(IsDefinedType) (THIS_
    // result
    /*[out]*/ aafBoolean_t *  pIsDefined) PURE;

  END_INTERFACE
};
#endif // __IAAFPropertyValue_INTERFACE_DEFINED__



// IAAFPluginManager

// ************************
//
// Interface IAAFPluginManager
//
// ************************





#ifndef __IAAFPluginManager_INTERFACE_DEFINED__
#define __IAAFPluginManager_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFPluginManager;

#undef  INTERFACE
#define INTERFACE   IAAFPluginManager

DECLARE_INTERFACE_(IAAFPluginManager, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFPluginManager methods *** */

  //***********************************************************
  //
  // RegisterSharedPlugins()
  //
  // Attempts to load and register all of the AAF plugin files found
  // in shared installation directory.
  STDMETHOD(RegisterSharedPlugins) (THIS) PURE;


  //***********************************************************
  //
  // RegisterPluginDirectory()
  //
  // Attempts to load and register all of the AAF plugin files found
  // in the given directory.
  //
  STDMETHOD(RegisterPluginDirectory) (THIS_
    // Pointer to the name of directory to look for plugins.
    /*[in]*/ aafCharacter_constptr  directoryName) PURE;


  //***********************************************************
  //
  // RegisterPluginFile()
  //
  // Attempts to load and register all of the AAF plugins found
  // in the given file.
  //
  STDMETHOD(RegisterPluginFile) (THIS_
    // Pointer to the name of plugin file to register.
    /*[in]*/ aafCharacter_constptr  fileName) PURE;


  //***********************************************************
  //
  // EnumLoadedPlugins()
  //
  // Returns an enumerator which enumerates over all of the loaded
  // pluigin choices through the *ppEnum argument.  The returned
  // enumerator is AddRef()ed before it is returned.
  // 
  // Succeeds if all of the following are true:
  // - the ppEnum pointer is valid.
  // 
  // If this method fails nothing will be written to *ppEnum.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - if ppEnum is null.
  //
  STDMETHOD(EnumLoadedPlugins) (THIS_
    // Which category ID do we want to enumerate
    /*[in, ref]*/ aafUID_constref  categoryID,

    // Loaded Plugin Enumeration
    /*[out,retval]*/ IEnumAAFLoadedPlugins ** ppEnum) PURE;


  //***********************************************************
  //
  // CreatePluginDefinition()
  //
  // Given a plugin definition ID, find a plugin and manufactures a
  // plugin descriptor of the correct class for this plugin, filling
  // in the values, and returning the definition through the
  // *pPluginDesc argument.  The returned definition is AddRef()ed
  // before it is returned.  You must call QueryInterface on the
  // result in order to find the correct interface, and are
  // responsible for adding the definition to the correct place in the
  // dictionary, as well as preventing duplicates. The resulting
  // definiton has the plugin descriptor already attached.
  // 
  // Succeeds if all of the following are true:
  // - the pPluginDesc pointer is valid.
  // 
  // If this method fails nothing will be written to *ppEnum.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - if pPluginDesc is null.
  //
  STDMETHOD(CreatePluginDefinition) (THIS_
    // Which plugin definition do you want to create
    /*[in, ref]*/ aafUID_constref  pluginDefID,

    // The dictionary of the file where the descriptor is to be created
    /*[in]*/ IAAFDictionary * pDictionary,

    // The interface of the returned definition
    /*[out]*/ IAAFDefObject**  ppPluginDef) PURE;


  //***********************************************************
  //
  // CreateInstance()
  //
  // Create an object contained within one of the loaded plugin
  // files.
  // 
  // Succeeds if all of the following are true:
  // - the rclsid was found by the plugin manager
  // - the interface corresponding to riid is supported by the plugin
  // - if pUnkOuter is not NULL and given plugin supports aggregation
  //   and riid must be a reference to IID_IUnknown.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // E_INVALIDARG
  //   - if ppPlugin is null.
  //   - pUnkOuter is not NULL and riid is not IID_IUnknown.
  //
  // AAFRESULT_EXTENSION_NOT_FOUND
  //   - The given rclsid could not be found by the Plugin Manager.
  //
  // E_NOINTERFACE
  //   - if initial interface given by riid is not supported by the
  //     plugin.
  //
  STDMETHOD(CreateInstance) (THIS_
    // The class id of the plugin object do you want to create
    /*[in]*/ REFCLSID  rclsid,

    // The controlling unknown of the new instance
    /*[in]*/ IUnknown *  pUnkOuter,

    // The IID of the initialial interface for the new plugin instance
    /*[in]*/ REFIID  riid,

    // The IID of the initialial interface for the new plugin instance
    /*[out,iid_is(riid)]*/ void **  ppPlugin) PURE;

  END_INTERFACE
};
#endif // __IAAFPluginManager_INTERFACE_DEFINED__



// IAAFPulldown

// ************************
//
// Interface IAAFPulldown
//
// ************************



#ifndef __IAAFPulldown_INTERFACE_DEFINED__
#define __IAAFPulldown_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFPulldown;

#undef  INTERFACE
#define INTERFACE   IAAFPulldown

DECLARE_INTERFACE_(IAAFPulldown, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFPulldown methods *** */

  //***********************************************************
  //
  // GetInputSegment()
  //
  // Places the input Segment object in this pulldown into the
  // *ppInputSegment argument.  If none exists yet, NULL is placed
  // into the *ppInputSegment argument.
  //
  // The returned segment object, if it exists, is AddRef()ed
  // before it is returned.
  //
  // Succeeds if all of the following are true:
  // - the ppInputSegment pointer is valid.
  // - A valid segment exists.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - ppInputSegment is null.
  //
  STDMETHOD(GetInputSegment) (THIS_
    // Returns the input Segment object
    /*[out]*/ IAAFSegment ** ppInputSegment) PURE;


  //***********************************************************
  //
  // SetInputSegment()
  //
  // Sets the input segment .
  //
  // Succeeds if all of the following are true:
  // - the pInputSegment pointer is valid.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pInputSegment is null.
  //
  STDMETHOD(SetInputSegment) (THIS_
    // A Segment object
    /*[in]*/ IAAFSegment * pInputSegment) PURE;


  //***********************************************************
  //
  // GetPulldownKind()
  //
  // Returns the pulldownKind property of this pulldown through the
  // *pPulldownKind argument.  The pulldown kinds include
  // kThreeTwoPD, kPalPD, kOneToOneNTSC, kOneToOnePAL, and
  // kVideoTapNTSC.
  //
  // Succeeds if all of the following are true:
  // - the pPulldownKind pointer is valid.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pPulldownKind is null.
  //
  STDMETHOD(GetPulldownKind) (THIS_
    // Returns the pulldownKind property
    /*[out]*/ aafPulldownKind_t *  pPulldownKind) PURE;


  //***********************************************************
  //
  // SetPulldownKind()
  //
  // Sets the pulldown kind field of this pulldown object.  The
  // pulldown kinds include kThreeTwoPD, kPalPD, kOneToOneNTSC,
  // kOneToOnePAL, and kVideoTapNTSC.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pInputSegment is null.
  //
  STDMETHOD(SetPulldownKind) (THIS_
    // A Segment object
    /*[in]*/ aafPulldownKind_t  pulldownKind) PURE;


  //***********************************************************
  //
  // GetPulldownDirection()
  //
  // Returns the pulldownDirection field of this pulldown through the
  // *pPulldownDirection argument.  The valid pulldown directions are:
  //    kVideoToFilmSpeed -- The input segment is at videoSpeed, and
  //                         the pulldown object is on a mob slot at
  //                         film edit rate.
  //    kFilmToVideoSpeed -- The input segment is at film edit rate.
  //
  // The value kVideoToFilmSpeed is used when connecting 24fps file
  // mobs to tape mobs. 
  //
  // The value kFilmToVideoSpeed is used when connecting tape mobs to
  // film mobs.
  //
  // Succeeds if all of the following are true:
  // - the pPulldownDirection pointer is valid.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pPulldownDirection is null.
  //
  STDMETHOD(GetPulldownDirection) (THIS_
    // Returns the input Segment object
    /*[out]*/ aafPulldownDir_t *  pPulldownDirection) PURE;


  //***********************************************************
  //
  // SetPulldownDirection()
  //
  // Sets the pulldown direction field of this pulldown object.  The
  // valid pulldown directions are:
  //    kVideoToFilmSpeed -- The input segment is at videoSpeed, and
  //                         the pulldown object is on a mob slot at
  //                         film edit rate.
  //    kFilmToVideoSpeed -- The input segment is at film edit rate.
  //
  // The value kVideoToFilmSpeed is used when connecting 24fps file
  // mobs to tape mobs.
  //
  // The value kFilmToVideoSpeed is used when connecting tape mobs to
  // film mobs.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pInputSegment is null.
  //
  STDMETHOD(SetPulldownDirection) (THIS_
    // A Segment object
    /*[in]*/ aafPulldownDir_t  pulldownDirection) PURE;


  //***********************************************************
  //
  // GetPhaseFrame()
  //
  // Returns the phaseFrame field of this pulldown through the
  // *pPhaseFrame argument.  The phase frame field specifies the phase
  // within the repeating pattern used to map between the two edit
  // rates. A value of zero specifies that the pulldown object starts
  // at the begining of the pattern.
  //
  // Succeeds if all of the following are true:
  // - the pPhaseFrame pointer is valid.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pPhaseFrame is null.
  //
  STDMETHOD(GetPhaseFrame) (THIS_
    // Returns the input Segment object
    /*[out]*/ aafPhaseFrame_t *  pPhaseFrame) PURE;


  //***********************************************************
  //
  // SetPhaseFrame()
  //
  // Sets the phase frame field of this pulldown object.  The phase
  // frame field specifies the phase within the repeating pattern used
  // to map between the two edit rates. A value of zero specifies that
  // the pulldown object starts at the begining of the pattern.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pInputSegment is null.
  //
  STDMETHOD(SetPhaseFrame) (THIS_
    // A Segment object
    /*[in]*/ aafPhaseFrame_t  phaseFrame) PURE;







  END_INTERFACE
};
#endif // __IAAFPulldown_INTERFACE_DEFINED__



// IAAFRGBADescriptor

// ************************
//
// Interface IAAFRGBADescriptor
//
// ************************







#ifndef __IAAFRGBADescriptor_INTERFACE_DEFINED__
#define __IAAFRGBADescriptor_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFRGBADescriptor;

#undef  INTERFACE
#define INTERFACE   IAAFRGBADescriptor

DECLARE_INTERFACE_(IAAFRGBADescriptor, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFRGBADescriptor methods *** */


  //***********************************************************
  //
  // SetPixelLayout()
  //
  // Sets the layout and structure of the components in a single pixel.
  // The layout array is an Array of 8 aafRGBAComponent_t.  The 'Code' field of the struct is
  // from the set:
  //   	kAAFCompNone
  // 	kAAFCompAlpha
  // 	kAAFCompBlue
  // 	kAAFCompFill
  // 	kAAFCompGreen
  // 	kAAFCompPalette
  // 	kAAFCompRed
  // The 'Size' field of the struct is the component size in bits.
  // 
  // If you set less than 8 entries, the remaining entries will be padded with kAAFCompNone and a size of zero.
  // If this method fails the PixelLayout property will not be changed.
  // 
  // This method will return the following codes:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  STDMETHOD(SetPixelLayout) (THIS_
    // The number of elements in each array
    /*[in]*/ aafUInt32  numberElements,

    // Array of up to 8 aafRGBAComponent_t indicating component order and size.
    /*[in]*/ aafRGBAComponent_t*  PixelLayoutArray) PURE;

  //***********************************************************
  //
  // CountPixelLayoutElements()
  //
  // This function returns the number of components in a pixel.
  // 
  // Succeeds if all of the following are true:
  // - this object has already been initialized.
  // - the pResult pointer is valid.
  // 
  // If this method fails no state is changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - Initialize() has already been called on this object.
  //
  // AAFRESULT_NULL_PARAM
  //   - pResult is null.
  //
  STDMETHOD(CountPixelLayoutElements) (THIS_
    // Number of components
    /*[out]*/ aafUInt32 *  pResult) PURE;

  //***********************************************************
  //
  // GetPixelLayout()
  //
  // Gets the layout and structure of the components in a single pixel.
  // The layout array is an Array of 8 aafRGBAComponent_t.  The 'Code' field of the struct is
  // from the set:
  //   	kAAFCompNone
  // 	kAAFCompAlpha
  // 	kAAFCompBlue
  // 	kAAFCompFill
  // 	kAAFCompGreen
  // 	kAAFCompPalette
  // 	kAAFCompRed
  //
  // The 'Size' field of the struct is the component size in bits.
  // 
  // If you Get more entries than were set, the extra entries will be padded with kAAFCompNone and a size of zero.
  //
  // If this method fails, PixelLayoutArray will not be changed.
  // 
  // This method will return the following codes:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pNumberElements or PixelLayoutArray or PixelStructureArray is NULL.
  //
  // AAFRESULT_SMALLBUF
  //   - numberElements indicates that the array is too small to hold
  //     the data.
  //
  STDMETHOD(GetPixelLayout) (THIS_
    // The number of elements in the array
    /*[in]*/ aafUInt32  numberElements,

    // Array to hold up to 8 aafRGBAComponent_t indicating component order and size.
    /*[out, size_is(numberElements)]*/ aafRGBAComponent_t*  PixelLayoutArray) PURE;

  //***********************************************************
  //
  // SetPalette()
  //
  // Sets the palette property.  The palette must be in the form specified
  // by the palette layout and palette structure parameters.
  // 
  // Succeeds if all of the following are true:
  // - pPalette is a valid pointer
  // 
  // If this method fails, the palette property will not be
  // changed.
  // 
  // This method will return the following codes:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pPalette is NULL.
  //
  STDMETHOD(SetPalette) (THIS_
    // The number of bytes in the array
    /*[in]*/ aafUInt32  numberElements,

    // Array to hold the palette information
    /*[in, size_is(numberElements)]*/ aafUInt8*  pPalette) PURE;


  //***********************************************************
  //
  // GetPalette()
  //
  // Sets the palette property.  The palette must be in the form specified
  // by the palette layout and palette structure parameters.
  // The values are written to the array specified by pPalette,
  // which is of size numberElements.  The required size may be found
  // by calling GetPaletteSize().
  // 
  // Succeeds if all of the following are true:
  // - pPalette is a valid pointer.
  // - numberElements indicates the array is large enough to hold the
  //   data.
  // 
  // If this method fails, pPalette will not be changed.
  // 
  // This method will return the following codes:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pNumberElements is NULL.
  //
  // AAFRESULT_SMALLBUF
  //   - numberElements indicates that the array is too small to hold
  //     the data.
  //
  STDMETHOD(GetPalette) (THIS_
    // The number of bytes in the array
    /*[in]*/ aafUInt32  numberRecords,

    // Array to hold the palette information
    /*[out, size_is(numberRecords)]*/ aafUInt8*  pPalette) PURE;


  //***********************************************************
  //
  // GetPaletteSize()
  //
  // Get the number of bytes in the VideoLineMap property array.
  // 
  // Succeeds if all of the following are true:
  // - pNumberBytes is a valid pointer
  // 
  // If this method fails, *pNumberBytes will not be changed.
  // 
  // This method will return the following codes:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pNumberBytes is NULL.
  //
  STDMETHOD(GetPaletteSize) (THIS_
    // The number of bytes in the array
    /*[out]*/ aafUInt32 *  pNumberBytes) PURE;

  //***********************************************************
  //
  // CountPaletteLayoutElements()
  //
  // This function returns the number of components in a pixel.
  // 
  // Succeeds if all of the following are true:
  // - this object has already been initialized.
  // - the pResult pointer is valid.
  // 
  // If this method fails no state is changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - Initialize() has already been called on this object.
  //
  // AAFRESULT_NULL_PARAM
  //   - pResult is null.
  //
  STDMETHOD(CountPaletteLayoutElements) (THIS_
    // Number of components
    /*[out]*/ aafUInt32 *  pResult) PURE;

  //***********************************************************
  //
  // SetPaletteLayout()
  //
  // Sets the layout and structure of the components in a single pixel.
  // The layout array is an Array of 8 aafRGBAComponent_t.  The 'Code' field of the struct is
  // from the set:
  //   	kAAFCompNone
  // 	kAAFCompAlpha
  // 	kAAFCompBlue
  // 	kAAFCompFill
  // 	kAAFCompGreen
  // 	kAAFCompPalette
  // 	kAAFCompRed
  // The 'Size' field of the struct is the component size in bits.
  // 
  // If you set less than 8 entries, the remaining entries will be padded with kAAFCompNone and a size of zero.
  // If this method fails the PaletteLayout property will not be changed.
  // 
  // This method will return the following codes:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  STDMETHOD(SetPaletteLayout) (THIS_
    // The number of elements in the array
    /*[in]*/ aafUInt32  numberElements,

    // Array of up to 8 bytes indicating component size, matching layout, and terminated by a zero byte.
    /*[in]*/ aafRGBAComponent_t*  PaletteLayoutArray) PURE;

  //***********************************************************
  //
  // GetPaletteLayout()
  //
  // // The layout array is an Array of 8 aafRGBAComponent_t.  The 'Code' field of the struct is
  // from the set:
  //   	kAAFCompNone
  // 	kAAFCompAlpha
  // 	kAAFCompBlue
  // 	kAAFCompFill
  // 	kAAFCompGreen
  // 	kAAFCompPalette
  // 	kAAFCompRed
  //
  // The 'Size' field of the struct is the component size in bits.
  // 
  // If you Get more entries than were set, the extra entries will be padded with kAAFCompNone and a size of zero.
  //
  // If this method fails, PaletteLayoutArray will not be changed.
  // 
  // This method will return the following codes:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pNumberElements or PaletteLayoutArray is NULL.
  //
  // AAFRESULT_SMALLBUF
  //   - numberElements indicates that the array is too small to hold
  //     the data.
  //
  STDMETHOD(GetPaletteLayout) (THIS_
    // The number of elements in each array
    /*[in]*/ aafUInt32  numberElements,

    // Array to hold 8 aafRGBAComponent_t indicating component order and size.
    /*[out, size_is(numberElements)]*/ aafRGBAComponent_t*  PaletteLayoutArray) PURE;


  END_INTERFACE
};
#endif // __IAAFRGBADescriptor_INTERFACE_DEFINED__



// IAAFScopeReference

// ************************
//
// Interface IAAFScopeReference
//
// ************************




#ifndef __IAAFScopeReference_INTERFACE_DEFINED__
#define __IAAFScopeReference_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFScopeReference;

#undef  INTERFACE
#define INTERFACE   IAAFScopeReference

DECLARE_INTERFACE_(IAAFScopeReference, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFScopeReference methods *** */

  //***********************************************************
  //
  // Create()
  //
  // Constructs a Scope Reference object.
  // 
  // If this method fails the length property will not be
  // changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  STDMETHOD(Create) (THIS_
    // Number of nested scopes to pass to find the Nested Scope slot
    /*[in]*/ aafUInt32  RelativeScope,

    // Number of slots to look backwards from the slot containing the
    // Scope Reference
    /*[in]*/ aafUInt32  RelativeSlot) PURE;

  //***********************************************************
  //
  // Initialize()
  //
  // Constructs a Scope Reference object.
  // 
  // If this method fails the length property will not be
  // changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  STDMETHOD(Initialize) (THIS_
    // Data definition for referenced slot
    /*[in]*/ IAAFDataDef * pDataDef,

    // Number of nested scopes to pass to find the Nested Scope slot
    /*[in]*/ aafUInt32  RelativeScope,

    // Number of slots to look backwards from the slot containing the
    // Scope Reference
    /*[in]*/ aafUInt32  RelativeSlot) PURE;

  //***********************************************************
  //
  // GetRelativeScope()
  //
  // Gets the number of nested scopes to pass to find the Nested Scope
  // slot.
  //	
  // Succeeds if all of the following are true:
  // - the pnRelativeScope pointer is valid.
  // 
  // If this method fails nothing will be written to *pnRelativeScope.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pnRelativeScope arg is NULL.
  //
  STDMETHOD(GetRelativeScope) (THIS_
    // Pointer to a Relative Scope
    /*[retval][out]*/ aafUInt32 *  pnRelativeScope) PURE;


  //***********************************************************
  //
  // GetRelativeSlot()
  //
  // Gets the number of slots that preced the slot containing the
  // Scope Reference. 
  //	
  // Succeeds if all of the following are true:
  // - the pnRelativeScope pointer is valid.
  // 
  // If this method fails nothing will be written to *pnRelativeSlot.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pnRelativeSlot arg is NULL.
  //
  STDMETHOD(GetRelativeSlot) (THIS_
    // Pointer to a Relative Slot
    /*[retval][out]*/ aafUInt32 *  pnRelativeSlot) PURE;

  END_INTERFACE
};
#endif // __IAAFScopeReference_INTERFACE_DEFINED__



// IAAFSegment

// ************************
//
// Interface IAAFSegment
//
// ************************



#ifndef __IAAFSegment_INTERFACE_DEFINED__
#define __IAAFSegment_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFSegment;

#undef  INTERFACE
#define INTERFACE   IAAFSegment

DECLARE_INTERFACE_(IAAFSegment, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFSegment methods *** */

  //***********************************************************
  //
  // SegmentOffsetToTC()
  //
  // Converts the given Segment offset to timecode.
  // 
  // Succeeds if all of the following are true:
  // - the pOffset pointer is valid.
  // - the pTimeCode pointer is valid.
  // 
  // If this method fails the value of pTimecode is left unchanged.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - any arg is NULL.
  //
  // AAFRESULT_TIMECODE_NOT_FOUND
  //   - the given offset is not available in this segment.
  //
  STDMETHOD(SegmentOffsetToTC) (THIS_
    // Pointer to a Segment Offset to be convert to Timecode
    /*[in]*/ aafPosition_t *  pOffset,

    // The converted timecode to be returned
    /*[out]*/ aafTimecode_t *  pTimecode) PURE;


  //***********************************************************
  //
  // SegmentTCToOffset()
  //
  // Converts the given Timecode to an Offset.
  // 
  // Succeeds if all of the following are true:
  // - the pTimeCode pointer is valid.
  // - the pEditRate pointer is valid
  // - the pFrameOffset pointer is valid.
  // 
  // If this method fails the value of pOffset is left unchanged.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - any arg is NULL.
  //
  // AAFRESULT_TIMECODE_NOT_FOUND
  //   - the given timecode is not available in this segment.
  //
  STDMETHOD(SegmentTCToOffset) (THIS_
    // Pointer to a timecode to be converted to Offset
    /*[in]*/ aafTimecode_t *  pTimecode,

    // The edit rate for the given timecode 
    /*[in]*/ aafRational_t *  pEditRate,

    // Frame Offset to be returned if found
    /*[out]*/ aafFrameOffset_t *  pOffset) PURE;

  END_INTERFACE
};
#endif // __IAAFSegment_INTERFACE_DEFINED__



// IAAFSelector

// ************************
//
// Interface IAAFSelector
//
// ************************





#ifndef __IAAFSelector_INTERFACE_DEFINED__
#define __IAAFSelector_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFSelector;

#undef  INTERFACE
#define INTERFACE   IAAFSelector

DECLARE_INTERFACE_(IAAFSelector, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFSelector methods *** */

  //***********************************************************
  //
  // GetSelectedSegment()
  //
  // Places the Selected Segment object in this Selector into the
  // *ppSelSegment argument.  If none exists yet, NULL is placed into
  // the *ppSelSegment argument.
  //
  // The returned essence descriptor object, if it exists, is
  // AddRef()ed before it is returned.
  //
  // Succeeds if all of the following are true:
  // - the ppSelSegment pointer is valid.
  // - A valid segment exists.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - ppSelSegment is null.
  //
  STDMETHOD(GetSelectedSegment) (THIS_
    // Returned the selected Segment object
    /*[out]*/ IAAFSegment ** ppSelSegment) PURE;


  //***********************************************************
  //
  // SetSelectedSegment()
  //
  // Sets the Selected segment.
  //
  // Succeeds if all of the following are true:
  // - the pSelSegment pointer is valid.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pSelSegment is null.
  //
  STDMETHOD(SetSelectedSegment) (THIS_
    // A Segment object
    /*[in]*/ IAAFSegment * pSelSegment) PURE;


  //***********************************************************
  //
  // AppendAlternateSegment()
  //
  // This function appends the input segment to the alternate segment
  // list, the alternate list of segments represents unused
  // alternative segments. 
  //
  // This method will AddRef() the segment if it succeeds.
  //
  // If the segment is successfully appended to the set of
  // alternates, the reference count of the segment is incremented.
  // 
  // Succeeds if all of the following are true:
  // - this object has already been initialized.
  // - the pSegment pointer is valid.
  // 
  // If this method fails no state is changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - Initialize() has already been called on this object.
  //
  // AAFRESULT_NULL_PARAM
  //   - pSegment is null.
  //
  STDMETHOD(AppendAlternateSegment) (THIS_
    // Segment to append to the Alternate list of segments
    /*[in]*/ IAAFSegment * pSegment) PURE;


  //***********************************************************
  //
  // GetNumAlternateSegments()
  //
  // This function returns the number of segments in the set.
  // 
  // Succeeds if all of the following are true:
  // - this object has already been initialized.
  // - the pNumSegments pointer is valid.
  // 
  // If this method fails no state is changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - Initialize() has already been called on this object.
  //
  // AAFRESULT_NULL_PARAM
  //   - pNumSegments is null.
  //
  STDMETHOD(GetNumAlternateSegments) (THIS_
    // Number of Alternate Segments
    /*[out]*/ aafInt32 *  pNumSegments) PURE;


  //***********************************************************
  //
  // EnumAlternateSegments()
  //
  // Places an IEnumAAFSegments enumerator for the alterante segments
  // contained in the selector into the *ppEnum argument.
  // 
  // The returned enumerator is AddRef()ed before it is returned.
  //
  // Succeeds if all of the following are true:
  // - this object has already been initialized.
  // - the ppEnum pointer is valid.
  // 
  // If this method fails nothing will be written to *ppEnum.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - Initialize() has already been called on this object.
  //
  // AAFRESULT_NULL_PARAM
  //   - ppEnum is null.
  //
  // E_FAIL
  //   - Failed to create the enumerator.
  //
  STDMETHOD(EnumAlternateSegments) (THIS_
    // Segment Enumeration
    /*[out, retval]*/ IEnumAAFSegments ** ppEnum) PURE;

  //***********************************************************
  //
  // RemoveAlternateSegment()
  //
  // // Removes the given Segment from the selector.
  //
  // Succeeds if all of the following are true:
  // - the v pointer is valid.
  // - the given segment is currently in the collection.
  // 
  // If this method fails no state will be changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pEssenceData is null.
  //
  // AAFRESULT_SEGMENT_NOT_FOUND
  //   - the given segment is not already contained.
  //
  STDMETHOD(RemoveAlternateSegment) (THIS_
    // Segment to remove
    /*[in]*/ IAAFSegment * pSegment) PURE;


  END_INTERFACE
};
#endif // __IAAFSelector_INTERFACE_DEFINED__



// IAAFSequence

// ************************
//
// Interface IAAFSequence
//
// ************************








#ifndef __IAAFSequence_INTERFACE_DEFINED__
#define __IAAFSequence_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFSequence;

#undef  INTERFACE
#define INTERFACE   IAAFSequence

DECLARE_INTERFACE_(IAAFSequence, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFSequence methods *** */

  //***********************************************************
  //
  // Initialize()
  //
  // This function sets the properties on a newly created sequence
  // object with the given property values. The length of the sequence
  // is initially set to 0.  When components are appended to the
  // sequence with the AppendComponent() call, the length of the
  // appended component is added to the length of the sequence.  The
  // given DataDef specifies the kind of data which all components to
  // be contained in this sequence must share.
  // 
  // Succeeds if all of the following are true:
  // - this object has not yet been initialized.
  // 
  // If this method fails no state is changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pDataDef is null.
  //
  // AAFRESULT_ALREADY_INITIALIZED
  //   - Initialize() has already been called on this object.
  //
  STDMETHOD(Initialize) (THIS_
    // DataDef of this object
    /*[in]*/ IAAFDataDef * pDataDef) PURE;


  //***********************************************************
  //
  // AppendComponent()
  //
  // This function appends the input component to the given sequence,
  // enforcing bottom up creation of mobs.  The length of the sequence
  // is incremented by the size of the component, unless the
  // component is a transition.  If the component is a transition, it
  // verifies that it is not the first object in a transition, and
  // that it is not neighboring another transition.  It also verifies
  // that there is enough source material on either side of the
  // transition.  The function also verifies that the datadefs are
  // compatible.
  //
  // This method will AddRef() the component if it succeeds.
  //
  // If the component is successfully appended to the sequence, the
  // reference count of the component is incremented.
  // 
  // Succeeds if all of the following are true:
  // - this object has already been initialized.
  // - the pComponent pointer is valid.
  // 
  // If this method fails no state is changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - Initialize() has already been called on this object.
  //
  // AAFRESULT_NULL_PARAM
  //   - pComponent is null.
  //
  // AAFRESULT_INVALID_DATADEF
  //   - The data kind of the component is not compatible with the 
  //     data def of the sequence.
  //
  // AAFRESULT_LEADING_TRAN
  //   - Attempted to append a transition as the first component of
  //     a sequence.  A sequence can not start with a transition. 
  //
  // AAFRESULT_ADJACENT_TRAN
  //   - Attempted to append a transition next to a transition.  A
  //     sequence can not contain back to back transitions.
  //
  // AAFRESULT_INSUFF_TRAN_MATERIAL
  //   - There is not enough source material to add this component.
  //
  STDMETHOD(AppendComponent) (THIS_
    // Component to append to the sequence
    /*[in]*/ IAAFComponent * pComponent) PURE;


  //***********************************************************
  //
  // PrependComponent()
  //
  // This function prepends the input component to the given
  // sequence, enforcing bottom up creation of mobs.  The length of
  // the sequence is incremented by the size of the component, unless
  // the component is a transition.  If the component is a
  // transition, it verifies that it is not the first object in a
  // transition, and that it is not neighboring another transition.
  // It also verifies that there is enough source material on either
  // side of the transition.  The function also verifies that the
  // datadefs are compatible.
  //
  // This method will AddRef() the component if it succeeds.
  //
  // If the component is successfully appended to the sequence, the
  // reference count of the component is incremented.
  // 
  // Succeeds if all of the following are true:
  // - this object has already been initialized.
  // - the pComponent pointer is valid.
  // 
  // If this method fails no state is changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - Initialize() has already been called on this object.
  //
  // AAFRESULT_NULL_PARAM
  //   - pComponent is null.
  //
  // AAFRESULT_INVALID_DATADEF
  //   - The data kind of the component is not compatible with the 
  //     data def of the sequence.
  //
  // AAFRESULT_LEADING_TRAN
  //   - Attempted to append a transition as the first component of
  //     a sequence.  A sequence can not start with a transition. 
  //
  // AAFRESULT_ADJACENT_TRAN
  //   - Attempted to append a transition next to a transition.  A
  //     sequence can not contain back to back transitions.
  //
  // AAFRESULT_INSUFF_TRAN_MATERIAL
  //   - There is not enough source material to add this component.
  //
  STDMETHOD(PrependComponent) (THIS_
    // Component to prepend to the sequence
    /*[in]*/ IAAFComponent * pComponent) PURE;


  //***********************************************************
  //
  // InsertComponentAt()
  //
  // This function inserts the input component into the given sequence
  // at the given index, enforcing bottom up creation of mobs.  The
  // length of the sequence is incremented by the size of the
  // component, unless the component is a transition.  If the
  // component is a transition, it verifies that it is not the first
  // object in a transition, and that it is not neighboring another
  // transition.  It also verifies that there is enough source
  // material on either side of the transition.  The function also
  // verifies that the datadefs are compatible.
  //
  // This method will AddRef() the component if it succeeds.
  //
  // If the component is successfully appended to the sequence, the
  // reference count of the component is incremented.
  // 
  // Succeeds if all of the following are true:
  // - this object has already been initialized.
  // - the pComponent pointer is valid.
  // - index is less than or equal to the value returned by
  //   CountComponents().
  // 
  // If this method fails no state is changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - Initialize() has already been called on this object.
  //
  // AAFRESULT_NULL_PARAM
  //   - pComponent is null.
  //
  // AAFRESULT_BADINDEX
  //   - index is greater than the value returned by
  //     CountComponents().
  //
  // AAFRESULT_INVALID_DATADEF
  //   - The data kind of the component is not compatible with the 
  //     data def of the sequence.
  //
  // AAFRESULT_LEADING_TRAN
  //   - Attempted to append a transition as the first component of
  //     a sequence.  A sequence can not start with a transition. 
  //
  // AAFRESULT_ADJACENT_TRAN
  //   - Attempted to append a transition next to a transition.  A
  //     sequence can not contain back to back transitions.
  //
  // AAFRESULT_INSUFF_TRAN_MATERIAL
  //   - There is not enough source material to add this component.
  //
  STDMETHOD(InsertComponentAt) (THIS_
    // index to insert component
    /*[in]*/ aafUInt32  index,

    // Component to insert into the sequence
    /*[in]*/ IAAFComponent * pComponent) PURE;


  //***********************************************************
  //
  // GetComponentAt()
  //
  // This function retrieves the input component at the given index in
  // the given sequence.
  // 
  // Succeeds if all of the following are true:
  // - this object has already been initialized.
  // - the ppComponent pointer is valid.
  // - index is less than the value returned by
  //   CountComponents().
  // 
  // If this method fails nothing will be written to *ppComponent.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - Initialize() has already been called on this object.
  //
  // AAFRESULT_NULL_PARAM
  //   - pComponent is null.
  //
  // AAFRESULT_BADINDEX
  //   - index is greater than or equal to the value returned by
  //     CountComponents().
  //
  STDMETHOD(GetComponentAt) (THIS_
    // index of component to retrieve
    /*[in]*/ aafUInt32  index,

    // Retrieved component
    /*[out, retval]*/ IAAFComponent ** ppComponent) PURE;


  //***********************************************************
  //
  // RemoveComponentAt()
  //
  // This function removes the input component at the given index in
  // the given sequence.  Components already existing at indices
  // higher than the given index will be moved to the next lower index
  // to accommodate.
  // 
  // Succeeds if all of the following are true:
  // - this object has already been initialized.
  // - index is less than the value returned by
  //   CountComponents().
  // 
  // If this method fails no state will be changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - Initialize() has already been called on this object.
  //
  // AAFRESULT_BADINDEX
  //   - index is greater than or equal to the value returned by
  //     CountComponents().
  //
  STDMETHOD(RemoveComponentAt) (THIS_
    // index of component to remove
    /*[in]*/ aafUInt32  index) PURE;


  //***********************************************************
  //
  // CountComponents()
  //
  // This function returns the number of components in the sequence.
  // 
  // Succeeds if all of the following are true:
  // - this object has already been initialized.
  // - the pResult pointer is valid.
  // 
  // If this method fails no state is changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - Initialize() has already been called on this object.
  //
  // AAFRESULT_NULL_PARAM
  //   - pResult is null.
  //
  STDMETHOD(CountComponents) (THIS_
    // Number of components
    /*[out]*/ aafUInt32 *  pResult) PURE;


  //***********************************************************
  //
  // GetComponents()
  //
  // Places an IEnumAAFComponents enumerator for the components
  // contained in the sequence into the *ppEnum argument.
  // 
  // The returned enumerator is AddRef()ed before it is returned.
  //
  // Succeeds if all of the following are true:
  // - this object has already been initialized.
  // - the ppEnum pointer is valid.
  // 
  // If this method fails nothing will be written to *ppEnum.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - Initialize() has already been called on this object.
  //
  // AAFRESULT_NULL_PARAM
  //   - ppEnum is null.
  //
  // E_FAIL
  //   - Failed to create the enumerator.
  //
  STDMETHOD(GetComponents) (THIS_
    // Component Enumeration
    /*[out, retval]*/ IEnumAAFComponents ** ppEnum) PURE;







  END_INTERFACE
};
#endif // __IAAFSequence_INTERFACE_DEFINED__



// IAAFSourceClip

// ************************
//
// Interface IAAFSourceClip
//
// ************************





#ifndef __IAAFSourceClip_INTERFACE_DEFINED__
#define __IAAFSourceClip_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFSourceClip;

#undef  INTERFACE
#define INTERFACE   IAAFSourceClip

DECLARE_INTERFACE_(IAAFSourceClip, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFSourceClip methods *** */

  //***********************************************************
  //
  // Initialize()
  //
  // This method initializes a source clip object with
  // the given properties.  Only required properties are set.
  // Optional properties are added with separate functions.
  //
  // Succeds if:
  // - This object has not already been Initialize()d.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_ALREADY_INITIALIZED
  //   - Initialize() has already been called on this object.
  //
  // AAFRESULT_NULL_PARAM
  //   - pDataDef argument is NULL.
  //
  STDMETHOD(Initialize) (THIS_
    // Data Definition object
    /*[in]*/ IAAFDataDef * pDataDef,

    // Length property value
    /*[in]*/ aafLength_constref  length,

    // Source Reference
    /*[in]*/ aafSourceRef_t  sourceRef) PURE;


  //***********************************************************
  //
  // GetFade()
  //
  // This function returns the optional fade information from a
  // source clip.  This function only applies to audio source clips.
  // Length units are specified by the containing mob slot's edit
  // rate.
  //
  // Succeeds if all of the following are true:
  // - This object has already been Initialize()d.
  // - the all argument pointers are valid.
  // 
  // If this method fails nothing will be written to any of the
  // locations specified by the arguments.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - any argument is NULL.
  //
  STDMETHOD(GetFade) (THIS_
    // Fade In Length
    /*[out]*/ aafLength_t *  pFadeInLen,

    // Fade In Type
    /*[out]*/ aafFadeType_t *  pFadeInType,

    // Fade In Type
    /*[out]*/ aafBoolean_t *  pFadeInPresent,

    // Fade Out Length
    /*[out]*/ aafLength_t *  pFadeOutLen,

    // Fade Out Type
    /*[out]*/ aafFadeType_t *  pFadeOutType,

    // Fade In Type
    /*[out]*/ aafBoolean_t *  pFadeOutPresent) PURE;


  //***********************************************************
  //
  // ResolveRef()
  //
  // Given a source clip object, this function returns a pointer
  // to the mob that it references.
  //
  // The returned mob is AddRef()ed before it is returned.
  //
  // Succeeds if all of the following are true:
  // - This object has already been Initialize()d.
  // - the ppMob pointer is valid.
  // 
  // If this method fails nothing will be written to *ppMob.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - ppMob arg is NULL.
  //
  // AAFRESULT_MOB_NOT_FOUND
  //   - this mob does not exist.
  //
  STDMETHOD(ResolveRef) (THIS_
    // Referenced mob
    /*[out]*/ IAAFMob ** ppMob) PURE;


  //***********************************************************
  //
  // GetSourceReference()
  //
  // // This function returns the source reference of this source clip.
  //
  // Note: the 3 properties of a source Clip that make up the "source
  // reference" are sourceID, sourceTrackID, and startTime.
  //
  // Succeeds if all of the following are true:
  // - This object has already been Initialize()d.
  // - the pSourceRef pointer is valid.
  // 
  // If this method fails nothing will be written to *pSourceRef.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pSourceRef arg is NULL.
  //
  STDMETHOD(GetSourceReference) (THIS_
    // Source Reference
    /*[out]*/ aafSourceRef_t *  pSourceRef) PURE;


  //***********************************************************
  //
  // SetFade()
  //
  // This function sets the optional fade properties on this source
  // clip object.  The fade properties only apply to a source clip of
  // data definition (or convertible to a data definition) of type
  // Sound.  All arguments should be specified.  Length units are
  // specified by the containing mob slot's edit rate.
  // 
  // Succeeds if all of the following are true:
  // - This object has already been Initialize()d.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  STDMETHOD(SetFade) (THIS_
    // Fade In Length
    /*[in]*/ aafInt32  fadeInLen,

    // Fade In Type
    /*[in]*/ aafFadeType_t  fadeInType,

    // Fade Out Length
    /*[in]*/ aafInt32  fadeOutLen,

    // Fade Out Type
    /*[in]*/ aafFadeType_t  fadeOutType) PURE;


  //***********************************************************
  //
  // SetSourceReference()
  //
  // This function sets the source reference of this source clip.
  //
  // Note: the  3 properties of a source Clip that make up the "source
  // reference" are sourceID, sourceTrackID, and startTime.
  // 
  // Succeeds if all of the following are true:
  // - This object has already been Initialize()d.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  STDMETHOD(SetSourceReference) (THIS_
    // Source Reference
    /*[in]*/ aafSourceRef_t  sourceRef) PURE;

  END_INTERFACE
};
#endif // __IAAFSourceClip_INTERFACE_DEFINED__



// IAAFSourceMob

// ************************
//
// Interface IAAFSourceMob
//
// ************************








#ifndef __IAAFSourceMob_INTERFACE_DEFINED__
#define __IAAFSourceMob_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFSourceMob;

#undef  INTERFACE
#define INTERFACE   IAAFSourceMob

DECLARE_INTERFACE_(IAAFSourceMob, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFSourceMob methods *** */
  //***********************************************************
  //
  // Initialize()
  //
  // Initializes a newly allocated, empty IAAFSourceMob-supporting
  // object.  This method must be called after allocation, and before
  // any other method can be called.
  //
  // Succeeds if:
  // - Initialize() has not yet been called on this object.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_ALREADY_INITIALIZED
  //   - Initialize() has already been called on this object.
  STDMETHOD(Initialize) (THIS) PURE;


  //***********************************************************
  //
  // GetEssenceDescriptor()
  //
  // Places the Essence Descriptor object attached to this Mob into the
  // *ppEssence argument.  If none exists yet, NULL is placed into the
  // *ppEssence argument.
  //
  // The returned essence descriptor object, if it exists, is
  // AddRef()ed before it is returned.
  //
  // Succeeds if all of the following are true:
  // - the ppEssence pointer is valid.
  // - A valid essence descriptor exists.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - ppEssence is null.
  //
  // AAFRESULT_NO_ESSENCE_DESC
  //   - There is no essence descriptor.  There has to be one of some
  //     kind for this to be a valid Mob.
  //
  STDMETHOD(GetEssenceDescriptor) (THIS_
    // Returned Essence Descriptor object
    /*[out]*/ IAAFEssenceDescriptor ** ppEssence) PURE;


  //***********************************************************
  //
  // SetEssenceDescriptor()
  //
  // Sets the Essence Descriptor of this Mob to be the given one.
  //
  // Succeeds if all of the following are true:
  // - the pEssence pointer is valid.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pEssence is null.
  //
  STDMETHOD(SetEssenceDescriptor) (THIS_
    // Essence Descriptor object
    /*[in]*/ IAAFEssenceDescriptor * pEssence) PURE;


  //***********************************************************
  //
  // AddNilReference()
  //
  // This function adds a slot containing a NIL [sourceID 0.0....]
  // Source Clip.  This special SourceID indicates that the mob chain
  // ends here, which indicates that no record exists of what the
  // essence was derived from.  Some AAFSourceClip is still required
  // on the track to indicate that the track exists, and may be
  // referenced from other Mobs.
  //
  // Examples of Source Mobs that are not derived from a previous
  // source of essence are: Tape Source Mobs that were not created
  // from film; File Source Mobs whose digital essence data was
  // originally generated by computer and was not digitized from
  // videotape.
  //
  // Succeeds if all of the following are true:
  // - The pDataDef parameter is valid.
  // - editRate is valid.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - the pDataDef parameter is NULL.
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_BADRATE
  //   - the editRate is not valid.
  //
  STDMETHOD(AddNilReference) (THIS_
    // SlotID to be assigned to the new slot
    /*[in]*/ aafSlotID_t  slotID,

    // Duration of the Source Clip to be added to the new slot
    /*[in]*/ aafLength_t  length,

    // Data definition of the new slot
    /*[in]*/ IAAFDataDef * pDataDef,

    // Edit rate of the new slot
    /*[in]*/ aafRational_t  editRate) PURE;


  //***********************************************************
  //
  // AppendTimecodeSlot()
  //
  // This function adds a Timecode slot to a specified tape Mob or
  // film Mob, with a specified starting timecode, length, and edit
  // rate.  Your must also call SpecifyValidCodeRange to add the
  // Filler to the other essence slots to indicate that the Timecode
  // is valid for that channel.
  // 
  // Note: The startTC parameter is expressed in frames since
  // midnight.
  // 
  // The length32 parameter can be the value FULL_RANGE, in which
  // case the length is 24 hours.
  //
  // Succeeds if all of the following are true:
  // - The specified slot ID is not yet used.
  // - This source mob references an AAFTapeDescriptor as an essence
  //   descriptor.
  // 
  // If this method fails no state is changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_SLOT_EXISTS
  //   - The specified slotID already exists.
  //
  // AAFRESULT_TAPEDESC_ONLY
  //   - Valid only for AAFSourceMob referencing an AAFTapeDescriptor
  //     as EssenceDescriptor.
  //
  STDMETHOD(AppendTimecodeSlot) (THIS_
    // Edit rate of Timecode slot
    /*[in]*/ aafRational_t  editrate,

    // SlotID of Timecode slot
    /*[in]*/ aafInt32  slotID,

    // Starting time code
    /*[in]*/ aafTimecode_t  startTC,

    // Duration of Timecode.
    /*[in]*/ aafFrameLength_t  length32) PURE;


  //***********************************************************
  //
  // AppendEdgecodeSlot()
  //
  // Adds an Edgecode slot to a specified film Mob, with a specified
  // starting edgecode, length, and edit rate. You must add a essence
  // slot with SpecifyValidCodeRange to make the edgecode slot valid.
  //
  // Succeeds if all of the following are true:
  // - The specified slot ID is not yet used.
  // - This source mob references an AAFFilmDescriptor as an essence
  //   descriptor.
  // 
  // If this method fails no state is changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_SLOT_EXISTS
  //   - The specified slotID already exists.
  //
  // AAFRESULT_FILMDESC_ONLY
  //   - Valid only for AAFSourceMob referencing an AAFFilmDescriptor
  //   as EssenceDescriptor.
  //
  STDMETHOD(AppendEdgecodeSlot) (THIS_
    // Edit rate of the Edgecode slot
    /*[in]*/ aafRational_t  editrate,

    // SlotID to assign to the new Edgecode slot
    /*[in]*/ aafInt32  slotID,

    // Starting Edgecode
    /*[in]*/ aafFrameOffset_t  startEC,

    // Length of the Edgecode component in the slot
    /*[in]*/ aafFrameLength_t  length32,

    // The film kind.  Can be one of:
	// - kFtNull
    // - kFt35MM
    // - kFt16MM
    // - kFt8MM
    // - kFt65MM
    /*[in]*/ aafFilmType_t  filmKind,

    // The code format.  Can be one of:
    // - kEtNull
    // - kEtKeycode
    // - kEtEdgenum4
    // - kEtEdgenum5
    /*[in]*/ aafEdgeType_t  codeFormat,

    // The Edgecode's 8-byte header
    /*[in]*/ aafEdgecodeHeader_t  header) PURE;


  //***********************************************************
  //
  // SpecifyValidCodeRange()
  //
  // Adds slot containing Source Clips to a Source Mob to indicate
  // that the Timecode or Edgecode is valid for that channel.
  //
  // Note: The pEssenceKind parameter requires a data kind valid for a
  // essence stream.  Valid data kinds are:
  // - Picture
  // - Sound
  //
  // Succeeds if all of the following are true:
  // - the pEssenceKind pointer is valid.
  // - The specified slot ID is not yet used.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pEssenceKind is null.
  //
  // AAFRESULT_SLOT_EXISTS
  //   - The specified slotID already exists.
  //
  STDMETHOD(SpecifyValidCodeRange) (THIS_
    // Data kind for the slot to be added
    /*[in]*/ IAAFDataDef * pEssenceKind,

    // SlotID for the slot to be added
    /*[in]*/ aafSlotID_t  slotID,

    // Edit rate for the slot to be added
    /*[in]*/ aafRational_t  editrate,

    // Start offset for the slot to be added
    /*[in]*/ aafFrameOffset_t  startOffset,

    // Duration of the Source Clip in the slot
    /*[in]*/ aafFrameLength_t  length32) PURE;


  //***********************************************************
  //
  // AppendPhysSourceRef()
  //
  // Connects this Source Mob with the physical Source Mob that
  // describes the previous generation of essence, appending it to
  // existing Mob data.  If a physical Source Mob, such as a File
  // Source Mob or tape Source Mob, references another physical
  // Source Mob as its ancestor, with no pulldown, then this
  // function makes the connection between the two.
  //
  // Functionally, this is a helper function to create a slot with an
  // AAFSourceClip referencing a particular piece of media.  This
  // function takes many parameters because the components of an
  // aafSourceRef_t have been broken out as separate parameters.
  //
  // The ancestor of an AAFSourceMob with an AAFFileDescriptor is often an
  // AAFTapeDescriptor or NIL.
  //
  // Succeeds if all of the following are true:
  // - the pSourceRefObj pointer is valid.
  // - the pEssenceKind pointer is valid.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pSourceRefObj or pEssenceKind is null.
  //
  STDMETHOD(AppendPhysSourceRef) (THIS_
    // Edit rate of slot to contain reference
    /*[in]*/ aafRational_t  editrate,

    // SlotID of slot to contain reference
    /*[in]*/ aafSlotID_t  aMobSlot,

    // Data kind of slot to contain reference.  Requires a data kind
	// valid for a essence stream.  Valid data kinds are:
    // - Picture
    // - Sound
    /*[in]*/ IAAFDataDef * pEssenceKind,

    // Reference to a Physical Source Mob
    /*[in]*/ aafSourceRef_t  ref,

    // Length of the Source Clip
    /*[in]*/ aafLength_t  srcRefLength) PURE;


  //***********************************************************
  //
  // NewPhysSourceRef()
  //
  // Connects this Source Mob with the physical Source Mob that
  // describes the previous generation of essence, replacing any
  // existing Mob data.  If a physical Source Mob, such as a File
  // Source Mob or tape Source Mob, references another physical
  // Source Mob as its ancestor, with no pulldown, then this
  // function makes the connection between the two.
  //
  // Functionally, this is a helper function to create a slot with an
  // AAFSourceClip referencing a particular piece of media.  This
  // function takes many parameters because the components of an
  // aafSourceRef_t have been broken out as separate parameters.
  //
  // The ancestor of an AAFSourceMob with an AAFFileDescriptor is often an
  // AAFTapeDescriptor or NIL.
  //
  // Succeeds if all of the following are true:
  // - the pSourceRefObj pointer is valid.
  // - the pEssenceKind pointer is valid.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pSourceRefObj or pEssenceKind is null.
  //
  STDMETHOD(NewPhysSourceRef) (THIS_
    // Edit rate of slot to contain reference
    /*[in]*/ aafRational_t  editrate,

    // SlotID of slot to contain reference
    /*[in]*/ aafSlotID_t  aMobSlot,

    // Data kind of slot to contain reference.  Requires a data kind
	// valid for a essence stream.  Valid data kinds are:
    // - Picture
    // - Sound
    /*[in]*/ IAAFDataDef * pEssenceKind,

    // Reference to a Physical Source Mob
    /*[in]*/ aafSourceRef_t  ref,

    // Length of the Source Clip
    /*[in]*/ aafLength_t  srcRefLength) PURE;


  //***********************************************************
  //
  // AddPulldownRef()
  //
  // Connects the specified Source Mob with the physical Source Mob
  // that describes the previous generation of essence, with an
  // additional AAFPulldown as part of the reference to indicate a non
  // 1-1 relationship Between the two. 
  //
  // Functionally, this is a helper function to create a slot with an
  // AAFPulldown object which references an AAFSourceClip, which
  // references a particular piece of media.  This function takes many
  // parameters because the components of an aafSourceRef_t and the
  // AAFPulldown object have been broken out as separate parameters.
  //
  // The ancestor of an AAFSourceMob with an AAFTapeDescriptor is
  // often an AAFFilmDescriptor or NIL.
  //
  // Succeeds if all of the following are true:
  // - the pSourceRefObj pointer is valid.
  // - the pEssenceKind pointer is valid.
  // - a valid pulldown direction was specified.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pSourceRefObj or pEssenceKind is null.
  //
  // AAFRESULT_PULLDOWN_DIRECTION
  //   - an invalid pulldown direction was specified.
  //
  STDMETHOD(AddPulldownRef) (THIS_
    // Tells whether to overwrite an existing slot segment, or create
	// a sequence and append
    /*[in]*/ aafAppendOption_t  addType,

    // Edit rate of slot to contain reference
    /*[in]*/ aafRational_t  editrate,

    // SlotID of slot to contain reference
    /*[in]*/ aafSlotID_t  aMobSlot,

    // Data kind of slot to contain reference.  Requires a data kind
	// valid for a essence stream.  Valid data kinds are:
    // - Picture
    // - Sound
    /*[in]*/ IAAFDataDef * pEssenceKind,

    // Reference to a Physical Source Mob
    /*[in]*/ aafSourceRef_t  ref,

    // Length of the Source Clip in the Source Mob
    /*[in]*/ aafLength_t  srcRefLength,

    // Method of conversion.  Possible values are:
    // - kAAFTwoThreePD   	-- Normal NTSC-20fps pulldown
    // - kAAFPALPD
    // - kAAFOneToOneNTSC   -- NTSC recorded as 1 frame == 1 film frame.
    // - kAAFOneToOnePAL    -- PAL recorded as 1 frame == 1 film frame.
    /*[in]*/ aafPulldownKind_t  pulldownKind,

    // phase of first frame
    /*[in]*/ aafPhaseFrame_t  phaseFrame,

    // Direction of the pulldown conversion. Possible values are:
    //	- kAAFTapeToFilmSpeed -- Used to link a file descriptor with a
    //							 tape descriptor.
    //	- kAAFFilmToTapeSpeed -- Used to link a tape descriptor with a
    //							 film descriptor.
    /*[in]*/ aafPulldownDir_t  direction) PURE;


  END_INTERFACE
};
#endif // __IAAFSourceMob_INTERFACE_DEFINED__



// IAAFSourceReference

// ************************
//
// Interface IAAFSourceReference
//
// ************************



#ifndef __IAAFSourceReference_INTERFACE_DEFINED__
#define __IAAFSourceReference_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFSourceReference;

#undef  INTERFACE
#define INTERFACE   IAAFSourceReference

DECLARE_INTERFACE_(IAAFSourceReference, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFSourceReference methods *** */

  //***********************************************************
  //
  // GetSourceID()
  //
  // Gets the SourceID and places it into the pSourceID argument.
  //
  // Succeeds if all of the following are true:
  // - the pSourceID pointer is valid.
  // 
  // If this method fails nothing will be written to *pSourceID.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pSourceID arg is NULL.
  //
  STDMETHOD(GetSourceID) (THIS_
    // Place to put source ID
    /*[retval][out]*/ aafMobID_t *  pSourceID) PURE;


  //***********************************************************
  //
  // SetSourceID()
  //
  // Sets the SourceID using the sourceID argument.
  // 
  // Always succeeds.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  STDMETHOD(SetSourceID) (THIS_
    // Source ID to set
    /*[in]*/ aafMobID_constref   sourceID) PURE;


  //***********************************************************
  //
  // GetSourceMobSlotID()
  //
  // Gets the Mob Slot ID and places it into the pMobSlotID argument.
  //
  // Succeeds if all of the following are true:
  // - the pMobSlotID pointer is valid.
  // 
  // If this method fails nothing will be written to *pMobSlotID.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pMobSlotID arg is NULL.
  //
  STDMETHOD(GetSourceMobSlotID) (THIS_
    // Place to put source mob slot ID
    /*[retval][out]*/ aafSlotID_t *  pMobSlotID) PURE;


  //***********************************************************
  //
  // SetSourceMobSlotID()
  //
  // Sets the mob slot ID using the mobSlotID argument.
  // 
  // Succeeds if all of the following are true:
  // - (preconditions here)
  // 
  // If this method fails no state will be changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // (other error codes here.)
  //
  STDMETHOD(SetSourceMobSlotID) (THIS_
    // Source Mob ID to set
    /*[in]*/ aafSlotID_t   mobSlotID) PURE;

  END_INTERFACE
};
#endif // __IAAFSourceReference_INTERFACE_DEFINED__



// IAAFStaticMobSlot

// ************************
//
// Interface IAAFStaticMobSlot
//
// ************************





#ifndef __IAAFStaticMobSlot_INTERFACE_DEFINED__
#define __IAAFStaticMobSlot_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFStaticMobSlot;

#undef  INTERFACE
#define INTERFACE   IAAFStaticMobSlot

DECLARE_INTERFACE_(IAAFStaticMobSlot, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFStaticMobSlot methods *** */



  END_INTERFACE
};
#endif // __IAAFStaticMobSlot_INTERFACE_DEFINED__



// IAAFTapeDescriptor

// ************************
//
// Interface IAAFTapeDescriptor
//
// ************************




#ifndef __IAAFTapeDescriptor_INTERFACE_DEFINED__
#define __IAAFTapeDescriptor_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFTapeDescriptor;

#undef  INTERFACE
#define INTERFACE   IAAFTapeDescriptor

DECLARE_INTERFACE_(IAAFTapeDescriptor, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFTapeDescriptor methods *** */

  //***********************************************************
  //
  // Initialize()
  //
  // Initializes a newly allocated, empty
  // IAAFTapeDescriptor-supporting object.  This method must be called
  // after allocation, and before any other method can be called.
  //
  // Succeeds if:
  // - Initialize() has not yet been called on this object.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_ALREADY_INITIALIZED
  //   - Initialize() has already been called on this object.
  STDMETHOD(Initialize) (THIS) PURE;


  //***********************************************************
  //
  // SetTapeManufacturer()
  //
  // Sets the Tape Manufacturer string property.
  //
  // Set the TapeManufacturer property to the value specified in
  // pTapeManufacturer.  A copy is made of the data so the caller
  // retains ownership of the *pTapeManufacturer buffer and is
  // responsible for de-allocating it.  There is no pre-set limit to
  // the length of the name, other than available system memory or
  // disk space.
  // 
  // Succeeds if all of the following are true:
  // - the pTapeManufacturer pointer is valid.
  // 
  // If this method fails the TapeManufacturer property will not be
  // changed.
  // 
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pTapeManufacturer arg is NULL.
  //
  STDMETHOD(SetTapeManufacturer) (THIS_
    // buffer from which TapeManufacturer is to be read
    /*[in, string]*/ aafCharacter_constptr  pTapeManufacturer) PURE;


  //***********************************************************
  //
  // GetTapeManufacturer()
  //
  // Gets the Tape Manufacturer string property.
  // 
  // Writes the TapeManufacturer property, with a trailing null
  // character, into the pTapeManufacturer buffer.  The
  // buffer is allocated by the caller.  The size of the buffer is
  // given by bufSize.  If the TapeManufacturer property has not yet
  // been set, a zero-length string will be written (that is,
  // only the trailing null character). 
  // 
  // Caller may call GetTapeManufacturerBufLen() to determine the
  // required buffer size.
  // 
  // If this method fails nothing will be written to
  // *pTapeManufacturer.
  // 
  // Succeeds if:
  // - The pTapeManufacturer pointer is valid.
  // - bufSize indicates that the buffer is large enough to hold
  //   TapeManufacturer.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pTapeManufacturer arg is NULL.
  //
  // AAFRESULT_SMALL_BUF
  //   - bufSize indicates that the allocated buffer is not large
  //     enough to hold TapeManufacturer.
  //
  STDMETHOD(GetTapeManufacturer) (THIS_
    // buffer into which TapeManufacturer is to be written
    /*[out, string, size_is(bufSize)]*/ aafCharacter *  pTapeManufacturer,

    // size of *pTapeManufacturer buffer in bytes
    /*[in]*/ aafUInt32  bufSize) PURE;


  //***********************************************************
  //
  // GetTapeManufacturerBufLen()
  //
  // Returns size of buffer (in bytes) required for GetTapeManufacturer().
  // 
  // Succeeds if:
  // - The pBufSize pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pBufSize arg is NULL.
  //
  STDMETHOD(GetTapeManufacturerBufLen) (THIS_
    // size of required buffer, in bytes
    /*[out]*/ aafUInt32 *  pBufSize) PURE;


  //***********************************************************
  //
  // SetTapeModel()
  //
  // Sets the Tape Model string property.
  //
  // Set the TapeModel property to the value specified in
  // pTapeModel.  A copy is made of the data so the caller
  // retains ownership of the *pTapeModel buffer and is
  // responsible for de-allocating it.  There is no pre-set limit to
  // the length of the name, other than available system memory or
  // disk space.
  // 
  // Succeeds if all of the following are true:
  // - the pTapeModel pointer is valid.
  // 
  // If this method fails the TapeModel property will not be
  // changed.
  // 
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pTapeModel arg is NULL.
  //
  STDMETHOD(SetTapeModel) (THIS_
    // buffer from which TapeModel is to be read
    /*[in, string]*/ aafCharacter_constptr  pTapeModel) PURE;


  //***********************************************************
  //
  // GetTapeModel()
  //
  // Gets the Tape Model string property.
  // 
  // Writes the TapeModel property, with a trailing null
  // character, into the pTapeModel buffer.  The
  // buffer is allocated by the caller.  The size of the buffer is
  // given by bufSize.  If the TapeModel property has not yet
  // been set, a zero-length string will be written (that is,
  // only the trailing null character). 
  // 
  // Caller may call GetTapeModelBufLen() to determine the
  // required buffer size.
  // 
  // If this method fails nothing will be written to
  // *pTapeModel.
  // 
  // Succeeds if:
  // - The pTapeModel pointer is valid.
  // - bufSize indicates that the buffer is large enough to hold
  //   TapeModel.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pTapeModel arg is NULL.
  //
  // AAFRESULT_SMALL_BUF
  //   - bufSize indicates that the allocated buffer is not large
  //     enough to hold TapeModel.
  //
  STDMETHOD(GetTapeModel) (THIS_
    // buffer into which TapeModel is to be written
    /*[out, string, size_is(bufSize)]*/ aafCharacter *  pTapeModel,

    // size of *pTapeModel buffer in bytes
    /*[in]*/ aafUInt32  bufSize) PURE;


  //***********************************************************
  //
  // GetTapeModelBufLen()
  //
  // Returns size of buffer (in bytes) required for GetTapeModel().
  // 
  // Succeeds if:
  // - The pBufSize pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pBufSize arg is NULL.
  //
  STDMETHOD(GetTapeModelBufLen) (THIS_
    // size of required buffer, in bytes
    /*[out]*/ aafUInt32 *  pBufSize) PURE;


  //***********************************************************
  //
  // SetTapeFormFactor()
  //
  // Sets the form factor [case size] of the tape.
  // 
  // This method succeeds if all of the following are true:
  // - formFactor represents a valid format.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_BAD_TYPE
  //	- formFactor is invalid.
  //
  STDMETHOD(SetTapeFormFactor) (THIS_
    // ex: kVHSVideoTape, kDATCartridge 
    /*[in]*/ aafTapeCaseType_t  formFactor) PURE;


  //***********************************************************
  //
  // GetTapeFormFactor()
  //
  // Gets the form factor [case size] of the tape.
  // 
  // This method succeeds if all of the following are true:
  // - the pFormFactor pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pFormFactor arg is NULL.
  //
  STDMETHOD(GetTapeFormFactor) (THIS_
    // ex: kVHSVideoTape, kDATCartridge
    /*[out]*/ aafTapeCaseType_t *  formFactor) PURE;


  //***********************************************************
  //
  // SetSignalType()
  //
  // Sets the signal standard recorded on the tape.
  // 
  // This method succeeds if all of the following are true:
  //	videoSignal represents a valid video signal type.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_BAD_TYPE
  //	- videoSignal is invalid.
  //
  STDMETHOD(SetSignalType) (THIS_
    // ex: kNTSCSignal
    /*[in]*/ aafVideoSignalType_t  videoSignal) PURE;


  //***********************************************************
  //
  // GetSignalType()
  //
  // Gets the signal standard recorded on the tape.
  // 
  // This method succeeds if all of the following are true:
  // - the pVideoSignal pointer is valid.
  //
  // If this method fails nothing will be written to *pVideoSignal.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pVideoSignal arg is NULL.
  //
  STDMETHOD(GetSignalType) (THIS_
    // ex: kNTSCSignal
    /*[out]*/ aafVideoSignalType_t *  pVideoSignal) PURE;


  //***********************************************************
  //
  // SetTapeFormat()
  //
  // Sets the recording method of the tape.
  // 
  // This method succeeds if all of the following are true:
  // - tapeFormat represents a valid tape format type.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_BAD_TYPE
  //	- tapeFormat is invalid.
  //
  STDMETHOD(SetTapeFormat) (THIS_
    // ex: kBetacamFormat, kBetacamSPFormat
    /*[in]*/ aafTapeFormatType_t  tapeFormat) PURE;


  //***********************************************************
  //
  // GetTapeFormat()
  //
  // Gets the recording method of the tape.
  //
  // Succeeds if all of the following are true:
  // - the pTapeFormat pointer is valid.
  // 
  // This method succeeds if all of the following are true:
  // - the pTapeFormat pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pTapeFormat arg is NULL.
  //
  STDMETHOD(GetTapeFormat) (THIS_
    // ex: kBetacamFormat, kBetacamSPFormat
    /*[out]*/ aafTapeFormatType_t *  pTapeFormat) PURE;


  //***********************************************************
  //
  // SetTapeLength()
  //
  // Sets the length of the tape in minutes.
  // 
  // This method succeeds if all of the following are true:
  // - tapeLength is a positive number.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_BAD_LENGTH
  //	- tapeLength is negative.
  //
  STDMETHOD(SetTapeLength) (THIS_
    // The length of the tape in minutes.
    /*[in]*/ aafUInt32  tapeLength) PURE;


  //***********************************************************
  //
  // GetTapeLength()
  //
  // Gets the length of the tape in minutes.
  //
  // This method succeeds if all of the following are true:
  // - the pTapeLength pointer is valid.
  // 
  // If this method fails nothing will be written to *pTapeLength.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pTapeLength arg is NULL.
  //
  STDMETHOD(GetTapeLength) (THIS_
    // The length of the tape in minutes.
    /*[out]*/ aafUInt32 *  pTapeLength) PURE;

  END_INTERFACE
};
#endif // __IAAFTapeDescriptor_INTERFACE_DEFINED__



// IAAFTaggedValue

// ************************
//
// Interface IAAFTaggedValue
//
// ************************




#ifndef __IAAFTaggedValue_INTERFACE_DEFINED__
#define __IAAFTaggedValue_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFTaggedValue;

#undef  INTERFACE
#define INTERFACE   IAAFTaggedValue

DECLARE_INTERFACE_(IAAFTaggedValue, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFTaggedValue methods *** */

  //***********************************************************
  //
  // Initialize()
  //
  // Initializes a new tagged value object to be identified with the
  // given the given type, and with the given human-legible name.
  //
  // This method must be called after allocation, and before
  // any other method can be called.
  //
  // Succeeds if:
  // - Initialize() has not yet been called on this object.
  // - pName is a valid pointer.
  // - pTypeDef is a valid pointer and registered
  // - pValue is a valid pointer
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_ALREADY_INITIALIZED
  //   - This object has already had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pName or pTypeDef or pValue arg is NULL.
  // 
  //
  STDMETHOD(Initialize) (THIS_
    // User defined name (tag) of this tagged value object
    /*[in, string]*/ aafCharacter_constptr  pName,

    // Type Definition of the following value data
    /*[in]*/ IAAFTypeDef * pTypeDef,

    // Size of preallocated buffer
    /*[in]*/ aafUInt32  valueSize,

    // buffer containing value
    /*[in, size_is(valueSize)]*/ aafDataBuffer_t  pValue) PURE;


  //***********************************************************
  //
  // GetName()
  //
  // Gets the Name string property.
  // 
  // Writes the Name property, with a trailing null
  // character, into the pName buffer.  The
  // buffer is allocated by the caller.  The size of the buffer is
  // given by bufSize.  If the Name property has not yet
  // been set, a zero-length string will be written (that is,
  // only the trailing null character). 
  // 
  // Caller may call GetNameBufLen() to determine the
  // required buffer size.
  // 
  // If this method fails nothing will be written to
  // *pName.
  // 
  // Succeeds if:
  // - The pName pointer is valid.
  // - bufSize indicates that the buffer is large enough to hold
  //   Name.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pName arg is NULL.
  //
  // AAFRESULT_SMALL_BUF
  //   - bufSize indicates that the allocated buffer is not large
  //     enough to hold Name.
  //
  STDMETHOD(GetName) (THIS_
    // buffer into which Name is to be written
    /*[out, string, size_is(bufSize)]*/ aafCharacter *  pName,

    // size of *pName buffer in bytes
    /*[in]*/ aafUInt32  bufSize) PURE;


  //***********************************************************
  //
  // GetNameBufLen()
  //
  // Returns size of buffer (in bytes) required for GetName().
  // 
  // Succeeds if:
  // - The pBufSize pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pBufSize arg is NULL.
  //
  STDMETHOD(GetNameBufLen) (THIS_
    // size of required buffer, in bytes
    /*[out]*/ aafUInt32 *  pBufSize) PURE;


  //***********************************************************
  //
  // GetTypeDefinition()
  //
  // Returns the type definition for this invocation.
  // 
  // Succeeds if all of the following are true:
  // - the ppTypeDef pointer is valid.
  // 
  // If this method fails nothing will be written to *ppTypeDef.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  //
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_PROP_NOT_PRESENT
  //   - This property does not exist in the file.
  //
  // AAFRESULT_NULL_PARAM
  //   - ppTypeDef arg is NULL.
  //
  STDMETHOD(GetTypeDefinition) (THIS_
    // Type definition object
    /*[out]*/ IAAFTypeDef ** ppTypeDef) PURE;


  //***********************************************************
  //
  // GetValue()
  //
  // Writes the value into the pValue buffer.  The buffer is allocated
  // by the caller, and the size of the buffer is given by
  // valueSize.
  // 
  // Caller may call GetValueBufLen() to determine the
  // required buffer size.
  // 
  // Succeeds if all of the following are true:
  // - the pValue pointer is valid.
  // - valueSize indicates the buffer is large enough to hold the name.
  // 
  // If this method fails nothing will be written to *pValue.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pValue arg is NULL.
  //
  // AAFRESULT_SMALLBUF
  //   - valueSize indicates the buffer is too small to hold the value.
  //
  STDMETHOD(GetValue) (THIS_
    // Size of preallocated buffer
    /*[in]*/ aafUInt32  valueSize,

    // Preallocated buffer to hold value
    /*[out, size_is(valueSize), length_is(*bytesRead)]*/ aafDataBuffer_t  pValue,

    // Number of actual bytes read
    /*[out]*/ aafUInt32 *  bytesRead) PURE;


  //***********************************************************
  //
  // GetValueBufLen()
  //
  // Returns the length of buffer required for the GetValue() method.
  // The value is placed into the location specified by pLen.
  //
  // Succeeds if all of the following are true:
  // - the pLen pointer is valid.
  //
  // If this method fails nothing will be written to *pLen.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pLen arg is NULL.
  //
  STDMETHOD(GetValueBufLen) (THIS_
    // Pointer to an variable used to return the length
    /*[out]*/ aafUInt32 *  pLen) PURE;

  //***********************************************************
  //
  // SetValue()
  //
  // The data value is set from a buffer of size valueSize and type.
  //
  // Succeeds if all of the following are true:
  // - pTypeDef is valid and registered with the object's dictionary.
  // - the pValue pointer is valid.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - ppTypeDef is null.
  //
  STDMETHOD(SetValue) (THIS_
    // Size of preallocated buffer
    /*[in]*/ aafUInt32  valueSize,

    // buffer containing value
    /*[in, size_is(valueSize)]*/ aafDataBuffer_t  pValue) PURE;


  END_INTERFACE
};
#endif // __IAAFTaggedValue_INTERFACE_DEFINED__



// IAAFTextLocator

// ************************
//
// Interface IAAFTextLocator
//
// ************************




#ifndef __IAAFTextLocator_INTERFACE_DEFINED__
#define __IAAFTextLocator_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFTextLocator;

#undef  INTERFACE
#define INTERFACE   IAAFTextLocator

DECLARE_INTERFACE_(IAAFTextLocator, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFTextLocator methods *** */

  //***********************************************************
  //
  // Initialize()
  //
  // Initializes a newly allocated, empty
  // IAAFNetworkLocator-supporting object.  This method must be called
  // after allocation, and before any other method can be called.
  //
  // Succeeds if:
  // - Initialize() has not yet been called on this object.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_ALREADY_INITIALIZED
  //   - Initialize() has already been called on this object.
  STDMETHOD(Initialize) (THIS) PURE;


  //***********************************************************
  //
  // SetName()
  //
  // Sets the Name string property.
  //
  // Set the Name property to the value specified in
  // pName.  A copy is made of the data so the caller
  // retains ownership of the *pName buffer and is
  // responsible for de-allocating it.  There is no pre-set limit to
  // the length of the name, other than available system memory or
  // disk space.
  // 
  // Succeeds if all of the following are true:
  // - the pName pointer is valid.
  // 
  // If this method fails the Name property will not be
  // changed.
  // 
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pName arg is NULL.
  //
  STDMETHOD(SetName) (THIS_
    // buffer from which Name is to be read
    /*[in, string]*/ aafCharacter_constptr  pName) PURE;


  //***********************************************************
  //
  // GetName()
  //
  // Gets the Name string property.
  // 
  // Writes the Name property, with a trailing null
  // character, into the pName buffer.  The
  // buffer is allocated by the caller.  The size of the buffer is
  // given by bufSize.  If the Name property has not yet
  // been set, a zero-length string will be written (that is,
  // only the trailing null character). 
  // 
  // Caller may call GetNameBufLen() to determine the
  // required buffer size.
  // 
  // If this method fails nothing will be written to
  // *pName.
  // 
  // Succeeds if:
  // - The pName pointer is valid.
  // - bufSize indicates that the buffer is large enough to hold
  //   Name.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pName arg is NULL.
  //
  // AAFRESULT_SMALL_BUF
  //   - bufSize indicates that the allocated buffer is not large
  //     enough to hold Name.
  //
  STDMETHOD(GetName) (THIS_
    // buffer into which Name is to be written
    /*[out, string, size_is(bufSize)]*/ aafCharacter *  pName,

    // size of *pName buffer in bytes
    /*[in]*/ aafUInt32  bufSize) PURE;


  //***********************************************************
  //
  // GetNameBufLen()
  //
  // Returns size of buffer (in bytes) required for GetName().
  // 
  // Succeeds if:
  // - The pBufSize pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pBufSize arg is NULL.
  //
  STDMETHOD(GetNameBufLen) (THIS_
    // size of required buffer, in bytes
    /*[out]*/ aafUInt32 *  pBufSize) PURE;

  END_INTERFACE
};
#endif // __IAAFTextLocator_INTERFACE_DEFINED__



// IAAFTimecode

// ************************
//
// Interface IAAFTimecode
//
// ************************



#ifndef __IAAFTimecode_INTERFACE_DEFINED__
#define __IAAFTimecode_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFTimecode;

#undef  INTERFACE
#define INTERFACE   IAAFTimecode

DECLARE_INTERFACE_(IAAFTimecode, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFTimecode methods *** */

  //***********************************************************
  //
  // Initialize()
  //
  // Initializes this object with the given length and timecode
  // values.  Length is specified in units of the edit rate of the
  // containing timeline mob slot.
  // 
  // Succeeds if all of the following are true:
  // - this object has not yet been initialized.
  // - the pTimecode pointer is valid.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_ALREADY_INITIALIZED
  //   - Initialize() has already been called on this object.
  //
  // AAFRESULT_NULL_PARAM
  //   - pTimecode argument is NULL.
  //
  STDMETHOD(Initialize) (THIS_
    // Length Property Value
    /*[in]*/ aafLength_t  length,

    // Timecode Value (startFrame, drop, fps)
    /*[in]*/ aafTimecode_t*  pTimecode) PURE;


  //***********************************************************
  //
  // GetTimecode()
  //
  // Get the timecode fields.
  //
  // Succeeds if all of the following are true:
  // - the pTimecode pointer is valid.
  // 
  // If this method fails nothing will be written to *pTimecode.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - Initialize() has already been called on this object.
  //
  // AAFRESULT_NULL_PARAM
  //   - pTimecode arg is NULL.
  //
  STDMETHOD(GetTimecode) (THIS_
    // Timecode (startFrame, drop, fps)
    /*[out]*/ aafTimecode_t *  pTimecode) PURE;


  //***********************************************************
  //
  // SetTimecode()
  //
  // Set the timecode fields.
  // 
  // Succeeds if all of the following are true:
  // - the pTimecode pointer is valid.
  // 
  // If this method fails no state will be changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - Initialize() has already been called on this object.
  //
  // AAFRESULT_NULL_PARAM
  //   - pTimecode arg is NULL.
  //
  STDMETHOD(SetTimecode) (THIS_
    // Timecode (startFrame, drop, fps)
    /*[in]*/ aafTimecode_t *  timecode) PURE;





  END_INTERFACE
};
#endif // __IAAFTimecode_INTERFACE_DEFINED__



// IAAFTimelineMobSlot

// ************************
//
// Interface IAAFTimelineMobSlot
//
// ************************



#ifndef __IAAFTimelineMobSlot_INTERFACE_DEFINED__
#define __IAAFTimelineMobSlot_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFTimelineMobSlot;

#undef  INTERFACE
#define INTERFACE   IAAFTimelineMobSlot

DECLARE_INTERFACE_(IAAFTimelineMobSlot, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFTimelineMobSlot methods *** */

  //***********************************************************
  //
  // Initialize()
  //
  // Initializes a newly allocated, empty
  // IAAFTimelineMobSlot-supporting object.  This method must be
  // called after allocation, and before any other method can be
  // called.
  //
  // Succeeds if:
  // - Initialize() has not yet been called on this object.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_ALREADY_INITIALIZED
  //   - Initialize() has already been called on this object.
  STDMETHOD(Initialize) (THIS) PURE;


  //***********************************************************
  //
  // GetEditRate()
  //
  // This method will get the edit rate for this mob slot.
  // 
  // Succeeds if all of the following are true:
  // - the pEditRate pointer is valid.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pEditRate arg is NULL.
  //
  STDMETHOD(GetEditRate) (THIS_
    // Edit rate property value
    /*[out,retval]*/ aafRational_t *  pEditRate) PURE;


  //***********************************************************
  //
  // SetEditRate()
  //
  // This method will get set edit rate for this mob slot.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  STDMETHOD(SetEditRate) (THIS_
    // Edit rate property value
    /*[in]*/ aafRational_constref  editRate) PURE;


  //***********************************************************
  //
  // GetOrigin()
  //
  // This method will return the origin of this mob slot.
  // 
  // Succeeds if all of the following are true:
  // - the pOrigin pointer is valid.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pOrigin arg is NULL.
  //
  STDMETHOD(GetOrigin) (THIS_
    // Origin property value
    /*[out,retval]*/ aafPosition_t *  pOrigin) PURE;


  //***********************************************************
  //
  // SetOrigin()
  //
  // This method will set the origin of this mob slot.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.).
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  STDMETHOD(SetOrigin) (THIS_
    // Origin property value
    /*[in]*/ aafPosition_t  origin) PURE;

  END_INTERFACE
};
#endif // __IAAFTimelineMobSlot_INTERFACE_DEFINED__



// IAAFTransition

// ************************
//
// Interface IAAFTransition
//
// ************************








#ifndef __IAAFTransition_INTERFACE_DEFINED__
#define __IAAFTransition_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFTransition;

#undef  INTERFACE
#define INTERFACE   IAAFTransition

DECLARE_INTERFACE_(IAAFTransition, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFTransition methods *** */

  //***********************************************************
  //
  // Initialize()
  //
  // Constructor which allows specification of starting values.
  //
  STDMETHOD(Initialize) (THIS_
    // Data Definition Object
    /*[in]*/ IAAFDataDef * pDataDef,

    // Length property value
    /*[in]*/ aafLength_t  length,

    // The point at which a cut would be inserted if the transition
	// were removed
    /*[in]*/ aafPosition_t  cutPoint,

    // A reference to an operation group object
    /*[in]*/ IAAFOperationGroup * op) PURE;	 


  //***********************************************************
  //
  // GetCutPoint()
  //
  // Gets the point at which a cut would be inserted if the transition
  // were removed.
  //
  STDMETHOD(GetCutPoint) (THIS_
    // Cut Point
    /*[out]*/ aafPosition_t *  cutPoint) PURE;


  //***********************************************************
  //
  // GetOperationGroup()
  //
  // Gets the OperationGroup associated with the transition.
  //
  STDMETHOD(GetOperationGroup) (THIS_
    // OperationGroup used by transition
    /*[out]*/ IAAFOperationGroup ** groupObj) PURE;


  //***********************************************************
  //
  // SetCutPoint()
  //
  // Sets the point at which a cut would be inserted if the transition
  // were removed.
  //
  STDMETHOD(SetCutPoint) (THIS_
    // Cut Point
    /*[in]*/ aafPosition_t  cutPoint) PURE;


  //***********************************************************
  //
  // SetOperationGroup()
  //
  // Sets the operation group associated with the transition.
  //
  STDMETHOD(SetOperationGroup) (THIS_
    // Operation group used by transition
    /*[in]*/ IAAFOperationGroup * opgroup) PURE;

  END_INTERFACE
};
#endif // __IAAFTransition_INTERFACE_DEFINED__



// IAAFTIFFDescriptor

// ************************
//
// Interface IAAFTIFFDescriptor
//
// ************************


  


#ifndef __IAAFTIFFDescriptor_INTERFACE_DEFINED__
#define __IAAFTIFFDescriptor_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFTIFFDescriptor;

#undef  INTERFACE
#define INTERFACE   IAAFTIFFDescriptor

DECLARE_INTERFACE_(IAAFTIFFDescriptor, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFTIFFDescriptor methods *** */

  //***********************************************************
  //
  // SetIsUniform()
  //
  // Set to TRUE if essence data has the same number of rows per strip
  // throughout.
  //
  // Always succeeds.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  STDMETHOD(SetIsUniform) (THIS_
    // Sets the IsUniform flag value
    /*[in]*/ aafBoolean_t  IsUniform) PURE;


  //***********************************************************
  //
  // GetIsUniform()
  //
  // Places TRUE into *pIsUniform if the data has the same number of
  // rows per strip throughout.
  //
  // Succeeds if all of the following are true:
  // - the pIsUniform pointer is valid.
  // 
  // If this method fails nothing will be written to *pIsUniform.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pIsUniform arg is NULL.
  //
  STDMETHOD(GetIsUniform) (THIS_
    // Gets the IsUniform flag value
    /*[out]*/ aafBoolean_t *  pIsUniform) PURE;


  //***********************************************************
  //
  // SetIsContiguous()
  //
  // Set to TRUE if essence data is stored in contiguous bytes.
  // 
  // Always succeeds.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  STDMETHOD(SetIsContiguous) (THIS_
    // is data stores in contiguous bytes
    /*[in]*/ aafBoolean_t  IsContiguous) PURE;


  //***********************************************************
  //
  // GetIsContiguous()
  //
  // Places TRUE into *pIsContiguous if essence data is stored in
  // contiguous bytes.
  //
  // Succeeds if all of the following are true:
  // - the pIsContiguous pointer is valid.
  // 
  // If this method fails nothing will be written to *pIsContiguous.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pIsContiguous arg is NULL.
  //
  STDMETHOD(GetIsContiguous) (THIS_
    // is this data stored in contiguous bytes
    /*[out]*/ aafBoolean_t *  pIsContiguous) PURE;


  //***********************************************************
  //
  // SetLeadingLines()
  //
  // Sets the number of leading lines in the TIFF image file.
  // 
  // This method succeeds if all of the following are true:
  // - LeadingLines is  equal or greater than 0(zero).
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  STDMETHOD(SetLeadingLines) (THIS_
    // Number of leading lines to be thrown away Optional
    /*[in]*/ aafInt32  LeadingLines) PURE;


  //***********************************************************
  //
  // GetLeadingLines()
  //
  // Gets the leading lines of the TIFF image.
  //
  // This method succeeds if all of the following are true:
  // - the pLeadingLines pointer is valid.
  // 
  // If this method fails nothing will be written to *pLeadingLines.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pLeadingLines arg is NULL.
  //
  STDMETHOD(GetLeadingLines) (THIS_
    // Address to store the number of leading lines
    /*[out]*/ aafInt32 *  pLeadingLines) PURE;


  //***********************************************************
  //
  // SetTrailingLines()
  //
  // Sets the number of trailing lines in the TIFF image file
  // 
  // This method succeeds if all of the following are true:
  // - TrailingLines is  equal or greater than 0(zero).
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  STDMETHOD(SetTrailingLines) (THIS_
    // Number of trailing lines to be thrown away Optional.
    /*[in]*/ aafInt32  TrailingLines) PURE;


  //***********************************************************
  //
  // GetTrailingLines()
  //
  // Gets the trailing lines of the TIFF image.
  //
  // This method succeeds if all of the following are true:
  // - the pTrailingLines pointer is valid.
  // 
  // If this method fails nothing will be written to *pTrailingLines.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pTrailingLines arg is NULL.
  //
  STDMETHOD(GetTrailingLines) (THIS_
    // Address to store the number of trailing lines.
    /*[out]*/ aafInt32 *  pTrailingLines) PURE;


  //***********************************************************
  //
  // SetJPEGTableID()
  //
  // Sets the JPEG table code for  the TIFF image file
  // 
  // This method always succeeds .
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  STDMETHOD(SetJPEGTableID) (THIS_
    // Registered JPEG table code or JT_NULL.
    /*[in]*/ aafJPEGTableID_t  JPEGTableID) PURE;


  //***********************************************************
  //
  // GetJPEGTableID()
  //
  // Gets the JPEG table code of the TIFF image.
  //
  // This method succeeds if all of the following are true:
  // - the pJPEGTableID pointer is valid.
  // 
  // If this method fails nothing will be written to *pJPEGTableID.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pJPEGTableID arg is NULL.
  //
  STDMETHOD(GetJPEGTableID) (THIS_
    // Address to store the nJPEG table code
    /*[out]*/ aafJPEGTableID_t *  pJPEGTableID) PURE;


  //***********************************************************
  //
  // GetSummary()
  //
  // Gets a copy of the TIFF IFD file information without the media.
  // 
  // Succeeds if all of the following are true:
  // - pSummary is a valid pointer.
  // - The size of the buffer is large enough to hold the TIFF IFD
  //   file information. 
  // 
  // If this method fails pSummary will not be changed.
  // 
  // This method will return the following codes:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.
  //
  // AAFRESULT_NULL_PARAM
  //   - pSummary arg is NULL.
  //
  // AAFRESULT_SMALLBUF
  //   - The buffer is too small to hold the WAVE file information.
  //
  STDMETHOD(GetSummary) (THIS_
    // Size of preallocated buffer
    /*[in]*/ aafUInt32  size,

    // Preallocated buffer to hold the TIFF IFD file information
    /*[out, size_is(size)]*/ aafDataValue_t  pSummary) PURE;


  //***********************************************************
  //
  // GetSummaryBufferSize()
  //
  // Returns the size of the buffer required for the GetSummary()
  // method.  The value is placed into the location specified by pSize.
  //
  // Succeeds if all of the following are true:
  // - the pSize pointer is valid.
  //
  // If this method fails nothing will be written to *pSize.
  //
  // This method will return the following codes:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.
  //
  // AAFRESULT_NULL_PARAM
  //   - pSize arg is NULL.
  //
  STDMETHOD(GetSummaryBufferSize) (THIS_
    // required buffer size
    /*[out]*/ aafUInt32 *  pSize) PURE;


  //***********************************************************
  //
  // SetSummary()
  //
  // Sets the TIFF IFD file information.
  // 
  // Succeeds if all of the following are true:
  // - pSummary is a valid pointer
  // 
  // If this method fails the summary property will not be
  // changed.
  // 
  // This method will return the following codes:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.
  //
  // AAFRESULT_NULL_PARAM
  //   - pSummary arg is NULL.
  //
  STDMETHOD(SetSummary) (THIS_
    // Size of preallocated buffer
    /*[in]*/ aafUInt32  size,

    // buffer containing value
    /*[in, size_is(size)]*/ aafDataValue_t  pSummary) PURE;

  END_INTERFACE
};
#endif // __IAAFTIFFDescriptor_INTERFACE_DEFINED__



// IAAFTimecodeStream

// ************************
//
// Interface IAAFTimecodeStream
//
// ************************




#ifndef __IAAFTimecodeStream_INTERFACE_DEFINED__
#define __IAAFTimecodeStream_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFTimecodeStream;

#undef  INTERFACE
#define INTERFACE   IAAFTimecodeStream

DECLARE_INTERFACE_(IAAFTimecodeStream, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFTimecodeStream methods *** */

  //***********************************************************
  //
  // GetPositionTimecode()
  //
  // Get the timecode fields at the given position.
  //
  STDMETHOD(GetPositionTimecode) (THIS_
    // Zero based offset to set the timecode at
    /*[in]*/ aafPosition_t  position,

    // Timecode [startFrame drop fps]
    /*[out]*/ aafTimecode_t *  timecode) PURE;


  //***********************************************************
  //
  // SetPositionTimecode()
  //
  // Set the timecode fields for a given frame.  The frame index must
  // be within the length of the object.
  //
  STDMETHOD(SetPositionTimecode) (THIS_
    // Zero-based offset to set the timecode at
    /*[in]*/ aafPosition_t  position,

    // Timecode [startFrame  drop  fps]
    /*[in]*/ aafTimecode_t  timecode) PURE;


  //***********************************************************
  //
  // GetUserDataLength()
  //
  // Gets the length of the user data for one frame.
  //
  STDMETHOD(GetUserDataLength) (THIS_
    // Fixed length of the user data [userbits] in bytes
    /*[out]*/ aafInt32 *  length) PURE;


  //***********************************************************
  //
  // GetUserDataAtPosition()
  //
  // Gets the user data [userbits] for a particular frame.
  //
  STDMETHOD(GetUserDataAtPosition) (THIS_
    // Zero-based offset
    /*[in]*/ aafPosition_t  position,

    // Length of the buffer
    /*[in]*/ aafInt32  buflen,

    // Passed in and filled with user data
    /*[out]*/ aafDataBuffer_t  buffer) PURE;


  //***********************************************************
  //
  // SetUserDataAtPosition()
  //
  // Gets the user data [userbits] for a particular frame.
  //
  STDMETHOD(SetUserDataAtPosition) (THIS_
    // Zero-based offset to set the userbits at
    /*[in]*/ aafPosition_t  position,

    // Length of the buffer
    /*[in]*/ aafInt32  buflen,

    // user data for the given frame
    /*[in]*/ aafDataBuffer_t  buffer) PURE;
							 

  //***********************************************************
  //
  // SetSampleRate()
  //
  // Sets the sample rate of the timecode data.
  //
  STDMETHOD(SetSampleRate) (THIS_
    // The sample rate of the timecode data
    /*[in]*/ aafRational_t  sampleRate) PURE;


  //***********************************************************
  //
  // GetSampleRate()
  //
  // Gets the sample rate of the timecode data.
  //
  STDMETHOD(GetSampleRate) (THIS_
    // The sample rate of the timecode data
    /*[out]*/ aafRational_t *  pSampleRate) PURE;


  //***********************************************************
  //
  // SetSourceType()
  //
  // Sets the type (LTC or VITC) of the timecode data.
  //
  STDMETHOD(SetSourceType) (THIS_
    // The type (LTC or VITC) of the timecode data
    /*[in]*/ aafTimecodeSourceType_t  sourceType) PURE;


  //***********************************************************
  //
  // GetSourceType()
  //
  // Gets the type (LTC or VITC) of the timecode data.
  //
  STDMETHOD(GetSourceType) (THIS_
    // The type (LTC or VITC) of the timecode data
    /*[out]*/ aafTimecodeSourceType_t *  pSourceType) PURE;


  //***********************************************************
  //
  // GetSampleSize()
  //
  // Gets the size (in samples) of one sample of the timecode data.
  //
  STDMETHOD(GetSampleSize) (THIS_
    // The size (in bytes) of one sample of the timecode data
    /*[out]*/ aafUInt32 *  pSampleSize) PURE;


  //***********************************************************
  //
  // GetSource()
  //
  // Writes the entire timecode data value into the pValue buffer.
  // The buffer is allocated by the caller, and the size of the
  // buffer is given by valueSize.
  // 
  // Caller may call GetValueBufLen() to determine the
  // required buffer size.
  // 
  // Succeeds if all of the following are true:
  // - the pValue pointer is valid.
  // - valueSize indicates the buffer is large enough to hold the name.
  // 
  // If this method fails nothing will be written to *pValue.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pValue arg is NULL.
  //
  // AAFRESULT_SMALLBUF
  //   - valueSize indicates the buffer is too small to hold the value.
  //
  STDMETHOD(GetSource) (THIS_
    // Size of preallocated buffer
    /*[in]*/ aafUInt32  valueSize,

    // Preallocated buffer to hold value
    /*[out, size_is(valueSize),length_is(*bytesRead)]*/ aafDataBuffer_t  pValue,

    // Number of actual bytes read
    /*[out]*/ aafUInt32*  bytesRead) PURE;


  //***********************************************************
  //
  // GetSourceBufLen()
  //
  // Returns the length of buffer required for the GetValue()
  // method.  The value is placed into the location specified by
  // pLen.
  //
  // Succeeds if all of the following are true:
  // - the pLen pointer is valid.
  //
  // If this method fails nothing will be written to *pLen.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pLen arg is NULL.
  //
  STDMETHOD(GetSourceBufLen) (THIS_
    // Pointer to an variable used to return the length
    /*[out]*/ aafUInt32 *  pLen) PURE;


  //***********************************************************
  //
  // SetSource()
  //
  // The data value is set from a buffer of size valueSize.
  //
  // Succeeds if all of the following are true:
  // - the pValue pointer is valid.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pValue is null.
  //
  STDMETHOD(SetSource) (THIS_
    // Size of preallocated buffer
    /*[in]*/ aafUInt32  valueSize,

    // buffer containing value
    /*[in, size_is(valueSize)]*/ aafDataBuffer_t  pValue) PURE;







  END_INTERFACE
};
#endif // __IAAFTimecodeStream_INTERFACE_DEFINED__



// IAAFTimecodeStream12M

// ************************
//
// Interface IAAFTimecodeStream12M
//
// ************************



#ifndef __IAAFTimecodeStream12M_INTERFACE_DEFINED__
#define __IAAFTimecodeStream12M_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFTimecodeStream12M;


#undef  INTERFACE
#define INTERFACE   IAAFTimecodeStream12M

DECLARE_INTERFACE_(IAAFTimecodeStream12M, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFTimecodeStream12M methods *** */





  END_INTERFACE
};
#endif // __IAAFTimecodeStream12M_INTERFACE_DEFINED__



// IAAFTypeDef

// ************************
//
// Interface IAAFTypeDef
//
// ************************



#ifndef __IAAFTypeDef_INTERFACE_DEFINED__
#define __IAAFTypeDef_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFTypeDef;

#undef  INTERFACE
#define INTERFACE   IAAFTypeDef

DECLARE_INTERFACE_(IAAFTypeDef, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFTypeDef methods *** */

  //***********************************************************
  //
  // GetTypeCategory()
  //
  // Returns the type category to which this type definition	belongs.
  // 
  // Succeeds if:
  // - The pTid argument is valid
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pTid arg is NULL.
  //
  STDMETHOD(GetTypeCategory) (THIS_
    // Returned type category
    /*[out]*/ eAAFTypeCategory_t *  pTid) PURE;


  //***********************************************************
  //
  // RawAccessType()
  //
  // This method returns the type def through which values of this
  // type may be accessed if the client wishes to access the value as
  // as raw data.
    // NOTE! Stub only.   Implementation not yet added.
  //

  // 
  // Succeeds if:
  // - The ppRawTYPEDEF argument is valid
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppRawTypeDef arg is NULL.
  //
  STDMETHOD(RawAccessType) (THIS_
    // the raw access type definition
    /*[out]*/ IAAFTypeDef ** ppRawTypeDef) PURE;



  END_INTERFACE
};
#endif // __IAAFTypeDef_INTERFACE_DEFINED__



// IAAFTypeDefCharacter

// ************************
//
// Interface IAAFTypeDefCharacter
//
// ************************





#ifndef __IAAFTypeDefCharacter_INTERFACE_DEFINED__
#define __IAAFTypeDefCharacter_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFTypeDefCharacter;

#undef  INTERFACE
#define INTERFACE   IAAFTypeDefCharacter

DECLARE_INTERFACE_(IAAFTypeDefCharacter, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFTypeDefCharacter methods *** */


  //***********************************************************
  //
  // CreateValueFromCharacter()
  //
  // Gets a property value corresponding to the character data. 
  // 
  // Succeeds if:
  // - Initialize() has already been called on this object.
  // - The pCharacterValue pointer is valid.
  // - The ppActualPropertyValue pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppCharacterValue is not a valid pointer.
  //
  //
  STDMETHOD(CreateValueFromCharacter) (THIS_
    // character data to write the the new value
    /*[in]*/ aafCharacter  character,

    // character property value with the given character
    /*[out]*/ IAAFPropertyValue ** ppCharacterValue) PURE;

  //***********************************************************
  //
  // GetCharacter()
  //
  // Gets a character from the property value. 
  // 
  // Succeeds if:
  // - Initialize() has already been called on this object.
  // - The pCharacterValue pointer is valid.
  // - The ppActualPropertyValue pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_ILLEGAL_VALUE
  //   - pCharacterValue is not a valid character property value.
  //
  //
  STDMETHOD(GetCharacter) (THIS_
    // character property value to read
    /*[in]*/ IAAFPropertyValue * pCharacterValue,

    // character that is read
    /*[out]*/ aafCharacter *  pCharacter) PURE;

  //***********************************************************
  //
  // SetCharacter()
  //
  // Sets a character into the given property value. 
  // 
  // Succeeds if:
  // - Initialize() has already been called on this object.
  // - The pCharacterValue pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_ILLEGAL_VALUE
  //   - pCharacterValue is not a valid character property value.
  //
  //
  STDMETHOD(SetCharacter) (THIS_
    // character property value to modify
    /*[in]*/ IAAFPropertyValue * pCharacterValue,

    // character that is written
    /*[in]*/ aafCharacter  character) PURE;




  END_INTERFACE
};
#endif // __IAAFTypeDefCharacter_INTERFACE_DEFINED__



// IAAFTypeDefIndirect

// ************************
//
// Interface IAAFTypeDefIndirect
//
// ************************





#ifndef __IAAFTypeDefIndirect_INTERFACE_DEFINED__
#define __IAAFTypeDefIndirect_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFTypeDefIndirect;

#undef  INTERFACE
#define INTERFACE   IAAFTypeDefIndirect

DECLARE_INTERFACE_(IAAFTypeDefIndirect, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFTypeDefIndirect methods *** */



  //***********************************************************
  //
  // CreateValueFromActualValue()
  //
  // Creates an indirect property value which contains the actual type.  
  // Returns the newly-created property value in ppIndirectPropertyValue.
  //
  // Succeeds if all of the following are true:
  // - the pActualValue pointer is valid.
  // - the ppIndirectPropertyValue pointer is valid.
  //
  // If this method fails nothing will be written to *ppIndirectPropertyValue.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - either pActualValue or ppIndirectPropertyValue arg is NULL.
  //
  // AAFRESULT_ILLEGAL_VALUE
  //   - initDataSize indicates pInitData is of the wrong size.
  //
  // AAFRESULT_NOT_REGISTERED
  //  - struct offsets have not yet been registered for this typedef.
  //
  STDMETHOD(CreateValueFromActualValue) (THIS_
    // pointer to actual value
    /*[in]*/ IAAFPropertyValue * pActualValue,

    // newly created property value
    /*[out]*/ IAAFPropertyValue ** ppIndirectPropertyValue) PURE;

  //***********************************************************
  //
  // CreateValueFromActualData()
  //
  // Creates an indirect property value which contains data of the 
  // actual type.  Returns the newly-created property value in
  // ppIndirectPropertyValue.
  //
  // Succeeds if all of the following are true:
  // - the pActualType pointer is valid and registered
  // - the pInitData pointer is valid.
  // - the ppIndirectPropertyValue pointer is valid.
  // - initDataSize indicates pInitData is the correct size for 
  //   the actual type.
  // - compile-time struct has had its member offests registered.
  //
  // If this method fails nothing will be written to *ppIndirectPropertyValue.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - either pActualType or InitData or ppIndirectPropertyValue arg is NULL.
  //
  // AAFRESULT_ILLEGAL_VALUE
  //   - initDataSize indicates pInitData is of the wrong size.
  //
  // AAFRESULT_NOT_REGISTERED
  //  - struct offsets have not yet been registered for this typedef.
  //
  STDMETHOD(CreateValueFromActualData) (THIS_
    // the actual type of the data
    /*[in]*/ IAAFTypeDef * pActualType,

    // pointer to buffer containing data to use
    /*[in, size_is(initDataSize)]*/ aafMemPtr_t  pInitData,

    // size of data in pInitData
    /*[in]*/ aafUInt32  initDataSize,

    // newly created property value
    /*[out]*/ IAAFPropertyValue ** ppIndirectPropertyValue) PURE;


  //***********************************************************
  //
  // GetActualValue()
  //
  // Gets a property value corresponding to the actual data. 
  // 
  // Succeeds if:
  // - Initialize() has already been called on this object.
  // - The pIndirectPropertyValue pointer is valid.
  // - The ppActualPropertyValue pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - either pIndirectPropertyValue or ppActualPropertyValue arg is NULL.
  //
  // AAFRESULT_ILLEGAL_VALUE
  //   - initDataSize indicates pInitData is of the wrong size.
  //
  // AAFRESULT_NOT_REGISTERED
  //  - struct offsets have not yet been registered for this typedef.
  //
  STDMETHOD(GetActualValue) (THIS_
    // indirect property value to read
    /*[in]*/ IAAFPropertyValue * pIndirectPropertyValue,

    // value that is read
    /*[out]*/ IAAFPropertyValue ** ppActualPropertyValue) PURE;
  //)

  //***********************************************************
  //
  // GetActualSize()
  //
  // Return the size of the actual data withing the indirect property value.
  //
  //
  // Succeeds if all of the following are true:
  // - the pIndirectPropertyValue pointer is valid.
  // - the pActualSize pointer is valid.
  //
  // If this method fails nothing will be written to *pActualSize.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - either pIndirectPropertyValue or pActualSize arg is NULL.
  //
  // AAFRESULT_ILLEGAL_VALUE
  //   - the type of pIndirectPropertyValue was not indirect. 
  //
  // AAFRESULT_TYPE_NOT_FOUND
  //   - the actual type cannot be found in the dictionary.
  //
  // AAFRESULT_NOT_REGISTERED
  //  - struct offsets have not yet been registered for 
  //    the actual typedef.
  //
  STDMETHOD(GetActualSize) (THIS_
    // indirect property value to read
    /*[in]*/ IAAFPropertyValue * pIndirectPropertyValue,

    // actual data size
    /*[out]*/ aafUInt32 *  pActualSize) PURE;
  //***********************************************************
  //
  // GetActualType()
  //
  // Return the type definition of the  actual data within the indirect property value.
  //
  //
  // Succeeds if all of the following are true:
  // - the pIndirectPropertyValue pointer is valid.
  // - the pActualType pointer is valid.
  //
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - either pIndirectPropertyValue or pActualType arg is NULL.
  //
  // AAFRESULT_ILLEGAL_VALUE
  //   - the type of pIndirectPropertyValue was not indirect. 
  //
  // AAFRESULT_TYPE_NOT_FOUND
  //   - the actual type cannot be found in the dictionary.
  //
  // AAFRESULT_NOT_REGISTERED
  //  - struct offsets have not yet been registered for 
  //    the actual typedef.
  //
  STDMETHOD(GetActualType) (THIS_
    // indirect property value to read
    /*[in]*/ IAAFPropertyValue * pIndirectPropertyValue,

    // the type definition of the actual data
    /*[out]*/ IAAFTypeDef ** pActualType) PURE;

  //***********************************************************
  //
  // GetActualData()
  //
  // Copies all the actual data contained in the given indirect property value,
  // interpreted as the actual type for this indirect property value, into the 
  // buffer pointed to by pData.
  //
  // Succeeds if all of the following are true:
  // - the pPropVal pointer is valid.
  // - the pData pointer is valid.
  // - dataSize indicates pData is large enough to hold the data.
  //
  // If this method fails nothing will be written to *ppPropVal.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - either pPropVal or pData arg is NULL.
  //
  // AAFRESULT_ILLEGAL_VALUE
  //   - dataSize indicates pData is too small.
  //
  // AAFRESULT_TYPE_NOT_FOUND
  //   - the actual type cannot be found in the dictionary.
  //
  // AAFRESULT_NOT_REGISTERED
  //  - struct offsets have not yet been registered for 
  //    the actual typedef.
  //
  STDMETHOD(GetActualData) (THIS_
    // indirect property value to read
    /*[in]*/ IAAFPropertyValue * pPropVal,

    // buffer into which actual data should be written
    /*[out, size_is(dataSize)]*/ aafMemPtr_t  pData,

    // size of pData buffer in bytes
    /*[in]*/ aafUInt32  dataSize) PURE;




  END_INTERFACE
};
#endif // __IAAFTypeDefIndirect_INTERFACE_DEFINED__



// IAAFTypeDefInt

// ************************
//
// Interface IAAFTypeDefInt
//
// ************************




#ifndef __IAAFTypeDefInt_INTERFACE_DEFINED__
#define __IAAFTypeDefInt_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFTypeDefInt;

#undef  INTERFACE
#define INTERFACE   IAAFTypeDefInt

DECLARE_INTERFACE_(IAAFTypeDefInt, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFTypeDefInt methods *** */

  //***********************************************************
  //
  // Initialize()
  //
  // Initializes this type def to be identified by the given guid, to
  // have the given size in bytes, and to be signed or unsigned.
  //
  // The implementation of this method may only allow certain values
  // for intSize.  It *will* allow at least 1, 2, 4, and 8-byte
  // integers; some implementations may allow more than that.
  //
  // This method must be called after allocation, and before
  // any other method can be called.
  //
  // Succeeds if:
  // - Initialize() has not yet been called on this object.
  // - intSize is a valid value.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_ALREADY_INITIALIZED
  //   - This object has already had Initialize() called on it.
  //
  // AAFRESULT_BAD_SIZE
  //  - intSize is not a valid value.
  //
  STDMETHOD(Initialize) (THIS_
    // auid to be used to identify this type
    /*[in, ref]*/ aafUID_constref  id,

    // the size of this integer type in bytes
    /*[in]*/ aafUInt8  intSize,

    // true if this integer type is signed; false for unsigned
    /*[in]*/ aafBoolean_t  isSigned,

    // friendly name of this type definition
    /*[in, string]*/ aafCharacter_constptr  pTypeName) PURE;


  //***********************************************************
  //
  // CreateValue()
  //
  // Creates a property value which contains an integer.  Initializes
  // it to contain the given integer value.  The initialization value
  // is passed through pVal; the size of the initialzation value is
  // given in valSize.
  //
  // valSize may be smaller than GetSize() for this typedef; if so,
  // the value is lsb-justified and sign-extended (for signed) or
  // zero-filled (for unsigned).
  //
  // The implementation of this method may only allow certain values
  // for valSize.  It *will* allow at least 1, 2, 4, and 8-byte
  // integers; some implementations may allow more than that.
  //
  // Succeeds if:
  // - The pVal pointer is valid.
  // - The ppPropVal pointer is valid.
  // - valSize is no larger than GetSize() for this typedef.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - either pVal or ppPropVal arg is NULL.
  //
  // AAFRESULT_BAD_SIZE
  //   - valSize is larger than GetSize() for this typedef, or
  //     valSize is not a supported value.
  //
  STDMETHOD(CreateValue) (THIS_
    // pointer to integer initialization value
    /*[in, size_is(valSize)]*/ aafMemPtr_t  pVal,

    // size of integer, in bytes, in pVal
    /*[in]*/ aafUInt32  valSize,

    // newly created property value
    /*[out]*/ IAAFPropertyValue ** ppPropVal) PURE;


  //***********************************************************
  //
  // GetInteger()
  //
  // Returns the integer value of this property.  The value
  // to set is passed through pVal.  The size of the pVal buffer is
  // given in valSize.  valSize may be larger than GetSize(); if so,
  // the value is lsb-justified and sign-extended (for signed) or
  // zero-filled (for unsigned).
  //
  // valSize may be smaller than GetSize() for this typedef; if so,
  // the value is lsb-justified and sign-extended (for signed) or
  // zero-filled (for unsigned).
  //
  // The implementation of this method may only allow certain values
  // for valSize.  It *will* allow at least 1, 2, 4, and 8-byte
  // integers; some implementations may allow more than that.
  //
  // Succeeds if:
  // - The pPropVal pointer is valid.
  // - The pVal pointer is valid.
  // - valSize indicates that pVal is large enough to hold the value.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - either pPropVal or pVal arg is NULL.
  //
  // AAFRESULT_BAD_SIZE
  //   - valSize is smaller than GetSize() for this typedef, or
  //     valSize is not a supported value.
  //
  // AAFRESULT_BAD_TYPE
  //   - The type associated with pPropVal cannot be read as an
  //     integral type, or the int size of pPropVal is larger than the
  //     int size of this type.
  //
  STDMETHOD(GetInteger) (THIS_
    // property value from which value is to be read
    /*[in]*/ IAAFPropertyValue * pPropVal,

    // buffer into which value is written
    /*[out, size_is(valSize)]*/ aafMemPtr_t  pVal,

    // size of pVal buffer in bytes
    /*[in]*/ aafUInt32  valSize) PURE;


  //***********************************************************
  //
  // SetInteger()
  //
  // Sets this property value to the given integer value.  The value
  // to set is passed in pVal, and the size of the value in pVal is
  // given in valSize.  valSize may be smaller than GetSize(); if so,
  // the value is lsb-justified and sign-extended (for signed) or
  // zero-filled (for unsigned).
  //
  // Succeeds if:
  // - The pPropVal pointer is valid.
  // - The pVal pointer is valid.
  // - valSize indicates that pVal is large enough to hold the value.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - either pPropVal or pVal arg is NULL.
  //
  // AAFRESULT_BAD_SIZE
  //   - valSize is larger than GetSize() for this typedef.
  //
  STDMETHOD(SetInteger) (THIS_
    // property value from which value is to be read
    /*[in]*/ IAAFPropertyValue * pPropVal,

    // buffer from which value is read
    /*[in, size_is(valSize)]*/ aafMemPtr_t  pVal,

    // size of pVal buffer in bytes
    /*[in]*/ aafUInt32  valSize) PURE;


  //***********************************************************
  //
  // GetSize()
  //
  // Returns the size of the integral value defined by this type
  // definition. 
  //
  // Succeeds if:
  // - The pSize pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pSize arg is NULL.
  //
  STDMETHOD(GetSize) (THIS_
    // the returned size of this integral value, in bytes
    /*[out]*/ aafUInt32 *  pSize) PURE;


  //***********************************************************
  //
  // IsSigned()
  //
  // Puts true in *pSigned if property values defined with this type
  // def are signed; puts false there for unsigned property values.
  //
  // Succeeds if:
  // - The pSigned pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pSigned arg is NULL.
  //
  STDMETHOD(IsSigned) (THIS_
    // set to true if this integer type is signed; set to false for
    // unsigned
    /*[out]*/ aafBoolean_t *  pSigned) PURE;




  END_INTERFACE
};
#endif // __IAAFTypeDefInt_INTERFACE_DEFINED__



// IAAFTypeDefRename

// ************************
//
// Interface IAAFTypeDefRename
//
// ************************




#ifndef __IAAFTypeDefRename_INTERFACE_DEFINED__
#define __IAAFTypeDefRename_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFTypeDefRename;

#undef  INTERFACE
#define INTERFACE   IAAFTypeDefRename

DECLARE_INTERFACE_(IAAFTypeDefRename, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFTypeDefRename methods *** */

  //***********************************************************
  //
  // Initialize()
  //
  // Initializes this type def to be an alias for the given type
  // (similar to a C typedef).
  // 
  // This method must be called after allocation, and before
  // any other method can be called.
  //
  // Succeeds if:
  // - Initialize() has not yet been called on this object.
  // - pBaseType is a valid pointer.
  // - pTypeName is a valid pointer.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  // 
  // AAFRESULT_NULL_PARAM
  //   - pBaseType or pTypeName is null.
  //
  // AAFRESULT_ALREADY_INITIALIZED
  //   - Initialize() has already been called on this object.
  //
  STDMETHOD(Initialize) (THIS_
    // auid to be used to identify this type
    /*[in, ref]*/ aafUID_constref  id,

    // type to which this is an alias
    /*[in]*/ IAAFTypeDef * pBaseType,

    // friendly name of this type definition
    /*[in, string]*/ aafCharacter_constptr  pTypeName) PURE;


  //***********************************************************
  //
  // GetBaseType()
  //
  // Returns the type definition to which this type def is an alias.
  //
  // Succeeds if:
  // - this object has been Initialize()d.
  // - The ppBaseType pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - ppBaseType pointer is NULL.
  //
  STDMETHOD(GetBaseType) (THIS_
    // type definition for which this is an alias
    /*[out]*/ IAAFTypeDef ** ppBaseType) PURE;


  //***********************************************************
  //
  // GetBaseValue()
  //
  // // Gets the property value of the base type from the given property
  // value of the typedef type and places a pointer to the base type's
  // property value into *ppOutPropVal.
  //
  // Succeeds if:
  // - The pInPropVal pointer is valid.
  // - The ppOutPropVal pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pInPropVal or ppOutPropVal is NULL.
  //
  STDMETHOD(GetBaseValue) (THIS_
    // property value from which value is to be read
    /*[in]*/ IAAFPropertyValue * pInPropVal,

    // pointer to property value represented by base type
    /*[out]*/ IAAFPropertyValue ** ppOutPropVal) PURE;

  //***********************************************************
  //
  // CreateValue()
  //
  // // Gets the property value of the typedef type from the given property
  // value of the base type and places a pointer to the base type's
  // property value into *ppOutPropVal.
  //
  // Succeeds if:
  // - The pInPropVal pointer is valid.
  // - The ppOutPropVal pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pInPropVal or ppOutPropVal is NULL.
  //
  STDMETHOD(CreateValue) (THIS_
    // property value from which value is to be read
    /*[in]*/ IAAFPropertyValue * pInPropVal,

    // pointer to property value represented by rename type
    /*[out]*/ IAAFPropertyValue ** ppOutPropVal) PURE;



  END_INTERFACE
};
#endif // __IAAFTypeDefRename_INTERFACE_DEFINED__



// IAAFTypeDefEnum

// ************************
//
// Interface IAAFTypeDefEnum
//
// ************************




#ifndef __IAAFTypeDefEnum_INTERFACE_DEFINED__
#define __IAAFTypeDefEnum_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFTypeDefEnum;

#undef  INTERFACE
#define INTERFACE   IAAFTypeDefEnum

DECLARE_INTERFACE_(IAAFTypeDefEnum, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFTypeDefEnum methods *** */

  //***********************************************************
  //
  // Initialize()
  //
  // Initializes this type def to be identified by the given guid, to
  // be implemented as the given data type, and to contain the given
  // elements (names and values).  The given data type must be an
  // integral type.  It is considered an error if multiple elements
  // have the same name or the same value.  The values and names are
  // given in parallel arrays, each of which has numElements
  // elements.
  //
  // This method must be called after allocation, and before
  // any other method can be called.
  //
  // Succeeds if:
  // - Initialize() has not yet been called on this object.
  // - pID is a valid pointer.
  // - pType is a valid pointer.
  // - pElementValues is a valid pointer.
  // - pElementNames is a valid pointer.
  // - pTypeName is a valid pointer.
  // - base type is integral type.
  // - no duplicate names or values are found.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_ALREADY_INITIALIZED
  //   - This object has already had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - any pointer argument arg is NULL.
  //
  // AAFRESULT_DUPLICATE
  //   - duplicate name or value is found.
  //
  // AAFRESULT_BAD_TYPE
  //   - base type is not integral type.
  //
  STDMETHOD(Initialize) (THIS_
    // auid to be used to identify this type
    /*[in, ref]*/ aafUID_constref  id,

    // Type of values in this enumeration.
			// Has to be of type Int
    /*[in]*/ IAAFTypeDef * pType,

    // array of element values to be represented in this enumerated
    // type
    /*[in, size_is(numElems)]*/ aafInt64 *  pElementValues,

    // array of element names to be represented in this enumerated
    // type
    /*[in, size_is(numElems)]*/ aafString_t *  pElementNames,

    // number of members in pElementValues and pElementNames arrays
    /*[in]*/ aafUInt32  numElems,

    // friendly name of this type definition
    /*[in]*/ aafCharacter_constptr  pTypeName) PURE;


  //***********************************************************
  //
  // CreateValueFromName()
  //
  // Creates a property value which contains an Enum type.  A
  // lookup on the Name is done to find a match in the list of 
  // legal enumerations for this type. If the Name specified is not
  // found to exist then an INVALID_PARAM error code is returned.
  // If it succeeds then a newly-created property value in ppPropVal
  // is returned.
  //
  // Succeeds if all of the following are true:
  // - the Name pointer is valid.
  // - the ppPropVal pointer is valid.
  //
  // If this method fails nothing will be written to *ppPropVal.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - ppPropVal arg is NULL.
  //
  // AAFRESULT_INVALID_PARAM
  //   - the Name specified is not in the list of legal Enumerations.
  //
  STDMETHOD(CreateValueFromName) (THIS_
    // the Name of a valid Enum symbol
    /*[in]*/ aafCharacter_constptr  Name,

    // newly created property value
    /*[out]*/ IAAFPropertyValue ** ppPropVal) PURE;
  
  
  
  //***********************************************************
  //
  // GetElementType()
  //
  // Returns the type definition of the values which are found in this
  // enumeration.
  // 
  // Succeeds if:
  // - Initialize() has already been called on this object.
  // - The ppTypeDef pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - ppTypeDef arg is NULL.
  //
  STDMETHOD(GetElementType) (THIS_
    // type definition of values of this enumeration
    /*[out]*/ IAAFTypeDef ** ppTypeDef) PURE;

  //***********************************************************
  //
  // GetElementValue()
  //
  // Gets the indexed element in this enumerated type.  The
  // value is written into the client-allocated *pOutValue.  Index
  // must be less than the value returned by CountElements().
  //
  // Succeeds if:
  // - pOutValue is a valid pointer.
  // - index is less than CountElements().
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pOutValue arg is NULL.
  //
  // AAFRESULT_BADINDEX
  //   - index is not less than CountElements().
  //
  STDMETHOD(GetElementValue) (THIS_
    // index of element to retrieve
    /*[in]*/ aafUInt32  index,

    // requested value
    /*[out]*/ aafInt64 *  pOutValue) PURE;

  //***********************************************************
  //
  // GetElementName()
  //
  // Gets the indexed element in this enumerated type.  The
  // Name is written into the client-allocated *pOutValue. The
  // bufSize argument should be large enough to hold the pOutValue.
  // Index must be less than the value returned by CountElements().
  //
  // Caller may call GetElementNameBufLen() to determine the
  // required buffer size.
  //  
  // Succeeds if:
  // - pOutValue is a valid pointer.
  // - index is less than CountElements().
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pOutValue arg is NULL.
  //
  // AAFRESULT_BADINDEX
  //   - index is not less than CountElements().
  //
  // AAFRESULT_SMALLBUF
  //   - bufSize indicates the buffer is too small to hold the string.
  //
  //
  STDMETHOD(GetElementName) (THIS_
    // index of element to retrieve
    /*[in]*/ aafUInt32  index,

    // requested value
    /*[out, size_is(bufSize)]*/ aafCharacter *  pOutValue,

    // The size of the pOutValue buffer in bytes
    /*[in]*/ aafUInt32  bufSize) PURE;
  
  

  //***********************************************************
  //
  // GetElementNameBufLen()
  //
  // Returns the length of buffer required for the GetElementName()
  // method, in bytes.  The value is placed into the location
  // specified by pLen. The value will include space required for the
  // trailing null character.
  //
  // Succeeds if the following is true:
  // - the pLen pointer is valid.
  // - index is less than CountElements().
  //
  // If this method fails nothing will be written to *pLen.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pLen arg is NULL.
  //
  // AAFRESULT_BADINDEX
  //   - index is not less than CountElements().
  //
  //
  STDMETHOD(GetElementNameBufLen) (THIS_
    // index of element to retrieve
    /*[in]*/ aafUInt32  index,

    // required buffer length, in bytes
    /*[out]*/ aafUInt32 *  pLen) PURE;



  
  //***********************************************************
  //
  // CountElements()
  //
  // Returns number of enumeration elements contained.
  //
  // Succeeds if:
  // - Initialize() has already been called on this object.
  // - pCount is a valid pointer.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pCount arg is NULL.
  //
  STDMETHOD(CountElements) (THIS_
    // count of elements within this enumeration
    /*[out]*/ aafUInt32 *  pCount) PURE;



  //***********************************************************
  //
  // GetNameFromValue()
  //
  // Writes the human-legible tag associated with the given value in
  // this enumerated type.  The name is written, with a trailing null
  // character, into the pName buffer.  The buffer is allocated by
  // the caller.  The size of the buffer is given by bufSize.
  // 
  // Caller may call GetNameBufLenFromValue() to determine the
  // required buffer size.
  // 
  // Succeeds if all of the following are true:
  // - the pValue pointer is valid.
  // - the pName pointer is valid.
  // - bufSize indicates the buffer is large enough to hold the name.
  // - the integer value is associated with an element of this
  //   enumerated type.
  // 
  // If this method fails nothing will be written to
  // *pName.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - either pValue or pName arg is NULL.
  //
  // AAFRESULT_SMALLBUF
  //   - bufSize indicates the buffer is too small to hold the string.
  //
  // AAFRESULT_BAD_PARAM
  //   - the given value is not associated with an element of
  //     this type.
  //
  STDMETHOD(GetNameFromValue) (THIS_
    // value of element to get
    /*[in]*/ IAAFPropertyValue * pValue,

    // buffer into which the element name is written
    /*[out, size_is(bufSize), string]*/ aafCharacter *  pName,

    // The size of the pName buffer, in bytes
    /*[in]*/ aafUInt32  bufSize) PURE;


  //***********************************************************
  //
  // GetNameBufLenFromValue()
  //
  // Returns the length of buffer required for the GetNameFromValue()
  // method, in bytes.  The value is placed into the location
  // specified by pLen. The value will include space required for the
  // trailing null character.
  //
  // Succeeds if all of the following are true:
  // - the pValue pointer is valid.
  // - the pLen pointer is valid.
  // - the value is associated with an element of this enumerated
  //   type.
  //
  // If this method fails nothing will be written to *pLen.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - either pValue or pLen arg is NULL.
  //
  // AAFRESULT_BAD_PARAM
  //   - the given value is not associated with an element of this
  //     type.
  //
  STDMETHOD(GetNameBufLenFromValue) (THIS_
    // value of element to get
    /*[in]*/ IAAFPropertyValue * pValue,

    // required buffer length, in bytes
    /*[out]*/ aafUInt32 *  pLen) PURE;


  //***********************************************************
  //
  // GetNameFromInteger()
  //
  // Writes the human-legible tag associated with the given value in
  // this enumerated type.  The name is written, with a trailing null
  // character, into the pName buffer.  The buffer is allocated by
  // the caller.  The size of the buffer is given by bufSize.
  // 
  // Caller may call GetNameBufLenFromInteger() to determine the
  // required buffer size.
  // 
  // Succeeds if all of the following are true:
  // - the pName pointer is valid.
  // - bufSize indicates the buffer is large enough to hold the name.
  // - the integer value is associated with an element of this
  //   enumerated type.
  // 
  // If this method fails nothing will be written to
  // *pName.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pName arg is NULL.
  //
  // AAFRESULT_SMALLBUF
  //   - bufSize indicates the buffer is too small to hold the string.
  //
  // AAFRESULT_ILLEGAL_VALUE
  //   - the given value is not associated with an element of
  //     this type.
  //
  STDMETHOD(GetNameFromInteger) (THIS_
    // value of element to get
    /*[in]*/ aafInt64  value,

    // buffer into which the element name is written
    /*[out, size_is(bufSize), string]*/ aafCharacter *  pName,

    // The size of the pName buffer, in bytes
    /*[in]*/ aafUInt32  bufSize) PURE;


  //***********************************************************
  //
  // GetNameBufLenFromInteger()
  //
  // Returns the length of buffer required for the GetNameFromInteger()
  // method, in bytes.  The value is placed into the location
  // specified by pLen. The value will include space required for the
  // trailing null character.
  //
  // Succeeds if all of the following are true:
  // - the pLen pointer is valid.
  // - the value is associated with an element of this enumerated
  //   type.
  //
  // If this method fails nothing will be written to *pLen.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pLen arg is NULL.
  //
  // AAFRESULT_ILLEGAL_VALUE
  //   - the given value is not associated with an element of this
  //     type.
  //
  STDMETHOD(GetNameBufLenFromInteger) (THIS_
    // value of element to get
    /*[in]*/ aafInt64  value,

    // required buffer length, in bytes
    /*[out]*/ aafUInt32 *  pLen) PURE;


  //***********************************************************
  //
  // GetIntegerValue()
  //
  // Gets the value from the given property value and writes it as an
  // integer into *pValueOut.
  //
  // Succeeds if:
  // - The pPropValIn pointer is valid.
  // - The pValueOut pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - Either pPropValIn or ppPropValOut arg is NULL.
  //
  STDMETHOD(GetIntegerValue) (THIS_
    // property value to read
    /*[in]*/ IAAFPropertyValue * pPropValIn,

    // value of the enum represented by the given input property value
    /*[out]*/ aafInt64 *  pValueOut) PURE;


  //***********************************************************
  //
  // SetIntegerValue()
  //
  // Sets the given property to the value given in pValueIn.
  //
  // Succeeds if:
  // - The pPropValToSet pointer is valid.
  // - valueIn is a correct value for this enumerated type.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pPropValToSet arg is NULL.
  //
  // AAFRESULT_ILLEGAL_VALUE
  //   - valueIn is not a correct value for this enumerated type.
  //   - pPropValIn's type doesn't match GetElementType()
  //
  STDMETHOD(SetIntegerValue) (THIS_
    // property value to set
    /*[in]*/ IAAFPropertyValue * pPropValToSet,

    // new value of the enum represented by the given property value
    /*[in]*/ aafInt64  valueIn) PURE;


  //***********************************************************
  //
  // RegisterSize()
  //
  // Allows client to register to the reference implementation a
  // runtime C enum to represent objects of this TypeDef.  The size of
  // the enum to be represented should be passed as the enumSize
  // argument.  This allows the reference implementation to write
  // property values into compile-time-defined C enums intelligible
  // by the local machine and compiler.
  //
  // Succeeds if:
  // - Initialize() has already been called on this object.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  STDMETHOD(RegisterSize) (THIS_
    // size of this enum
    /*[in]*/ aafUInt32  enumSize) PURE;


  END_INTERFACE
};
#endif // __IAAFTypeDefEnum_INTERFACE_DEFINED__



// IAAFTypeDefExtEnum

// ************************
//
// Interface IAAFTypeDefExtEnum
//
// ************************




#ifndef __IAAFTypeDefExtEnum_INTERFACE_DEFINED__
#define __IAAFTypeDefExtEnum_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFTypeDefExtEnum;

#undef  INTERFACE
#define INTERFACE   IAAFTypeDefExtEnum

DECLARE_INTERFACE_(IAAFTypeDefExtEnum, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFTypeDefExtEnum methods *** */

  //***********************************************************
  //
  // Initialize()
  //
  // Initializes this type def to be identified by the given guid.  No
  // element values are initially specified; they must be supplied
  // later using the AppendElement method.
  //
  // This method must be called after allocation, and before
  // any other method can be called.
  //
  // Succeeds if:
  // - Initialize() has not yet been called on this object.
  // - pID is a valid pointer.
  // - pTypeName is a valid pointer.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_ALREADY_INITIALIZED
  //   - This object has already had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pTypeName arg is NULL.
  //
  // AAFRESULT_DUPLICATE
  //   - duplicate name or value is found.
  //
  STDMETHOD(Initialize) (THIS_
    // auid to be used to identify this type
    /*[in, ref]*/ aafUID_constref  id,

    // friendly name of this type definition
    /*[in]*/ aafCharacter_constptr  pTypeName) PURE;

  //***********************************************************
  //
  // CreateValueFromName()
  //
  // Creates a property value which contains an Enum type.  A
  // lookup on the Name is done to find a match in the list of 
  // legal enumerations for this type. If the Name specified is not
  // found to exist then an INVALID_PARAM error code is returned.
  // If it succeeds then a newly-created property value in ppPropVal
  // is returned.
  //
  // Succeeds if all of the following are true:
  // - the Name pointer is valid.
  // - the ppPropVal pointer is valid.
  //
  // If this method fails nothing will be written to *ppPropVal.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - ppPropVal arg is NULL.
  //
  // AAFRESULT_INVALID_PARAM
  //   - the Name specified is not in the list of legal Enumerations.
  //
  STDMETHOD(CreateValueFromName) (THIS_
    // the Name of a valid Enum symbol
    /*[in]*/ aafCharacter_constptr  Name,

    // newly created property value
    /*[out]*/ IAAFPropertyValue ** ppPropVal) PURE;
  

  //***********************************************************
  //
  // CountElements()
  //
  // Returns number of enumeration elements contained.
  //
  // Succeeds if:
  // - Initialize() has already been called on this object.
  // - pCount is a valid pointer.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pCount arg is NULL.
  //
  STDMETHOD(CountElements) (THIS_
    // count of elements within this enumeration
    /*[out]*/ aafUInt32 *  pCount) PURE;


  //***********************************************************
  //
  // GetElementValue()
  //
  // Gets the indexed element in this enumerated type.  The
  // value is written into the client-allocated *pOutValue.  Index
  // must be less than the value returned by CountElements().
  //
  // Succeeds if:
  // - pOutValue is a valid pointer.
  // - index is less than CountElements().
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pOutValue arg is NULL.
  //
  // AAFRESULT_BADINDEX
  //   - index is not less than CountElements().
  //
  STDMETHOD(GetElementValue) (THIS_
    // index of element to retrieve
    /*[in]*/ aafUInt32  index,

    // requested value
    /*[out]*/ aafUID_t *  pOutValue) PURE;


  //***********************************************************
  //
  // GetElementName()
  //
  // Gets the indexed element in this enumerated type.  The
  // Name is written into the client-allocated *pOutValue. The
  // bufSize argument should be large enough to hold the pOutValue.
  // Index must be less than the value returned by CountElements().
  //
  // Caller may call GetElementNameBufLen() to determine the
  // required buffer size.
  //  
  // Succeeds if:
  // - pOutValue is a valid pointer.
  // - index is less than CountElements().
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pOutValue arg is NULL.
  //
  // AAFRESULT_BADINDEX
  //   - index is not less than CountElements().
  //
  // AAFRESULT_SMALLBUF
  //   - bufSize indicates the buffer is too small to hold the string.
  //
  //
  STDMETHOD(GetElementName) (THIS_
    // index of element to retrieve
    /*[in]*/ aafUInt32  index,

    // requested value
    /*[out, size_is(bufSize)]*/ aafCharacter *  pOutValue,

    // The size of the pOutValue buffer in bytes
    /*[in]*/ aafUInt32  bufSize) PURE;
  
  //***********************************************************
  //
  // GetElementNameBufLen()
  //
  // Returns the length of buffer required for the GetElementName()
  // method, in bytes.  The value is placed into the location
  // specified by pLen. The value will include space required for the
  // trailing null character.
  //
  // Succeeds if the following is true:
  // - the pLen pointer is valid.
  // - index is less than CountElements().
  //
  // If this method fails nothing will be written to *pLen.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pLen arg is NULL.
  //
  // AAFRESULT_BADINDEX
  //   - index is not less than CountElements().
  //
  //
  STDMETHOD(GetElementNameBufLen) (THIS_
    // index of element to retrieve
    /*[in]*/ aafUInt32  index,

    // required buffer length, in bytes
    /*[out]*/ aafUInt32 *  pLen) PURE;


  //***********************************************************
  //
  // GetNameFromValue()
  //
  // Writes the human-legible tag associated with the given value in
  // this enumerated type.  The name is written, with a trailing null
  // character, into the pName buffer.  The buffer is allocated by
  // the caller.  The size of the buffer is given by bufSize.
  // 
  // Caller may call GetNameBufLenFromValue() to determine the
  // required buffer size.
  // 
  // Succeeds if all of the following are true:
  // - the pValue pointer is valid.
  // - the pName pointer is valid.
  // - bufSize indicates the buffer is large enough to hold the name.
  // - the integer value is associated with an element of this
  //   enumerated type.
  // 
  // If this method fails nothing will be written to
  // *pName.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - either pValue or pName arg is NULL.
  //
  // AAFRESULT_SMALLBUF
  //   - bufSize indicates the buffer is too small to hold the string.
  //
  // AAFRESULT_BAD_PARAM
  //   - the given value is not associated with an element of
  //     this type.
  //
  STDMETHOD(GetNameFromValue) (THIS_
    // value of element to get
    /*[in]*/ IAAFPropertyValue * pValue,

    // buffer into which the element name is written
    /*[out, size_is(bufSize), string]*/ aafCharacter *  pName,

    // The size of the pName buffer, in bytes
    /*[in]*/ aafUInt32  bufSize) PURE;


  //***********************************************************
  //
  // GetNameBufLenFromValue()
  //
  // Returns the length of buffer required for the GetNameFromValue()
  // method, in bytes.  The value is placed into the location
  // specified by pLen. The value will include space required for the
  // trailing null character.
  //
  // Succeeds if all of the following are true:
  // - the pValue pointer is valid.
  // - the pLen pointer is valid.
  // - the value is associated with an element of this enumerated
  //   type.
  //
  // If this method fails nothing will be written to *pLen.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - either pValue or pLen arg is NULL.
  //
  // AAFRESULT_BAD_PARAM
  //   - the given value is not associated with an element of this
  //     type.
  //
  STDMETHOD(GetNameBufLenFromValue) (THIS_
    // value of element to get
    /*[in]*/ IAAFPropertyValue * pValue,

    // required buffer length, in bytes
    /*[out]*/ aafUInt32 *  pLen) PURE;


  //***********************************************************
  //
  // GetNameFromAUID()
  //
  // Writes the human-legible tag associated with the given value in
  // this enumerated type.  The name is written, with a trailing null
  // character, into the pName buffer.  The buffer is allocated by
  // the caller.  The size of the buffer is given by bufSize.
  // 
  // Caller may call GetNameBufLenFromAUID() to determine the
  // required buffer size.
  // 
  // Succeeds if all of the following are true:
  // - the pName pointer is valid.
  // - bufSize indicates the buffer is large enough to hold the name.
  // - the integer value is associated with an element of this
  //   enumerated type.
  // 
  // If this method fails nothing will be written to
  // *pName.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pName arg is NULL.
  //
  // AAFRESULT_SMALLBUF
  //   - bufSize indicates the buffer is too small to hold the string.
  //
  // AAFRESULT_BAD_PARAM
  //   - the given value is not associated with an element of
  //     this type.
  //
  STDMETHOD(GetNameFromAUID) (THIS_
    // value of element to get
    /*[in, ref]*/ aafUID_constref  value,

    // buffer into which the element name is written
    /*[out, size_is(bufSize), string]*/ aafCharacter *  pName,

    // The size of the pName buffer, in bytes
    /*[in]*/ aafUInt32  bufSize) PURE;


  //***********************************************************
  //
  // GetNameBufLenFromAUID()
  //
  // Returns the length of buffer required for the GetNameFromInteger()
  // method, in bytes.  The value is placed into the location
  // specified by pLen. The value will include space required for the
  // trailing null character.
  //
  // Succeeds if all of the following are true:
  // - the pLen pointer is valid.
  // - the value is associated with an element of this enumerated
  //   type.
  //
  // If this method fails nothing will be written to *pLen.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pLen arg is NULL.
  //
  // AAFRESULT_BAD_PARAM
  //   - the given value is not associated with an element of this
  //     type.
  //
  STDMETHOD(GetNameBufLenFromAUID) (THIS_
    // value of element to get
    /*[in, ref]*/ aafUID_constref  value,

    // required buffer length, in bytes
    /*[out]*/ aafUInt32 *  pLen) PURE;


  //***********************************************************
  //
  // GetAUIDValue()
  //
  // Gets the value from the given property value and writes it as an
  // AUID into *pValueOut.
  //
  // Succeeds if:
  // - The pPropValIn pointer is valid.
  // - The pValueOut pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - Either pPropValIn or ppPropValOut arg is NULL.
  //
  STDMETHOD(GetAUIDValue) (THIS_
    // property value to read
    /*[in]*/ IAAFPropertyValue * pPropValIn,

    // value of the enum represented by the given input property value
    /*[out]*/ aafUID_t *  pValueOut) PURE;


  //***********************************************************
  //
  // SetAUIDValue()
  //
  // Sets the given property to the value given in valueIn.
  //
  // Succeeds if:
  // - The pPropValToSet pointer is valid.
  // - valueIn is a correct value for this enumerated type.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pPropValToSet arg is NULL.
  //
  // AAFRESULT_BAD_PARAM
  //   - valueIn is not a correct value for this enumerated type.
  //   - pPropValIn's type doesn't match GetElementType()
  //
  STDMETHOD(SetAUIDValue) (THIS_
    // property value to set
    /*[in]*/ IAAFPropertyValue * pPropValToSet,

    // new value of the enum represented by the given property value
    /*[in, ref]*/ aafUID_constref  valueIn) PURE;


  //***********************************************************
  //
  // AppendElement()
  //
  // Appends a new element to this extendible enumeration.  The
  // element will have the given name and value.  It is not legal to
  // have elements with duplicate names or values.
  // 
  // Succeeds if:
  // - the pName pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pName arg is NULL.
  //
  // AAFRESULT_DUPLICATE
  //   - duplicate name or value is found.
  //
  STDMETHOD(AppendElement) (THIS_
    // value of appended element
    /*[in, ref]*/ aafUID_constref  value,

    // name of appended element
    /*[in]*/ aafCharacter_constptr  pName) PURE;




  END_INTERFACE
};
#endif // __IAAFTypeDefExtEnum_INTERFACE_DEFINED__



// IAAFTypeDefFixedArray

// ************************
//
// Interface IAAFTypeDefFixedArray
//
// ************************





#ifndef __IAAFTypeDefFixedArray_INTERFACE_DEFINED__
#define __IAAFTypeDefFixedArray_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFTypeDefFixedArray;

#undef  INTERFACE
#define INTERFACE   IAAFTypeDefFixedArray

DECLARE_INTERFACE_(IAAFTypeDefFixedArray, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFTypeDefFixedArray methods *** */

  //***********************************************************
  //
  // Initialize()
  //
  // Initializes this type def to contain elements of the given type,
  // and have the given fixed size.  Note that it is only possible to
  // use certain types as the element type.  Those permissible types
  // include:
  // - AAFTypeDefInt
  // - AAFTypeDefRecord
  // - AAFTypeDefEnum
  // - AAFTypeDefExtEnum
  // - AAFTypeDefFixedArray
  //
  // This method must be called after allocation, and before
  // any other method can be called.
  //
  // Succeeds if:
  // - Initialize() has not yet been called on this object.
  // - pID is a valid pointer.
  // - pTypeDef is a valid pointer.
  // - pTypeName is a valid pointer.
  // - element type is permissible for use in a FixedArray.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_ALREADY_INITIALIZED
  //   - This object has already had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - either pTypeDef or pTypeName arg is NULL.
  //
  // AAFRESULT_BAD_TYPE
  //   - an illegal element type was given.
  //
  STDMETHOD(Initialize) (THIS_
    // auid to be used to identify this type
    /*[in, ref]*/ aafUID_constref  id,

    // type of each element to be contained in this array
    /*[in]*/ IAAFTypeDef * pTypeDef,

    // number of elements to be in this array
    /*[in]*/ aafUInt32  nElements,

    // friendly name of this type definition
    /*[in]*/ aafCharacter_constptr  pTypeName) PURE;


  //***********************************************************
  //
  // GetType()
  //
  // Returns the type of elements in this array.
  //
  // Succeeds if:
  // - Initialize() has already been called on this object.
  // - ppTypeDef is a valid pointer.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - ppTypeDef arg is NULL.
  //
  STDMETHOD(GetType) (THIS_
    // type of elements in this array
    /*[out]*/ IAAFTypeDef ** ppTypeDef) PURE;


  //***********************************************************
  //
  // GetCount()
  //
  // Returns number of elements in this array.
  //
  // Succeeds if:
  // - Initialize() has already been called on this object.
  // - pCount is a valid pointer.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pCount arg is NULL.
  //
  STDMETHOD(GetCount) (THIS_
    // count of elements in this array
    /*[out]*/ aafUInt32 *  pCount) PURE;


  //***********************************************************
  //
  // CreateValueFromValues()
  //
  // Creates a property value which contains a fixed array type.  The
  // array elements in the property value are initialized to contain
  // the given values, passed in the pElementValues array.
  // numElements, which indicates the size of the pElementValues
  // array, must match the value returned by GetCount().  Returns
  // the newly-created property value in ppPropVal.
  //
  // Succeeds if all of the following are true:
  // - the pElementValues pointer is valid.
  // - the ppPropVal pointer is valid.
  // - numElements matches the number of elements in this array
  //
  // If this method fails nothing will be written to *ppPropVal.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - either pElementValues or ppPropVal arg is NULL.
  //
  // AAFRESULT_BAD_PARAM
  //   - numElements does not match GetCount().
  //
  STDMETHOD(CreateValueFromValues) (THIS_
    // array of property values for elements of array value which
    // is to be created.
    /*[in, size_is(numElements)]*/ IAAFPropertyValue ** ppElementValues,

    // size of pElementValues array.
    /*[in]*/ aafUInt32  numElements,

    // newly-created property value
    /*[out]*/ IAAFPropertyValue ** ppPropVal) PURE;


  //***********************************************************
  //
  // CreateValueFromCArray()
  //
  // Creates a property value which contains a fixed array type.  The
  // array elements in the property value are initialized from data in
  // a C array which is pointed to by pInitData.  Requires that any
  // structures declared within this array typedef have had their
  // offsets registered with that type.  Returns the newly-created
  // property value in ppPropVal.
  //
  // Succeeds if all of the following are true:
  // - the pInitData pointer is valid.
  // - the ppPropVal pointer is valid.
  // - initDataSize indicates pInitData is the correct size.
  // - compile-time struct has had its member offests registered.
  //
  // If this method fails nothing will be written to *ppPropVal.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - either pInitData or ppPropVal arg is NULL.
  //
  // AAFRESULT_BAD_PARAM
  //   - initDataSize indicates pInitData is of the wrong size.
  //
  // AAFRESULT_NOT_REGISTERED
  //  - any contained struct offsets have not yet been registered for
  //    that typedef.
  //
  STDMETHOD(CreateValueFromCArray) (THIS_
    // pointer to compile-time C array containing data to use
    /*[in, size_is(initDataSize)]*/ aafMemPtr_t  pInitData,

    // size of data in pInitData, in bytes
    /*[in]*/ aafUInt32  initDataSize,

    // newly created property value
    /*[out]*/ IAAFPropertyValue ** ppPropVal) PURE;


  //***********************************************************
  //
  // GetElementValue()
  //
  // Gets a single property value corresponding to the indexed array
  // element.  Places a property value representing the array element
  // identified by the index into ppOutPropval.  Index is zero-based,
  // and must be less than the value returned by GetCount().
  // 
  // Succeeds if:
  // - Initialize() has already been called on this object.
  // - the index exists in this array type def.
  // - The pInPropVal pointer is valid.
  // - The ppOutPropVal pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - Either pInPropVal or ppOutPropVal arg is NULL.
  //
  // AAFRESULT_BAD_PARAM
  //   - The given index is out of range for this array type def.
  //
  STDMETHOD(GetElementValue) (THIS_
    // property value to read
    /*[in]*/ IAAFPropertyValue * pInPropVal,

    // zero-based index into elements in this array type
    /*[in]*/ aafUInt32  index,

    // value that is read
    /*[out]*/ IAAFPropertyValue ** ppOutPropVal) PURE;


  //***********************************************************
  //
  // GetCArray()
  //
  // Copies all the array data contained in the given property value,
  // interpreted as a fixed array of this type, into the C array
  // pointed to by pData.  Requires that any structures declared
  // within this array typedef have had their offsets registered with
  // that type.
  //
  // Succeeds if all of the following are true:
  // - the pPropVal pointer is valid.
  // - the pData pointer is valid.
  // - dataSize indicates pData is large enough to hold the data.
  // - compile-time struct has had its member offests registered.
  //
  // If this method fails nothing will be written to *ppPropVal.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - either pPropVal or pData arg is NULL.
  //
  // AAFRESULT_BAD_PARAM
  //   - dataSize indicates pData is too small.
  //
  // AAFRESULT_NOT_REGISTERED
  //  - struct offsets have not yet been registered for this typedef.
  //
  STDMETHOD(GetCArray) (THIS_
    // property value to read
    /*[in]*/ IAAFPropertyValue * pPropVal,

    // buffer into which C array data should be written
    /*[out, size_is(dataSize)]*/ aafMemPtr_t  pData,

    // size of pData buffer in bytes
    /*[in]*/ aafUInt32  dataSize) PURE;


  //***********************************************************
  //
  // SetElementValue()
  //
  // Sets the value of the single, indicated element of the fixed
  // array contained in pPropVal, to the value contained in
  // pMemberPropVal.  Index is zero-based, and must be less than the
  // value returned by GetCount().  Property value must be of the
  // same type as returned by GetType().
  // 
  // Succeeds if:
  // - Initialize() has already been called on this object.
  // - the index exists in this array type def.
  // - The pInPropVal pointer is valid.
  // - The ppOutPropVal pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - either pInPropVal or ppOutPropVal arg is NULL.
  //
  // AAFRESULT_BAD_PARAM
  //   - The given index is out of range for this array type def.
  //
  STDMETHOD(SetElementValue) (THIS_
    // property value to write
    /*[in]*/ IAAFPropertyValue * pPropVal,

    // zero-based index into members in this array type
    /*[in]*/ aafUInt32  index,

    // value to be placed into this array
    /*[in]*/ IAAFPropertyValue * pMemberPropVal) PURE;


  //***********************************************************
  //
  // SetCArray()
  //
  // Copies all the array data contained in the C array pointed to by
  // pData into the given property value, interpreting the data as a
  // fixed array of this type.  Requires that any structures declared
  // within this typedef have had their offsets registered with that
  // type.
  //
  // Succeeds if all of the following are true:
  // - the pPropVal pointer is valid.
  // - the pData pointer is valid.
  // - dataSize indicates pData contains the correct amount of data.
  // - any contained compile-time struct has had its member offests
  //   registered.
  //
  // If this method fails nothing will be written to *ppPropVal.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - either pPropVal or pData arg is NULL.
  //
  // AAFRESULT_BAD_PARAM
  //  - dataSize indicates pData is not the correct size.
  //
  // AAFRESULT_NOT_REGISTERED
  //  - offsets of any contained struct have not yet been registered.
  //
  STDMETHOD(SetCArray) (THIS_
    // property value to write
    /*[in]*/ IAAFPropertyValue * pPropVal,

    // buffer from which C array data should be read
    /*[in, size_is(dataSize)]*/ aafMemPtr_t  pData,

    // size of pData buffer in bytes
    /*[in]*/ aafUInt32  dataSize) PURE;




  //***********************************************************
  //
  // GetElements()
  //
  // Returns an enumerator across elements in this set.
  // 
  // Succeeds if:
  // - Initialize() has already been called on this object.
  // - The PSetPropVal pointer is valid.
  // - The ppEnum pointer is valid.
  //
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - Either PSetPropVal or ppEnum arg is NULL.
  //
  STDMETHOD(GetElements) (THIS_
    // property value to read
    /*[in]*/ IAAFPropertyValue * PSetPropVal,

    // enumerator across property values
    /*[out]*/ IEnumAAFPropertyValues ** ppEnum) PURE;


  END_INTERFACE
};
#endif // __IAAFTypeDefFixedArray_INTERFACE_DEFINED__



// IAAFTypeDefRecord

// ************************
//
// Interface IAAFTypeDefRecord
//
// ************************





#ifndef __IAAFTypeDefRecord_INTERFACE_DEFINED__
#define __IAAFTypeDefRecord_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFTypeDefRecord;

#undef  INTERFACE
#define INTERFACE   IAAFTypeDefRecord

DECLARE_INTERFACE_(IAAFTypeDefRecord, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFTypeDefRecord methods *** */

  //***********************************************************
  //
  // Initialize()
  //
  // Initializes this type def to be identified by the given guid, and
  // to contain the given members (types and names).  It is considered
  // an error if multiple members have the same name.  Note that it is
  // only possible to use certain types as member types.  Those
  // permissible types include:
  // - AAFTypeDefInt
  // - AAFTypeDefRecord
  // - AAFTypeDefEnum
  // - AAFTypeDefExtEnum
  // - AAFTypeDefFixedArray
  //
  // Succeeds if:
  // - Initialize() has not yet been called on this object.
  // - pID is a valid pointer.
  // - pMemberTypes is a valid pointer.
  // - pMemberNames is a valid pointer.
  // - pTypeName is a valid pointer.
  // - all specified member types are permissible for use in a Record.
  // - all member names are unique.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_ALREADY_INITIALIZED
  //   - This object has already had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pMemberTypes, pMemberNames, or pTypeName arg is NULL.
  //
  // AAFRESULT_BAD_TYPE
  //   - an illegal member type was given.
  //
  // AAFRESULT_DUPLICATE
  //   - a duplicate member name was given.
  //
  STDMETHOD(Initialize) (THIS_
    // auid to be used to identify this type
    /*[in, ref]*/ aafUID_constref  id,

    // array of member types to be represented in this record
    // type
    /*[in, size_is(numMembers)]*/ IAAFTypeDef ** ppMemberTypes,

    // array of member names to be represented in this enumerated
    // type
    /*[in, size_is(numMembers)]*/ aafString_t *  pMemberNames,

    // number of members in pMemberInfo array
    /*[in]*/ aafUInt32  numMembers,

    // friendly name of this type definition
    /*[in]*/ aafCharacter_constptr  pTypeName) PURE;


  //***********************************************************
  //
  // GetMemberType()
  //
  // Returns the type definition of the indexed member in this
  // record type.  Index is zero-based, and must be less than the
  // value returned by GetCount().
  // 
  // Succeeds if:
  // - Initialize() has already been called on this object.
  // - the index exists in this record type def.
  // - The ppTypeDef pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - ppTypeDef arg is NULL.
  //
  // AAFRESULT_ILLEGAL_VALUE
  //   - The given index is out of range for this record type def.
  //
  STDMETHOD(GetMemberType) (THIS_
    // zero-based index into members in this record type
    /*[in]*/ aafUInt32  index,

    // type definition of indexed member
    /*[out]*/ IAAFTypeDef ** ppTypeDef) PURE;


  //***********************************************************
  //
  // GetMemberName()
  //
  // Writes the human-legible tag associated with the indexed member
  // in this record type.  Index is zero-based, and must be less
  // than the value returned by GetCount().  The name is written,
  // with a trailing null character, into the pName buffer.  The
  // buffer is allocated by the caller.  The size of the buffer is
  // given by bufSize.
  // 
  // Caller may call GetMemberNameBufLen() to determine the required
  // buffer size.
  // 
  // Succeeds if all of the following are true:
  // - the pName pointer is valid.
  // - bufSize indicates the buffer is large enough to hold the name.
  // 
  // If this method fails nothing will be written to
  // *pName.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pName arg is NULL.
  // 
  // AAFRESULT_SMALLBUF
  //   - bufSize indicates the buffer is too small to hold the string.
  //
  // AAFRESULT_ILLEGAL_VALUE
  //   - the given integer value is not associated with a member of
  //     this type.
  //
  STDMETHOD(GetMemberName) (THIS_
    // zero-based index into members in this record type
    /*[in]*/ aafUInt32  index,

    // buffer into which the member name is written
    /*[out, size_is(bufSize), string]*/ aafCharacter *  pName,

    // The size of the pName buffer, in bytes
    /*[in]*/ aafUInt32  bufSize) PURE;


  //***********************************************************
  //
  // GetMemberNameBufLen()
  //
  // Returns the length of buffer required for the GetMemberName()
  // method.  Index is zero-based, and must be less than the value
  // returned by GetCount().  The value is placed into the location
  // specified by pLen. The value will include space required for the
  // trailing null character.
  //
  // Succeeds if all of the following are true:
  // - the pLen pointer is valid.
  // - the integer value is associated with a member of this
  //   enumerated type.
  //
  // If this method fails nothing will be written to *pLen.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pLen arg is NULL.
  //
  // AAFRESULT_ILLEGAL_VALUE
  //   - the given integer value is not associated with a member of
  //     this type.
  //
  STDMETHOD(GetMemberNameBufLen) (THIS_
    // zero-based index into members in this record type
    /*[in]*/ aafUInt32  index,

    // required buffer length, in bytes
    /*[out]*/ aafUInt32 *  pLen) PURE;


  //***********************************************************
  //
  // CreateValueFromValues()
  //
  // Creates a property value which contains a record type.  The
  // record members in the property value are initialized to
  // contain the given values, passed in the pMemberValues array.
  // numMembers, which indicates the size of the pMemberValues array,
  // must match the value returned by GetCount().  Returns the
  // newly-created property value in ppPropVal.
  //
  // Succeeds if all of the following are true:
  // - the pMemberValues pointer is valid.
  // - the ppPropVal pointer is valid.
  // - numMembers matches the number of members in this record.
  //
  // If this method fails nothing will be written to *ppPropVal.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - either pMemberValues or ppPropVal arg is NULL.
  //
  // AAFRESULT_ILLEGAL_VALUE
  //   - numMembers does not match GetCount().
  //
  STDMETHOD(CreateValueFromValues) (THIS_
    // array of property values for members of record value which
    // is to be created.
    /*[in, size_is(numMembers)]*/ IAAFPropertyValue ** pMemberValues,

    // size of pMemberValues array.
    /*[in]*/ aafUInt32  numMembers,

    // newly-created property value
    /*[out]*/ IAAFPropertyValue ** ppPropVal) PURE;


  //***********************************************************
  //
  // CreateValueFromStruct()
  //
  // Creates a property value which contains a record type.  The
  // record members in the property value are initialized from data
  // in a struct which is pointed to by pInitData.  Requires that the
  // structure pointed to by pInitData has had its offsets registered
  // with this type.  Returns the newly-created property value in
  // ppPropVal.
  //
  // Succeeds if all of the following are true:
  // - the pInitData pointer is valid.
  // - the ppPropVal pointer is valid.
  // - initDataSize indicates pInitData is the correct size.
  // - compile-time struct has had its member offests registered.
  //
  // If this method fails nothing will be written to *ppPropVal.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - either pInitData or ppPropVal arg is NULL.
  //
  // AAFRESULT_ILLEGAL_VALUE
  //   - initDataSize indicates pInitData is of the wrong size.
  //
  // AAFRESULT_NOT_REGISTERED
  //  - struct offsets have not yet been registered for this typedef.
  //
  STDMETHOD(CreateValueFromStruct) (THIS_
    // pointer to compile-time struct containing data to use
    /*[in, size_is(initDataSize)]*/ aafMemPtr_t  pInitData,

    // size of data in pInitData
    /*[in]*/ aafUInt32  initDataSize,

    // newly created property value
    /*[out]*/ IAAFPropertyValue ** ppPropVal) PURE;


  //***********************************************************
  //
  // GetValue()
  //
  // Gets a single property value corresponding to the indicated
  // record member.  Places a property value representing the
  // record member identified by the index into ppOutPropval.
  // Index is zero-based, and must be less than the value returned by
  // GetCount().
  // 
  // Succeeds if:
  // - Initialize() has already been called on this object.
  // - the index exists in this record type def.
  // - The pInPropVal pointer is valid.
  // - The ppOutPropVal pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - either pInPropVal or ppOutPropVal arg is NULL.
  //
  // AAFRESULT_ILLEGAL_VALUE
  //   - The given index is out of range for this record type def.
  //
  STDMETHOD(GetValue) (THIS_
    // property value to read
    /*[in]*/ IAAFPropertyValue * pInPropVal,

    // zero-based index into members in this record type
    /*[in]*/ aafUInt32  index,

    // value that is read
    /*[out]*/ IAAFPropertyValue ** ppOutPropVal) PURE;


  //***********************************************************
  //
  // GetStruct()
  //
  // Copies all the member data contained in the given property value,
  // interpreted as a record of this type, into the struct pointed
  // to by pData.  Requires that the struct pointed to by pData has
  // had its offsets registered with this type.
  //
  // Succeeds if all of the following are true:
  // - the pPropVal pointer is valid.
  // - the pData pointer is valid.
  // - dataSize indicates pData is large enough to hold the data.
  // - compile-time struct has had its member offests registered.
  //
  // If this method fails nothing will be written to *ppPropVal.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - either pPropVal or pData arg is NULL.
  //
  // AAFRESULT_ILLEGAL_VALUE
  //   - dataSize indicates pData is too small.
  //
  // AAFRESULT_NOT_REGISTERED
  //  - struct offsets have not yet been registered for this typedef.
  //
  STDMETHOD(GetStruct) (THIS_
    // property value to read
    /*[in]*/ IAAFPropertyValue * pPropVal,

    // buffer into which struct data should be written
    /*[out, size_is(dataSize)]*/ aafMemPtr_t  pData,

    // size of pData buffer in bytes
    /*[in]*/ aafUInt32  dataSize) PURE;


  //***********************************************************
  //
  // SetValue()
  //
  // Sets the value of the single, indicated record member of the
  // record contained in pPropVal, to the value contained in
  // pMemberPropVal.  Index is zero-based, and must be less than the
  // value returned by GetCount().
  // 
  // Succeeds if:
  // - Initialize() has already been called on this object.
  // - the index exists in this record type def.
  // - The pInPropVal pointer is valid.
  // - The ppOutPropVal pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - either pInPropVal or ppOutPropVal arg is NULL.
  //
  // AAFRESULT_ILLEGAL_VALUE
  //   - The given index is out of range for this record type def.
  //
  STDMETHOD(SetValue) (THIS_
    // property value to write
    /*[in]*/ IAAFPropertyValue * pPropVal,

    // zero-based index into members in this record type
    /*[in]*/ aafUInt32  index,

    // value to be placed into this record
    /*[in]*/ IAAFPropertyValue * pMemberPropVal) PURE;


  //***********************************************************
  //
  // SetStruct()
  //
  // Copies all the member data contained in the struct pointed to by
  // pData into the given property value, interpreting the data as a record of
  // this type.  Requires that the struct pointed to by pData has had
  // its offsets registered with this type.
  //
  // Succeeds if all of the following are true:
  // - the pPropVal pointer is valid.
  // - the pData pointer is valid.
  // - dataSize indicates pData contains the correct amount of data.
  // - compile-time struct has had its member offests registered.
  //
  // If this method fails nothing will be written to *ppPropVal.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - either pPropVal or pData arg is NULL.
  //
  // AAFRESULT_ILLEGAL_VALUE
  //   - dataSize indicates pData is not the correct size.
  //
  // AAFRESULT_NOT_REGISTERED
  //  - struct offsets have not yet been registered for this typedef.
  //
  STDMETHOD(SetStruct) (THIS_
    // property value to write
    /*[in]*/ IAAFPropertyValue * pPropVal,

    // buffer from which struct data should be read
    /*[in, size_is(dataSize)]*/ aafMemPtr_t  pData,

    // size of pData buffer in bytes
    /*[in]*/ aafUInt32  dataSize) PURE;


  //***********************************************************
  //
  // GetCount()
  //
  // Returns number of members in this record type.
  //
  // Succeeds if:
  // - Initialize() has already been called on this object.
  // - pCount is a valid pointer.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pCount arg is NULL.
  //
  STDMETHOD(GetCount) (THIS_
    // count of members in this record type
    /*[out]*/ aafUInt32 *  pCount) PURE;


  //***********************************************************
  //
  // RegisterMembers()
  //
  // Allows client to register to the reference implementation a
  // runtime C struct to represent objects of this TypeDef.  Offsets
  // for each member in the struct are passed in as an array of
  // integers; size indicates the number of members in the array.
  // The offset is given in bytes from the start address of the
  // struct.  This allows the reference implementation to write
  // property values into compile-time-defined C structs intelligible
  // by the local machine and compiler.
  //
  // Succeeds if:
  // - Initialize() has already been called on this object.
  // - pOffsets is a valid pointer.
  // - numMembers matches the number of members defined for this
  //   record type.
  // - all types of the fields in this record already have their
  //   offsets registered.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pOffsets arg is NULL.
  //
  // AAFRESULT_ILLEGAL_VALUE
  //   - numMembers does not match number of members in this record
  //     type.
  //
  // AAFRESULT_NOT_REGISTERED
  //   - The type of any field in this record has not yet had its
  //     offsets registered.
  //
  // AAFRESULT_DEFAULT_ALREADY_USED
  //   - The default registration for this type has already been used
  //     to persist or unpersist a property containing this type.
  //
  STDMETHOD(RegisterMembers) (THIS_
    // array containing offset for each record member
    /*[in]*/ aafUInt32 *  pOffsets,

    // number of members in pOffsets
    /*[in]*/ aafUInt32  numMembers,

    // size of this struct
    /*[in]*/ aafUInt32  structSize) PURE;

  END_INTERFACE
};
#endif // __IAAFTypeDefRecord_INTERFACE_DEFINED__



// IAAFTypeDefSet

// ************************
//
// Interface IAAFTypeDefSet
//
// ************************





#ifndef __IAAFTypeDefSet_INTERFACE_DEFINED__
#define __IAAFTypeDefSet_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFTypeDefSet;

#undef  INTERFACE
#define INTERFACE   IAAFTypeDefSet

DECLARE_INTERFACE_(IAAFTypeDefSet, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFTypeDefSet methods *** */

  //***********************************************************
  //
  // Initialize()
  //
  // Initializes this type def to contain elements of the given type.
  //
  // This method must be called after allocation, and before
  // any other method can be called.
  //
  // Succeeds if:
  // - Initialize() has not yet been called on this object.
  // - pTypeName is a valid pointer.
  //
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_ALREADY_INITIALIZED
  //   - This object has already had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pTypeName arg is NULL.
  //
  STDMETHOD(Initialize) (THIS_
    // auid to be used to identify this type
    /*[in]*/ aafUID_constref  id,

    // type of each element to be contained in this set
    /*[in]*/ IAAFTypeDef * pTypeDef,

    // friendly name of this type definition
    /*[in,string]*/ aafCharacter_constptr  pTypeName) PURE;

  //***********************************************************
  //
  // GetElementType()
  //
  // Returns the type of elements in this set.
  //
  // Succeeds if:
  // - Initialize() has already been called on this object.
  // - ppTypeDef is a valid pointer.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - ppTypeDef arg is NULL.
  //
  STDMETHOD(GetElementType) (THIS_
    // type of elements in this array
    /*[out]*/ IAAFTypeDef ** ppTypeDef) PURE;

  //***********************************************************
  //
  // AddElement()
  //
  // Adds an element to the set, setting it to the
  // value given in pElementPropertyValue.
  //
  // Succeeds if:
  // - Initialize() has already been called on this object.
  // - pSetPropertyValue pointer is valid.
  // - pElementPropertyValue pointer is valid.
  //
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - either pSetPropertyValue or pElementPropertyValue arg is NULL.
  //
  STDMETHOD(AddElement) (THIS_
    // property value corresponding to set to which element is added
    /*[in]*/ IAAFPropertyValue * pSetPropertyValue,

    // value to be added to this set
    /*[in]*/ IAAFPropertyValue * pElementPropertyValue) PURE;

  //***********************************************************
  //
  // RemoveElement()
  //
  // Removes an element from the set.
  //
  // Succeeds if:
  // - Initialize() has already been called on this object.
  // - pSetPropertyValue pointer is valid.
  // - pElementPropertyValue pointer is valid.
  // - The given element was in the set.
  //
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - either pSetPropertyValue or pElementPropertyValue arg is NULL.
  //
  STDMETHOD(RemoveElement) (THIS_
    // property value corresponding to set from which element is removed
    /*[in]*/ IAAFPropertyValue * pSetPropertyValue,

    // value to be removed from this set
    /*[in]*/ IAAFPropertyValue * pElementPropertyValue) PURE;

  //***********************************************************
  //
  // ContainsElement()
  //
  // Tests if an element is in the set.
  //
  // Succeeds if:
  // - Initialize() has already been called on this object.
  // - pSetPropertyValue pointer is valid.
  // - pElementPropertyValue pointer is valid.
  //
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - either pSetPropertyValue or pElementPropertyValue arg is NULL.
  //
  STDMETHOD(ContainsElement) (THIS_
    // property value corresponding to set to which element is added
    /*[in]*/ IAAFPropertyValue * pSetPropertyValue,

    // value whose presence is being tested in this set
    /*[in]*/ IAAFPropertyValue * pElementPropertyValue,

    // value to be added to this set
    /*[out]*/ aafBoolean_t*  pContainsElement) PURE;



  //***********************************************************
  //
  // GetCount()
  //
  // Returns number of elements in the referenced property value.
  //
  // Succeeds if:
  // - Initialize() has already been called on this object.
  // - pSetPropertyValue is a valid pointer.
  // - pCount is a valid pointer.
  //
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - Either pSetPropertyValue or pCount arg is NULL.
  //
  STDMETHOD(GetCount) (THIS_
    // property value of array
    /*[in]*/ IAAFPropertyValue * pSetPropertyValue,

    // count of elements in the specified set property value
    /*[out]*/ aafUInt32 *  pCount) PURE;


  //***********************************************************
  //
  // CreateKey()
  //
  // Returns number of elements in the referenced property value.
  //
  // Succeeds if:
  // - Initialize() has already been called on this object.
  // - pSetPropertyValue is a valid pointer.
  // - pCount is a valid pointer.
  //
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - Either pSetPropertyValue or pCount arg is NULL.
  //
  STDMETHOD(CreateKey) (THIS_
    // Pointer to the key value bytes
    /*[in,size_is(length)]*/ aafDataBuffer_t  pKeyPtr,

    // The size of the key in bytes
    /*[in]*/ aafUInt32  length,

    // An interface which may be passed to LookupElement() or ContainsKey()
    /*[out]*/ IAAFPropertyValue ** ppKey) PURE;


  //***********************************************************
  //
  // LookupElement()
  //
  // Looks up the given key (created by CreateKey()) and returns the propertyValue
  // of the entry, or an error if the entry is not present.
  //
  // Succeeds if:
  // - Initialize() has already been called on this object.
  // - pSetPropertyValue is a valid pointer.
  // - pCount is a valid pointer.
  // - An entry with the correct key is present in the set.
  //
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - Either pSetPropertyValue or pSetPropertyValue or ppElementPropertyValue arg is NULL.
  //
  STDMETHOD(LookupElement) (THIS_
    // property value of set
    /*[in]*/ IAAFPropertyValue * pSetPropertyValue,

    // A key returned from CreateKey()
    /*[in]*/ IAAFPropertyValue * pKey,

    // The returned property value
    /*[out]*/ IAAFPropertyValue ** ppElementPropertyValue) PURE;

  //***********************************************************
  //
  // ContainsKey()
  //
  // Looks up the given key (created by CreateKey()) and returns AAFTrue if the entry
  // is present, or AAFFalse if the entry is not present.
  //
  // Succeeds if:
  // - Initialize() has already been called on this object.
  // - pSetPropertyValue is a valid pointer.
  // - pCount is a valid pointer.
  //
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - Either pSetPropertyValue or pContainsKey arg is NULL.
  //
  STDMETHOD(ContainsKey) (THIS_
    // property value of set
    /*[in]*/ IAAFPropertyValue * pSetPropertyValue,

    // A key returned from CreateKey()
    /*[in]*/ IAAFPropertyValue * pKey,

    // Value returned is AAFTrue if an entry with the correct key is present
    /*[out]*/ aafBoolean_t*  pContainsKey) PURE;


  //***********************************************************
  //
  // GetElements()
  //
  // Returns an enumerator across elements in this set.
  // 
  // Succeeds if:
  // - Initialize() has already been called on this object.
  // - The pSetPropertyValue pointer is valid.
  // - The ppEnum pointer is valid.
  //
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - Either pSetPropertyValue or ppEnum arg is NULL.
  //
  STDMETHOD(GetElements) (THIS_
    // property value to read
    /*[in]*/ IAAFPropertyValue * pSetPropertyValue,

    // enumerator across property values
    /*[out]*/ IEnumAAFPropertyValues ** ppEnum) PURE;



  END_INTERFACE
};
#endif // __IAAFTypeDefSet_INTERFACE_DEFINED__



// IAAFTypeDefStream

// ************************
//
// Interface IAAFTypeDefStream
//
// ************************




#ifndef __IAAFTypeDefStream_INTERFACE_DEFINED__
#define __IAAFTypeDefStream_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFTypeDefStream;

#undef  INTERFACE
#define INTERFACE   IAAFTypeDefStream

DECLARE_INTERFACE_(IAAFTypeDefStream, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFTypeDefStream methods *** */



  // 
  // All reads/and writes advance the current position
  //


  //
  // Raw byte stream access
  //


  // Stream size and positioning

  //***********************************************************
  //
  // GetSize()
  //
  // Returns number of bytes contained in the referenced property
  // value.
  //
  // Succeeds if:
  // - Initialize() has already been called on this object.
  // - pStreamPropertyValue is a valid pointer.
  // - pSize is a valid pointer.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - Either pStreamPropertyValue or pSize arg is NULL.
  //
  STDMETHOD(GetSize) (THIS_
    // stream property value
    /*[in]*/ IAAFPropertyValue * pStreamPropertyValue,

    // count of bytes in the specified stream property value
    /*[out]*/ aafInt64 *  pSize) PURE;

  //***********************************************************
  //
  // SetSize()
  //
  // Set the number of bytes contained in the give stream property value
  // to newElementCount
  // Succeeds if:
  // - Initialize() has already been called on this object.
  // - pStreamPropertyValue is a valid pointer.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - If pStreamPropertyValue arg is NULL.
  //
  STDMETHOD(SetSize) (THIS_
    // stream property value
    /*[in]*/ IAAFPropertyValue * pStreamPropertyValue,

    // new count of bytes in the specified stream property value
    /*[in]*/ aafInt64  newSize) PURE;

  //***********************************************************
  //
  // GetPosition()
  //
  // Returns the byte position of the current element in the stream. 
  //
  // Succeeds if:
  // - Initialize() has already been called on this object.
  // - pStreamPropertyValue is a valid pointer.
  // - pPosition is a valid pointer.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - Either pStreamPropertyValue or pPosition arg is NULL.
  //
  STDMETHOD(GetPosition) (THIS_
    // stream property value
    /*[in]*/ IAAFPropertyValue * pStreamPropertyValue,

    // current byte position in the specified stream property value
    /*[out]*/ aafInt64 *  pPosition) PURE;

  //***********************************************************
  //
  // SetPosition()
  //
  // Make the current byte position to the one at newPosition in the stream 
  // property value. 
  //
  // Succeeds if:
  // - pStreamPropertyValue is a valid pointer.
  // - the new position is valid
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - If pStreamPropertyValue arg is NULL.
  //
  // AAFRESULT_INVALID_PARAM
  //   - newPosition is outside the bounds of the stream.
  //
  STDMETHOD(SetPosition) (THIS_
    // stream property value
    /*[in]*/ IAAFPropertyValue * pStreamPropertyValue,

    // the new position in the specified stream property value
    /*[in]*/ aafInt64  newPosition) PURE;


  // Sequential access

  //***********************************************************
  //
  // Read()
  //
  // Copies the data at the position of the stream to the given
  // buffer.
  //
  // Succeeds if all of the following are true:
  // - the pStreamPropertyValue pointer is valid.
  // - the pData pointer is valid.
  // - the indicated bytes exist in the stream.
  //
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - either pStreamPropertyValue or pData arg is NULL.
  //
  STDMETHOD(Read) (THIS_
    // stream property value to read
    /*[in]*/ IAAFPropertyValue * pStreamPropertyValue,

    // number of bytes to read
    /*[in]*/ aafUInt32  dataSize,

    // buffer into which one element from the stream should be written
    /*[out, size_is(dataSize), length_is(*bytesRead)]*/ aafMemPtr_t  pData,

    // number of bytes actually read (will be either dataSize or 0 if there 
    // is in error)
    /*[out,ref]*/ aafUInt32 *  bytesRead) PURE;

  //***********************************************************
  //
  // Write()
  //
  // Copies the data in the given buffer into the stream at the 
  // current position of the stream..
  //
  // Succeeds if all of the following are true:
  // - the pStreamPropertyValue pointer is valid.
  // - the pData pointer is valid.
  // - the indicated bytes could be written to the stream.
  //
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - Either pStreamPropertyValue or pData arg is NULL.
  //
  STDMETHOD(Write) (THIS_
    // stream property value to modify
    /*[in]*/ IAAFPropertyValue * pStreamPropertyValue,

    // number of bytes to write
    /*[in]*/ aafUInt32  dataSize,

    // buffer into which should contain one element to be written to the stream
    /*[in, ref, size_is(dataSize)]*/ aafMemPtr_t  pData) PURE;


  // Extending the stream

  //***********************************************************
  //
  // Append()
  //
  // Copies the data in the given buffer into the stream at the 
  // end of the stream.
  //
  // Succeeds if all of the following are true:
  // - the pStreamPropertyValue pointer is valid.
  // - the pData pointer is valid.
  // - the indicated bytes could be appended to the stream.
  //
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - either pStreamPropertyValue or pData arg is NULL.
  //
  STDMETHOD(Append) (THIS_
    // stream property value to modify
    /*[in]*/ IAAFPropertyValue * pStreamPropertyValue,

    // number of bytes to write (must be equal to the element type length)
    /*[in]*/ aafUInt32  dataSize,

    // buffer into which should contain one element to be written to the stream
    /*[in, ref, size_is(dataSize)]*/ aafMemPtr_t  pData) PURE;



  //
  // Access byte order of the stream
  //


  //***********************************************************
  //
  // HasStoredByteOrder()
  //
  // Returns kAAFTrue if the stream has a stored byte order or 
  // kAAFFalse otherwise.
  //
  // Succeeds if:
  // - Initialize() has already been called on this object.
  // - pStreamPropertyValue is a valid pointer.
  // - pHasByteOrder is a valid pointer.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - Either pStreamPropertyValue or pHasByteOrder arg is NULL.
  //
  STDMETHOD(HasStoredByteOrder) (THIS_
    // stream property value
    /*[in]*/ IAAFPropertyValue * pStreamPropertyValue,

    // kAAFTrue if this stream has a stored byte order
    /*[out]*/ aafBoolean_t *  pHasByteOrder) PURE;

  //***********************************************************
  //
  // GetStoredByteOrder()
  //
  // Returns kAAFTrue if the stream has a stored byte order or 
  // kAAFFalse otherwise.
  //
  // Succeeds if:
  // - Initialize() has already been called on this object.
  // - pStreamPropertyValue is a valid pointer.
  // - pHasByteOrder is a valid pointer.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - Either pStreamPropertyValue or pByteOrder arg is NULL.
  //
  STDMETHOD(GetStoredByteOrder) (THIS_
    // stream property value
    /*[in]*/ IAAFPropertyValue * pStreamPropertyValue,

    // Pointer to variable where byte order is to be copied
    /*[out]*/ eAAFByteOrder_t *  pByteOrder) PURE;

  //***********************************************************
  //
  // SetStoredByteOrder()
  //
  // Sets the byte order to be associated with this stream. Note: the stream
  // must be empty.
  //
  // Succeeds if:
  // - Initialize() has already been called on this object.
  // - pStreamPropertyValue is a valid pointer.
  // - stream is empty.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - If pStreamPropertyValue arg is NULL.
  //
  STDMETHOD(SetStoredByteOrder) (THIS_
    // stream property value
    /*[in]*/ IAAFPropertyValue * pStreamPropertyValue,

    // byte order is to be stored with the stream
    /*[in]*/ eAAFByteOrder_t  byteOrder) PURE;

  //***********************************************************
  //
  // ClearStoredByteOrder()
  //
  // Clears the byte order to be associated with this stream. Note: the stream
  // must be empty.
  //
  // Succeeds if:
  // - Initialize() has already been called on this object.
  // - pStreamPropertyValue is a valid pointer.
  // - stream is empty.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - If pStreamPropertyValue arg is NULL.
  //
  STDMETHOD(ClearStoredByteOrder) (THIS_
    // stream property value
    /*[in]*/ IAAFPropertyValue * pStreamPropertyValue) PURE;



  //
  // Access in typed chunks of Elements
  //

  //***********************************************************
  //
  // ReadElements()
  //
  // Copies the data at the current position of the stream to the given
  // buffer. Requires that any structures declared within element 
  // typedef have had their offsets registered with that type.
  //
  // Succeeds if all of the following are true:
  // - the pStreamPropertyValue pointer is valid.
  // - the pElementType pointer is valid.
  // - the pData pointer is valid.
  // - dataSize indicates pData is large enough to hold the data.
  // - compile-time struct has had its member offests registered.
  // - the indicated elements exist in this stream type def.
  //
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - either pStreamPropertyValue or pElementType or pBytesRead or pData arg is NULL.
  //
  // AAFRESULT_INVALID_PARAM
  //   - dataSize indicates pData is too small.
  //
  // AAFRESULT_NOT_REGISTERED
  //  - struct offsets have not yet been registered for element typedef.
  //
  // AAFRESULT_INVALID_PARAM
  //   - there are not dataSize bytes left in the stream.
  //
  STDMETHOD(ReadElements) (THIS_
    // stream property value to read
    /*[in]*/ IAAFPropertyValue * pStreamPropertyValue,

    // the type definition of the elements to read
    /*[in]*/ IAAFTypeDef * pElementType,

    // number of bytes to read (must be evenly divisible by the element 
    // type length)
    /*[in]*/ aafUInt32  dataSize,

    // buffer into which elements from the stream should be written
    /*[out, size_is(dataSize), length_is(*pBytesRead)]*/ aafMemPtr_t  pData,

    // number of bytes actually read (will be either dataSize or 0 if 
    // there is in error)
    /*[out,ref]*/ aafUInt32 *  pBytesRead) PURE;

  //***********************************************************
  //
  // WriteElements()
  //
  // Copies the data in the given buffer into the stream at the  
  // current position of the stream. Requires that any structures 
  // declared within element 
  // typedef have had their offsets registered with that type..
  //
  // Succeeds if all of the following are true:
  // - the pStreamPropertyValue pointer is valid.
  // - the pElementType pointer is valid.
  // - the pData pointer is valid.
  // - dataSize indicates pData is large enough to hold the data.
  // - compile-time struct has had its member offests registered.
  // - the indicated elements exist in this stream type def.
  //
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - either pStreamPropertyValue or pElementType or pData arg is NULL.
  //
  // AAFRESULT_INVALID_PARAM
  //   - dataSize indicates pData is an even multiple of the given 
  //     element type size.
  //
  // AAFRESULT_NOT_REGISTERED
  //  - struct offsets have not yet been registered for the element typedef.
  //
  STDMETHOD(WriteElements) (THIS_
    // stream property value to modify
    /*[in]*/ IAAFPropertyValue * pStreamPropertyValue,

    // the type definition of the elements to read
    /*[in]*/ IAAFTypeDef * pElementType,

    // number of bytes to write (must be evenly divisible by the element type 
    // length)
    /*[in]*/ aafUInt32  dataSize,

    // buffer into which elements from the stream should be written
    /*[in, ref, size_is(dataSize)]*/ aafMemPtr_t  pData) PURE;


  // Extend in chunks of typed Elements

  //***********************************************************
  //
  // AppendElements()
  //
  // Copies the data in the given buffer onto the end of the stream. 
  // Requires that any structures declared within element 
  // typedef have had their offsets registered with that type..
  //
  // Succeeds if all of the following are true:
  // - the pStreamPropertyValue pointer is valid.
  // - the pElementType pointer is valid.
  // - the pData pointer is valid.
  // - dataSize indicates pData is large enough to hold the data.
  // - compile-time struct has had its member offests registered.
  // - the indicated elements exist in this stream type def.
  //
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - either pStreamPropertyValue or pElementType or pData arg is NULL.
  //
  // AAFRESULT_INVALID_PARAM
  //   - dataSize indicates pData is an even multiple of the given 
  //     element type size.
  //
  // AAFRESULT_NOT_REGISTERED
  //  - struct offsets have not yet been registered for the element typedef.
  //
  STDMETHOD(AppendElements) (THIS_
    // stream property value to modify
    /*[in]*/ IAAFPropertyValue * pStreamPropertyValue,

    // the type definition of the elements to read
    /*[in]*/ IAAFTypeDef * pElementType,

    // number of bytes to write (must be evenly divisible by the element type 
    // length)
    /*[in]*/ aafUInt32  dataSize,

    // buffer into which elements from the stream should be written
    /*[in, ref, size_is(dataSize)]*/ aafMemPtr_t  pData) PURE;


  END_INTERFACE
};
#endif // __IAAFTypeDefStream_INTERFACE_DEFINED__



// IAAFTypeDefString

// ************************
//
// Interface IAAFTypeDefString
//
// ************************




#ifndef __IAAFTypeDefString_INTERFACE_DEFINED__
#define __IAAFTypeDefString_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFTypeDefString;

#undef  INTERFACE
#define INTERFACE   IAAFTypeDefString

DECLARE_INTERFACE_(IAAFTypeDefString, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFTypeDefString methods *** */

  //***********************************************************
  //
  // Initialize()
  //
  // Initializes this type def to contain elements of the given type.
  // Note that it is only possible to use certain types as the element
  // type.  Those permissible types include:
  // - AAFTypeDefInt
  //
  // This method must be called after allocation, and before
  // any other method can be called.
  //
  // Succeeds if:
  // - Initialize() has not yet been called on this object.
  // - pID is a valid pointer.
  // - pTypeDef is a valid pointer.
  // - pTypeName is a valid pointer.
  // - element type is permissible for use in a String.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_ALREADY_INITIALIZED
  //   - This object has already had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - either pTypeDef or pTypeName arg is NULL.
  //
  STDMETHOD(Initialize) (THIS_
    // auid to be used to identify this type
    /*[in, ref]*/ aafUID_constref  id,

    // type of each element to be contained in this array
    /*[in]*/ IAAFTypeDef * pTypeDef,

    // friendly name of this type definition
    /*[in]*/ aafCharacter_constptr  pTypeName) PURE;


  //***********************************************************
  //
  // GetType()
  //
  // Returns the type of elements in this string.
  //
  // Succeeds if:
  // - Initialize() has already been called on this object.
  // - ppTypeDef is a valid pointer.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - ppTypeDef arg is NULL.
  //
  STDMETHOD(GetType) (THIS_
    // type of elements in this array
    /*[out]*/ IAAFTypeDef ** ppTypeDef) PURE;


  //***********************************************************
  //
  // GetCount()
  //
  // Returns number of elements contained in the referenced property
  // value.
  //
  // Succeeds if:
  // - Initialize() has already been called on this object.
  // - pPropVal is a valid pointer.
  // - pCount is a valid pointer.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - Either pPropVal or pCount arg is NULL.
  //
  STDMETHOD(GetCount) (THIS_
    // property value of array
    /*[in]*/ IAAFPropertyValue * pPropVal,

    // count of elements in the specified string property value
    /*[out]*/ aafUInt32 *  pCount) PURE;


  //***********************************************************
  //
  // CreateValueFromCString()
  //
  // Creates a property value which contains a string type.  The
  // string in the property value are initialized from data in a C
  // string which is pointed to by pInitData.  Returns the
  // newly-created property value in ppPropVal.  The size of the
  // newly-created string property value will be determined by the
  // size of the initialization C array, as communicated by
  // initDataSize.
  //
  // Succeeds if all of the following are true:
  // - the pInitData pointer is valid.
  // - the ppPropVal pointer is valid.
  //
  // If this method fails nothing will be written to *ppPropVal.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - either pInitData or ppPropVal arg is NULL.
  //
  STDMETHOD(CreateValueFromCString) (THIS_
    // pointer to compile-time C string containing data to use
    /*[in, size_is(initDataSize)]*/ aafMemPtr_t  pInitData,

    // size of data in pInitData, in bytes
    /*[in]*/ aafUInt32  initDataSize,

    // newly created property value
    /*[out]*/ IAAFPropertyValue ** ppPropVal) PURE;


  //***********************************************************
  //
  // SetCString()
  //
  // Copies all the string data contained in the C array pointed to by
  // pData into the given property value, interpreting the data as a
  // string of this type.  If dataSize indicates an array size
  // different from the size currently in the indicated array property
  // value, that array property value will be resized.
  //
  // Succeeds if all of the following are true:
  // - the pPropVal pointer is valid.
  // - the pData pointer is valid.
  //
  // If this method fails nothing will be written to *ppPropVal.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - either pPropVal or pData arg is NULL.
  //
  STDMETHOD(SetCString) (THIS_
    // property value to write
    /*[in]*/ IAAFPropertyValue * pPropVal,

    // buffer from which C string data should be read
    /*[in, size_is(dataSize)]*/ aafMemPtr_t  pData,

    // size of pData buffer in bytes
    /*[in]*/ aafUInt32  dataSize) PURE;


  //***********************************************************
  //
  // AppendElements()
  //
  // Appends elements to the end of the array, setting them to the
  // values given in the pElements array.
  //
  // Succeeds if:
  // - Initialize() has already been called on this object.
  // - pInPropVal pointer is valid.
  // - pElements pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - either pInPropVal or pElements arg is NULL.
  //
  STDMETHOD(AppendElements) (THIS_
    // property value corresponding to string to which elements are to
    // be appended
    /*[in]*/ IAAFPropertyValue * pInPropVal,

    // Null-terminated array of elements to be appended
    /*[in]*/ aafMemPtr_t  pElements) PURE;


  //***********************************************************
  //
  // GetElements()
  //
  // Gets the value of this property as a string and places it into
  // pBuffer.  bufferSize indicates the size of the buffer, in bytes.
  // 
  // Succeeds if:
  // - Initialize() has already been called on this object.
  // - The pInPropVal pointer is valid.
  // - bufferSize indicates that pBuffer is large enough to hold the
  //   data.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pInPropVal arg is NULL.
  //
  // AAFRESULT_SMALLBUF
  //   - bufferSize indicates that pBuffer is too small to hold the
  //     data.
  //
  STDMETHOD(GetElements) (THIS_
    // property value to read
    /*[in]*/ IAAFPropertyValue * pInPropVal,

    // array of values that are read
    /*[out]*/ aafMemPtr_t  pBuffer,

    // size of pBuffer, in bytes
    /*[in]*/ aafUInt32  bufferSize) PURE;




  END_INTERFACE
};
#endif // __IAAFTypeDefString_INTERFACE_DEFINED__



// IAAFTypeDefStrongObjRef

// ************************
//
// Interface IAAFTypeDefStrongObjRef
//
// ************************





#ifndef __IAAFTypeDefStrongObjRef_INTERFACE_DEFINED__
#define __IAAFTypeDefStrongObjRef_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFTypeDefStrongObjRef;

#undef  INTERFACE
#define INTERFACE   IAAFTypeDefStrongObjRef

DECLARE_INTERFACE_(IAAFTypeDefStrongObjRef, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFTypeDefStrongObjRef methods *** */

  //***********************************************************
  //
  // Initialize()
  //
  // Initializes this type def to be a reference to objects of
  // the given type, and assigns this object the given AUID.  pObjType
  // points to the class definition of the least-derived class which
  // is possible to be contained in property values of this type.
  // 
  // This method must be called after allocation, and before
  // any other method can be called.
  //
  // Succeeds if:
  // - Initialize() has not yet been called on this object.
  // - pObjType is a valid pointer.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_ALREADY_INITIALIZED
  //   - This object has already had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - either pObjType or pTypeName arg is NULL.
  //
  STDMETHOD(Initialize) (THIS_
    // auid to be used to identify this type
    /*[in, ref]*/ aafUID_constref  id,

    // class def of objects permitted to be referenced
    /*[in]*/ IAAFClassDef * pObjType,

    // friendly name of this type definition
    /*[in, string]*/ aafCharacter_constptr  pTypeName) PURE;





  END_INTERFACE
};
#endif // __IAAFTypeDefStrongObjRef_INTERFACE_DEFINED__



// IAAFTypeDefWeakObjRef

// ************************
//
// Interface IAAFTypeDefWeakObjRef
//
// ************************





#ifndef __IAAFTypeDefWeakObjRef_INTERFACE_DEFINED__
#define __IAAFTypeDefWeakObjRef_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFTypeDefWeakObjRef;

#undef  INTERFACE
#define INTERFACE   IAAFTypeDefWeakObjRef

DECLARE_INTERFACE_(IAAFTypeDefWeakObjRef, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFTypeDefWeakObjRef methods *** */

  //***********************************************************
  //
  // Initialize()
  //
  // Initializes this type def to be a reference to objects of
  // the given type, and assigns this object the given AUID.  pObjType
  // points to the class definition of the least-derived class which
  // is possible to be contained in property values of this type.
  // 
  // pTargetSet points to an array of Property Def AUIDs which
  // indicate the location of the property containing the target of
  // this weak reference.  The AUIDs indicate the containment path to
  // the target property, starting at the root Header object.  For
  // example, if the containment hierarchy is:
  // Header->A->B->C
  // then the first AUID corresponds to the Header's property which
  // contains Object A; the second AUID corresponds to Object A's
  // property which contains Object B; and the third AUID corresponds
  // to Object B's property C which contans the target of this weak
  // reference.  If any intermediate property is a vector or set,
  // *all* objects in that vector or set are searched for the target.
  // Note that the final AUID *must* correspond to a Set property.
  // 
  // The number of AUIDs in pTargetSet is noted by ids.
  // 
  // This method must be called after allocation, and before
  // any other method can be called.
  //
  // Succeeds if:
  // - Initialize() has not yet been called on this object.
  // - pObjType is a valid pointer.
  // - pTargetSet is a valid pointer.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_ALREADY_INITIALIZED
  //   - This object has already had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pObjType, pTypeName, or pTargetSet arg is NULL.
  //
  STDMETHOD(Initialize) (THIS_
    // auid to be used to identify this type
    /*[in, ref]*/ aafUID_constref  id,

    // class def of objects permitted to be referenced
    /*[in]*/ IAAFClassDef * pObjType,

    // friendly name of this type definition
    /*[in, string]*/ aafCharacter_constptr  pTypeName,

    // Number of property def IDs in pTargetSet
    /*[in]*/ aafUInt32  ids,

    // List of property definition IDs indicating the property where
    // the target is to be found.
    /*[in, size_is(ids)]*/ aafUID_constptr  pTargetSet) PURE;

  END_INTERFACE
};
#endif // __IAAFTypeDefWeakObjRef_INTERFACE_DEFINED__



// IAAFTypeDefObjectRef

// ************************
//
// Interface IAAFTypeDefObjectRef
//
// ************************







#ifndef __IAAFTypeDefObjectRef_INTERFACE_DEFINED__
#define __IAAFTypeDefObjectRef_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFTypeDefObjectRef;

#undef  INTERFACE
#define INTERFACE   IAAFTypeDefObjectRef

DECLARE_INTERFACE_(IAAFTypeDefObjectRef, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFTypeDefObjectRef methods *** */


  //***********************************************************
  //
  // GetObjectType()
  //
  // Returns the class def representing objects to which this type def
  // can refer.  The returned type def is the class definition of the
  // least-derived type which is permissible to be represented.
  //
  // Succeeds if:
  // - this object has been Initialize()d.
  // - The ppObjType pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - ppObjType arg is NULL.
  //
  STDMETHOD(GetObjectType) (THIS_
    // class def of objects permitted to be referenced
    /*[out]*/ IAAFClassDef ** ppObjType) PURE;

  //***********************************************************
  //
  // CreateValue()
  //
  // Creates a property value which contains an object reference.
  // Initializes it to refer to the given object, and returns the
  // newly-created property value in ppPropVal.
  //
  // Succeeds if:
  // - The pObj pointer is valid.
  // - The ppPropVal pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - either pObj or ppPropVal arg is NULL.
  //
  STDMETHOD(CreateValue) (THIS_
    // object with which to initialize this object reference
    /*[in]*/ IUnknown * pObj,

    // newly created property value
    /*[out]*/ IAAFPropertyValue ** ppPropVal) PURE;

  //***********************************************************
  //
  // GetObject()
  //
  // Returns the object contained in the named property value.
  // Requires that pPropVal be a strong object reference or a weak
  // object reference.
  //
  // Succeeds if:
  // - The pPropVal pointer is valid.
  // - The ppObject pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - either pPropVal or ppObject arg is NULL.
  //
  STDMETHOD(GetObject) (THIS_
    // property value from which value is to be read
    /*[in]*/ IAAFPropertyValue * pPropVal,

    // interface id of the required output
    /*[in]*/ REFIID  iid,

    // pointer to object value
    /*[out, iid_is(iid)]*/ IUnknown ** ppObject) PURE;


  //***********************************************************
  //
  // SetObject()
  //
  // Sets the named property value to refer to the named object.
  // Requires that pPropVal be a strong object reference or a weak
  // object reference.
  //
  // Succeeds if:
  // - The pPropVal pointer is valid.
  // - The ppObject pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - either pPropVal or ppObject arg is NULL.
  //
  STDMETHOD(SetObject) (THIS_
    // property value from which value is to be read
    /*[in]*/ IAAFPropertyValue * pPropVal,

    // pointer to object value
    /*[in]*/ IUnknown * pObject) PURE;




  END_INTERFACE
};
#endif // __IAAFTypeDefObjectRef_INTERFACE_DEFINED__



// IAAFTypeDefOpaque

// ************************
//
// Interface IAAFTypeDefOpaque
//
// ************************





#ifndef __IAAFTypeDefOpaque_INTERFACE_DEFINED__
#define __IAAFTypeDefOpaque_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFTypeDefOpaque;

#undef  INTERFACE
#define INTERFACE   IAAFTypeDefOpaque

DECLARE_INTERFACE_(IAAFTypeDefOpaque, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFTypeDefOpaque methods *** */


  //***********************************************************
  //
  // GetActualTypeID()
  //
  // Return the type id of the  actual data within the opaque property value.
  //
  //
  // Succeeds if all of the following are true:
  // - the pOpaquePropertyValue pointer is valid.
  // - the pActualType pointer is valid.
  //
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - either pOpaquePropertyValue or pActualTypeID arg is NULL.
  //
  // AAFRESULT_ILLEGAL_VALUE
  //   - the type of pOpaquePropertyValue was not opaque. 
  //
  //
  STDMETHOD(GetActualTypeID) (THIS_
    // indirect property value to read
    /*[in]*/ IAAFPropertyValue * pOpaquePropertyValue,

    // the type id of the actual data
    /*[out]*/ aafUID_t *  pActualTypeID) PURE;

  //***********************************************************
  //
  // GetHandle()
  //
  // Used to read and save an unknown property without having to know its contents.
  // This call fills in a handle to a block of data which can be saved in you application, and
  // later written to another file using SetHandle().  Writes the data into the pHandle buffer. 
  // The buffer is allocated by the caller, and the size of the buffer is given by
  // handleSize.
  // 
  // Caller may call GetHandleBufLen() to determine the
  // required buffer size.
  // 
  // Succeeds if all of the following are true:
  // - the pHandle pointer is valid.
  // - handleSize indicates the buffer is large enough to hold the
  //   name.
  // 
  // If this method fails nothing will be written to *pHandle.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pHandle arg is NULL.
  //
  // AAFRESULT_SMALLBUF
  //   - handleSize indicates the buffer is too small to hold the
  //     handle.
  //
  STDMETHOD(GetHandle) (THIS_
    // value to get data from.
    /*[in]*/ IAAFPropertyValue * pPropVal,

    // Size of preallocated buffer
    /*[in]*/ aafUInt32  handleSize,

    // Preallocated buffer to hold handle
    /*[out, size_is(handleSize),length_is(*bytesRead)]*/ aafDataBuffer_t  pHandle,

    // Number of actual bytes read
    /*[out]*/ aafUInt32*  bytesRead) PURE;


  //***********************************************************
  //
  // GetHandleBufLen()
  //
  // Returns the length of buffer required for the GetHandle()
  // method.  The handle is placed into the location specified by
  // pLen.
  //
  // Succeeds if all of the following are true:
  // - the pLen pointer is valid.
  //
  // If this method fails nothing will be written to *pLen.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pLen arg is NULL.
  //
  STDMETHOD(GetHandleBufLen) (THIS_
    // value to set.
    /*[in]*/ IAAFPropertyValue * pPropVal,

    // Pointer to an variable used to return the length
    /*[out]*/ aafUInt32 *  pLen) PURE;

  //***********************************************************
  //
  // SetHandle()
  //
  // This call takes a block of unknown data created by a previous call to GetHandle()
  // and saved in you application, and sets an opaque property value.
  //
  // Succeeds if all of the following are true:
  // - the pHandle pointer is valid.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pHandle is null.
  //
  STDMETHOD(SetHandle) (THIS_
    // value to write data to.
    /*[in]*/ IAAFPropertyValue * pPropVal,

    // Size of preallocated buffer
    /*[in]*/ aafUInt32  handleSize,

    // buffer containing handle
    /*[in, size_is(handleSize)]*/ aafDataBuffer_t  pHandle) PURE;

  //***********************************************************
  //
  // CreateValueFromHandle()
  //
  // This call takes a block of unknown data created by GetHandle()
  // and saved in you application, and creates an opaque property value.
  // Returns the newly-created property value in ppOpaquePropertyValue.
  //
  // Succeeds if all of the following are true:
  // - the pInitData pointer is valid.
  // - the ppOpaquePropertyValue pointer is valid.
  // - initDataSize indicates pInitData is the correct size for 
  //   the actual type.
  // - compile-time struct has had its member offests registered.
  //
  // If this method fails nothing will be written to *ppOpaquePropertyValue.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - either pInitData or ppOpaquePropertyValue arg is NULL.
  //
  // AAFRESULT_ILLEGAL_VALUE
  //   - initDataSize indicates pInitData is of the wrong size.
  //
  STDMETHOD(CreateValueFromHandle) (THIS_
    // pointer to buffer containing handle to use
    /*[in, size_is(initDataSize)]*/ aafMemPtr_t  pInitData,

    // size of handle in pInitData
    /*[in]*/ aafUInt32  initDataSize,

    // newly created property value
    /*[out]*/ IAAFPropertyValue ** ppOpaquePropertyValue) PURE;




  END_INTERFACE
};
#endif // __IAAFTypeDefOpaque_INTERFACE_DEFINED__



// IAAFTypeDefVariableArray

// ************************
//
// Interface IAAFTypeDefVariableArray
//
// ************************





#ifndef __IAAFTypeDefVariableArray_INTERFACE_DEFINED__
#define __IAAFTypeDefVariableArray_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFTypeDefVariableArray;

#undef  INTERFACE
#define INTERFACE   IAAFTypeDefVariableArray

DECLARE_INTERFACE_(IAAFTypeDefVariableArray, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFTypeDefVariableArray methods *** */
  //***********************************************************
  //
  // Initialize()
  //
  // Initializes this type def to contain elements of the given type.
  // Note that it is only possible to use certain types as the element
  // type.  Those permissible types include:
  // - AAFTypeDefInt
  // - AAFTypeDefRecord
  // - AAFTypeDefEnum
  // - AAFTypeDefExtEnum
  // - AAFTypeDefFixedArray
  // - AAFTypeDefObjectRef
  //
  // This method must be called after allocation, and before
  // any other method can be called.
  //
  // Succeeds if:
  // - Initialize() has not yet been called on this object.
  // - pID is a valid pointer.
  // - pTypeDef is a valid pointer.
  // - pTypeName is a valid pointer.
  // - element type is permissible for use in a VariableArray.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_ALREADY_INITIALIZED
  //   - This object has already had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - either pTypeDef or pTypeName arg is NULL.
  //
  // AAFRESULT_BAD_TYPE
  //   - an illegal element type was given.
  //
  STDMETHOD(Initialize) (THIS_
    // auid to be used to identify this type
    /*[in, ref]*/ aafUID_constref  id,

    // type of each element to be contained in this array
    /*[in]*/ IAAFTypeDef * pTypeDef,

    // friendly name of this type definition
    /*[in]*/ aafCharacter_constptr  pTypeName) PURE;


  //***********************************************************
  //
  // GetType()
  //
  // Returns the type of elements in this array.
  //
  // Succeeds if:
  // - Initialize() has already been called on this object.
  // - ppTypeDef is a valid pointer.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - ppTypeDef arg is NULL.
  //
  STDMETHOD(GetType) (THIS_
    // type of elements in this array
    /*[out]*/ IAAFTypeDef ** ppTypeDef) PURE;


  //***********************************************************
  //
  // GetCount()
  //
  // Returns number of array elements in the referenced property
  // value.
  //
  // Succeeds if:
  // - Initialize() has already been called on this object.
  // - pPropVal is a valid pointer.
  // - pCount is a valid pointer.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - Either pPropVal or pCount arg is NULL.
  //
  STDMETHOD(GetCount) (THIS_
    // property value of array
    /*[in]*/ IAAFPropertyValue * pPropVal,

    // count of elements in the specified array property value
    /*[out]*/ aafUInt32 *  pCount) PURE;


  //***********************************************************
  //
  // AppendElement()
  //
  // Appends an element to the end of the array, setting it to the
  // value given in pMemberPropVal.
  //
  // Succeeds if:
  // - Initialize() has already been called on this object.
  // - pInPropVal pointer is valid.
  // - pMemberPropVal pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - either pInPropVal or pMemberPropVal arg is NULL.
  //
  STDMETHOD(AppendElement) (THIS_
    // property value corresponding to array to which element is appended
    /*[in]*/ IAAFPropertyValue * pInPropVal,

    // value to be appended to this array
    /*[in]*/ IAAFPropertyValue * pMemberPropVal) PURE;


  //***********************************************************
  //
  // CreateEmptyValue()
  //
  // Creates an empty property value which contains a variable array
  // type that initially is empty (that is, contains no elements
  // yet).
  //
  // Succeeds if all of the following are true:
  // - the ppPropVal pointer is valid.
  //
  // If this method fails nothing will be written to *ppPropVal.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - ppPropVal arg is NULL.
  //
  STDMETHOD(CreateEmptyValue) (THIS_
    // newly-created empty property value
    /*[out]*/ IAAFPropertyValue ** ppPropVal) PURE;


  //***********************************************************
  //
  // CreateValueFromValues()
  //
  // Creates a property value which contains a variable array type.
  // The array elements in the property value are initialized to
  // contain the given values, passed in the pElementValues array.
  // numElements, which indicates the size of the pElementValues
  // array, determines the size of the array in the new array
  // property value.
  //
  // Succeeds if all of the following are true:
  // - the pElementValues pointer is valid.
  // - the ppPropVal pointer is valid.
  //
  // If this method fails nothing will be written to *ppPropVal.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - either pElementValues or ppPropVal arg is NULL.
  //
  STDMETHOD(CreateValueFromValues) (THIS_
    // array of property values for elements of array value which
    // is to be created.
    /*[in, size_is(numElements)]*/ IAAFPropertyValue ** pElementValues,

    // size of pElementValues array.
    /*[in]*/ aafUInt32  numElements,

    // newly-created property value
    /*[out]*/ IAAFPropertyValue ** ppPropVal) PURE;


  //***********************************************************
  //
  // CreateValueFromCArray()
  //
  // Creates a property value which contains a fixed array type.  The
  // array elements in the property value are initialized from data in
  // a C array which is pointed to by pInitData.  Requires that any
  // structures declared within this array typedef have had their
  // offsets registered with that type.  Returns the newly-created
  // property value in ppPropVal.  The size of the newly-created array
  // property value will be determined by the number of elements in
  // the initialization C array, as communicated by initDataSize.
  //
  // Succeeds if all of the following are true:
  // - the pInitData pointer is valid.
  // - the ppPropVal pointer is valid.
  // - compile-time struct has had its member offests registered.
  //
  // If this method fails nothing will be written to *ppPropVal.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - either pInitData or ppPropVal arg is NULL.
  //
  // AAFRESULT_NOT_REGISTERED
  //  - any contained struct offsets have not yet been registered for
  //    that typedef.
  //
  STDMETHOD(CreateValueFromCArray) (THIS_
    // pointer to compile-time C array containing data to use
    /*[in, size_is(initDataSize)]*/ aafMemPtr_t  pInitData,

    // size of data in pInitData, in bytes
    /*[in]*/ aafUInt32  initDataSize,

    // newly created property value
    /*[out]*/ IAAFPropertyValue ** ppPropVal) PURE;


  //***********************************************************
  //
  // GetElementValue()
  //
  // Gets a single property value corresponding to the indexed array
  // element.  Places a property value representing the array element
  // identified by the index into ppOutPropval.  Index is zero-based,
  // and must be less than the value returned by GetCount().
  // 
  // Succeeds if:
  // - Initialize() has already been called on this object.
  // - the index exists in this array type def.
  // - The pInPropVal pointer is valid.
  // - The ppOutPropVal pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - Either pInPropVal or ppOutPropVal arg is NULL.
  //
  // AAFRESULT_BAD_PARAM
  //   - The given index is out of range for this array type def.
  //
  STDMETHOD(GetElementValue) (THIS_
    // property value to read
    /*[in]*/ IAAFPropertyValue * pInPropVal,

    // zero-based index into elements in this array type
    /*[in]*/ aafUInt32  index,

    // value that is read
    /*[out]*/ IAAFPropertyValue ** ppOutPropVal) PURE;


  //***********************************************************
  //
  // GetCArray()
  //
  // Copies all the array data contained in the given property value,
  // interpreted as a fixed array of this type, into the C array
  // pointed to by pData.  Requires that any structures declared
  // within this array typedef have had their offsets registered with
  // that type.
  //
  // Succeeds if all of the following are true:
  // - the pPropVal pointer is valid.
  // - the pData pointer is valid.
  // - dataSize indicates pData is large enough to hold the data.
  // - compile-time struct has had its member offests registered.
  //
  // If this method fails nothing will be written to *ppPropVal.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - either pPropVal or pData arg is NULL.
  //
  // AAFRESULT_BAD_PARAM
  //   - dataSize indicates pData is too small.
  //
  // AAFRESULT_NOT_REGISTERED
  //  - struct offsets have not yet been registered for this typedef.
  //
  STDMETHOD(GetCArray) (THIS_
    // property value to read
    /*[in]*/ IAAFPropertyValue * pPropVal,

    // buffer into which C array data should be written
    /*[out, size_is(dataSize)]*/ aafMemPtr_t  pData,

    // size of pData buffer in bytes
    /*[in]*/ aafUInt32  dataSize) PURE;


  //***********************************************************
  //
  // SetElementValue()
  //
  // Sets the value of the single, indicated element of the fixed
  // array contained in pPropVal, to the value contained in
  // pMemberPropVal.  Index is zero-based, and must be less than the
  // value returned by GetCount().  Property value must be of the
  // same type as returned by GetType().
  // 
  // Succeeds if:
  // - Initialize() has already been called on this object.
  // - the index exists in this array type def.
  // - The pInPropVal pointer is valid.
  // - The ppOutPropVal pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - either pInPropVal or ppOutPropVal arg is NULL.
  //
  // AAFRESULT_BAD_PARAM
  //   - The given index is out of range for this array type def.
  //
  STDMETHOD(SetElementValue) (THIS_
    // property value to write
    /*[in]*/ IAAFPropertyValue * pPropVal,

    // zero-based index into members in this array type
    /*[in]*/ aafUInt32  index,

    // value to be placed into this array
    /*[in]*/ IAAFPropertyValue * pMemberPropVal) PURE;


  //***********************************************************
  //
  // SetCArray()
  //
  // Copies all the array data contained in the C array pointed to by
  // pData into the given property value, interpreting the data as a
  // fixed array of this type.  Requires that any structures declared
  // within this typedef have had their offsets registered with that
  // type.  If dataSize indicates an array size different from the
  // size currently in the indicated array property value, that array
  // property value will be resized.
  //
  // Succeeds if all of the following are true:
  // - the pPropVal pointer is valid.
  // - the pData pointer is valid.
  // - any contained compile-time struct has had its member offests
  //   registered.
  //
  // If this method fails nothing will be written to *ppPropVal.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - either pPropVal or pData arg is NULL.
  //
  // AAFRESULT_NOT_REGISTERED
  //  - offsets of any contained struct have not yet been registered.
  //
  STDMETHOD(SetCArray) (THIS_
    // property value to write
    /*[in]*/ IAAFPropertyValue * pPropVal,

    // buffer from which C array data should be read
    /*[in, size_is(dataSize)]*/ aafMemPtr_t  pData,

    // size of pData buffer in bytes
    /*[in]*/ aafUInt32  dataSize) PURE;




  //***********************************************************
  //
  // GetElements()
  //
  // Returns an enumerator across elements in this set.
  // 
  // Succeeds if:
  // - Initialize() has already been called on this object.
  // - The PSetPropVal pointer is valid.
  // - The ppEnum pointer is valid.
  //
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - Either PSetPropVal or ppEnum arg is NULL.
  //
  STDMETHOD(GetElements) (THIS_
    // property value to read
    /*[in]*/ IAAFPropertyValue * PSetPropVal,

    // enumerator across property values
    /*[out]*/ IEnumAAFPropertyValues ** ppEnum) PURE;






  END_INTERFACE
};
#endif // __IAAFTypeDefVariableArray_INTERFACE_DEFINED__


// IAAFVaryingValue

// ************************
//
// Interface IAAFVaryingValue
//
// ************************








#ifndef __IAAFVaryingValue_INTERFACE_DEFINED__
#define __IAAFVaryingValue_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFVaryingValue;

#undef  INTERFACE
#define INTERFACE   IAAFVaryingValue

DECLARE_INTERFACE_(IAAFVaryingValue, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFVaryingValue methods *** */


  //***********************************************************
  //
  // Initialize()
  //
  // Initializes a new varying value object to be identified with the
  // given the given parameter definition and interpolation definition.
  //
  // This method must be called after allocation, and before
  // any other method can be called.
  //
  // Succeeds if:
  // - Initialize() has not yet been called on this object.
  // - pParameterDef and pInterpolation are a valid pointers.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_ALREADY_INITIALIZED
  //   - This object has already had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pParameterDef or pInterpolation arg is NULL.
  // 
  //
  STDMETHOD(Initialize) (THIS_
    // Parameter definition for this object (this determines the type of the varying value)
    /*[in]*/ IAAFParameterDef * pParameterDef,

    // InterpolationDefinition object
    /*[in]*/ IAAFInterpolationDef * pInterpolation) PURE;

  //***********************************************************
  //
  // AddControlPoint()
  //
  // Adds a control point to the AAFVaryingValue object.
  // The point will be sorted by time order, not the order in which
  // the points were added.
  // 
  // Succeeds if all of the following are true:
  // - the pControlPoint pointer is valid.
  // 
  // If this method fails no state will be changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pControlPoint is null.
  //
  STDMETHOD(AddControlPoint) (THIS_
    // pointer to IAAFControlPoint object
    /*[in]*/ IAAFControlPoint * pControlPoint) PURE;


  //***********************************************************
  //
  // GetControlPoints()
  //
  // Return an enumerator for the list of IAAFControlPoints.  The list
  // will be returned in time order, not the order in which the
  // points were added.
  // 
  // Succeeds if all of the following are true:
  // - the ppEnum pointer is valid.
  // 
  // If this method fails nothing will be written to *ppEnum.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppEnum is null.
  //
  STDMETHOD(GetControlPoints) (THIS_
    // Parameter definition enumeration
    /*[out,retval]*/ IEnumAAFControlPoints ** ppEnum) PURE;


  //***********************************************************
  //
  // CountControlPoints()
  //
  // This function returns the number of control points in the sequence.
  // 
  // Succeeds if all of the following are true:
  // - this object has already been initialized.
  // - the pResult pointer is valid.
  // 
  // If this method fails no state is changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - Initialize() has already been called on this object.
  //
  // AAFRESULT_NULL_PARAM
  //   - pResult is null.
  //
  STDMETHOD(CountControlPoints) (THIS_
    // Number of control points
    /*[out]*/ aafUInt32 *  pResult) PURE;


  //***********************************************************
  //
  // GetControlPointAt()
  //
  // This function retrieves the input control point at the given index in
  // the given sequence.
  // 
  // Succeeds if all of the following are true:
  // - this object has already been initialized.
  // - the ppControlPoint pointer is valid.
  // - index is less than the value returned by
  //   CountControlPoints().
  // 
  // If this method fails nothing will be written to *ppControlPoint.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - Initialize() has already been called on this object.
  //
  // AAFRESULT_NULL_PARAM
  //   - pControlPoint is null.
  //
  // AAFRESULT_BADINDEX
  //   - index is greater than or equal to the value returned by
  //     CountControlPoints().
  //
  STDMETHOD(GetControlPointAt) (THIS_
    // index of control point to retrieve
    /*[in]*/ aafUInt32  index,

    // Retrieved control point
    /*[out, retval]*/ IAAFControlPoint ** ppControlPoint) PURE;


  //***********************************************************
  //
  // RemoveControlPointAt()
  //
  // This function removes the input control point at the given index in
  // the given sequence.  Control points already existing at indices
  // higher than the given index will be moved to the next lower index
  // to accommodate.
  // 
  // Succeeds if all of the following are true:
  // - this object has already been initialized.
  // - index is less than the value returned by
  //   CountControlPoints().
  // 
  // If this method fails no state will be changed.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - Initialize() has already been called on this object.
  //
  // AAFRESULT_BADINDEX
  //   - index is greater than or equal to the value returned by
  //     CountControlPoints().
  //
  STDMETHOD(RemoveControlPointAt) (THIS_
    // index of control point to remove
    /*[in]*/ aafUInt32  index) PURE;


  //***********************************************************
  //
  // GetInterpolationDefinition()
  //
  // Places the InterpolationDefinition object attached to this
  // VaryingValue into the *ppInterpolation argument.  If none exists
  // yet, NULL is placed into the *ppInterpolation argument.
  //
  // The returned InterpolationDefinition object, if it exists, is
  // AddRef()ed before it is returned.
  //
  // Succeeds if all of the following are true:
  // - the ppInterpolation pointer is valid.
  // - A valid InterpolationDefinition exists.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - ppInterpolation is null.
  //
  STDMETHOD(GetInterpolationDefinition) (THIS_
    // Returned InterpolationDefinition object
    /*[out]*/ IAAFInterpolationDef ** ppInterpolation) PURE;

  //***********************************************************
  //
  // GetValueBufLen()
  //
  // Returns the length of buffer required for the
  // GetInterpolatedValue() method.  The value is placed into the
  // location specified by pLen.
  //
  // Succeeds if all of the following are true:
  // - the pLen pointer is valid.
  //
  // If this method fails nothing will be written to *pLen.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pLen arg is NULL.
  //
  STDMETHOD(GetValueBufLen) (THIS_
    // Mob Name
    /*[out]*/ aafInt32 *  pLen) PURE;


  //***********************************************************
  //
  // GetInterpolatedValue()
  //
  // Writes the interpolated value of the IAAFVaryingValue at a given
  // position into the pValue buffer.  The buffer is allocated by the
  // caller, and the size of the buffer is given by valueSize.
  // 
  // Caller may call GetValueBufLen() to determine the
  // required buffer size.
  // 
  // Succeeds if all of the following are true:
  // - the pValue pointer is valid.
  // - valueSize indicates the buffer is large enough to hold the name.
  // 
  // If this method fails nothing will be written to *pValue.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pValue arg is NULL.
  //
  // AAFRESULT_SMALLBUF
  //   - valueSize indicates the buffer is too small to hold the value.
  //
  STDMETHOD(GetInterpolatedValue) (THIS_
    // Position along the operation group
    /*[in]*/ aafRational_t  inputValue,

    // Size of preallocated buffer
    /*[in]*/ aafInt32  valueSize,

    // Preallocated buffer to hold value
    /*[out,
		   size_is(valueSize),length_is(*bytesRead)]*/ aafDataBuffer_t  pValue,

    // Number of actual bytes read
    /*[out]*/ aafInt32 *  bytesRead) PURE;

  END_INTERFACE
};
#endif // __IAAFVaryingValue_INTERFACE_DEFINED__



// IAAFWAVEDescriptor

// ************************
//
// Interface IAAFWAVEDescriptor
//
// ************************



#ifndef __IAAFWAVEDescriptor_INTERFACE_DEFINED__
#define __IAAFWAVEDescriptor_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFWAVEDescriptor;

#undef  INTERFACE
#define INTERFACE   IAAFWAVEDescriptor

DECLARE_INTERFACE_(IAAFWAVEDescriptor, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFWAVEDescriptor methods *** */

  //***********************************************************
  //
  // Initialize()
  //
  // Initializes a newly allocated, empty
  // IAAFWaveDescriptor-supporting object.  This method must be
  // called after allocation, and before any other method can be
  // called.
  //
  // Succeeds if:
  // - Initialize() has not yet been called on this object.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_ALREADY_INITIALIZED
  //   - Initialize() has already been called on this object.
  STDMETHOD(Initialize) (THIS) PURE;


  //***********************************************************
  //
  // GetSummary()
  //
  // Gets a copy of the WAVE file information without the media.
  // 
  // Succeeds if all of the following are true:
  // - pSummary is a valid pointer.
  // - The size of the buffer is large enough to hold the WAVE file
  //   information.
  // 
  // If this method fails pSummary will not be changed.
  // 
  // This method will return the following codes:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.
  //
  // AAFRESULT_NULL_PARAM
  //   - pSummary arg is NULL.
  //
  // AAFRESULT_SMALLBUF
  //   - The buffer is too small to hold the WAVE file information.
  //
  STDMETHOD(GetSummary) (THIS_
    // Size of preallocated buffer
    /*[in]*/ aafUInt32  size,

    // Preallocated buffer to hold the WAVE file information
    /*[out, size_is(size)]*/ aafDataValue_t  pSummary) PURE;


  //***********************************************************
  //
  // GetSummaryBufferSize()
  //
  // Returns the size of the buffer required for the GetSummary()
  // method.  The value is placed into the location specified by pSize.
  //
  // Succeeds if all of the following are true:
  // - the pSize pointer is valid.
  //
  // If this method fails nothing will be written to *pSize.
  //
  // This method will return the following codes:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.
  //
  // AAFRESULT_NULL_PARAM
  //   - pSize arg is NULL.
  //
  STDMETHOD(GetSummaryBufferSize) (THIS_
    // required buffer size
    /*[out]*/ aafUInt32 *  pSize) PURE;


  //***********************************************************
  //
  // SetSummary()
  //
  // Sets the WAVE file information.
  // 
  // Succeeds if all of the following are true:
  // - pSummary is a valid pointer
  // 
  // If this method fails the summary property will not be
  // changed.
  // 
  // This method will return the following codes:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.
  //
  // AAFRESULT_NULL_PARAM
  //   - pSummary arg is NULL.
  //
  STDMETHOD(SetSummary) (THIS_
    // Size of preallocated buffer
    /*[in]*/ aafUInt32  size,

    // buffer containing value
    /*[in, size_is(size)]*/ aafDataValue_t  pSummary) PURE;



  END_INTERFACE
};
#endif // __IAAFWAVEDescriptor_INTERFACE_DEFINED__



// IEnumAAFClassDefs

// ************************
//
// Interface IEnumAAFClassDefs
//
// ************************




#ifndef __IEnumAAFClassDefs_INTERFACE_DEFINED__
#define __IEnumAAFClassDefs_INTERFACE_DEFINED__

EXTERN_C const IID IID_IEnumAAFClassDefs;

#undef  INTERFACE
#define INTERFACE   IEnumAAFClassDefs

DECLARE_INTERFACE_(IEnumAAFClassDefs, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IEnumAAFClassDefs methods *** */

  //***********************************************************
  //
  // NextOne()
  //
  // Enumerates to the next element in the enumerators list. The
  // caller is responsible for properly releasing the returned pointer
  // when it is no longer needed.
  // 
  // Succeeds if all of the following are true:
  // - the ppClassDefs pointer is valid.
  // - there are Class Definition objects remaining to be returned.
  // 
  // If this method fails nothing is written to *ppClassDefs.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppClassDefs arg is NULL.
  //
  // AAFRESULT_NO_MORE_OBJECTS
  //   - no Class Definition objects remaining to be returned.
  //
  STDMETHOD(NextOne) (THIS_
    // The Next Class Definition
    /*[out,retval]*/ IAAFClassDef ** ppClassDefs) PURE;


  //***********************************************************
  //
  // Next()
  //
  // Enumerates the next count elements (AAFClassDef pointers) in the
  // enumerator's list, returning them in the given array along with
  // the actual number of enumerated elements in pNumFetched. The caller
  // is responsible for properly releasing the returned pointers.
  // 
  // Succeeds if all of the following are true:
  // - The ppClassDefs pointer is valid.
  // - The pNumFetched pointer is valid. If count is 1, pNumFetched
  //   can be NULL.
  // - There are Class Definition objects remaining to be returned.
  // 
  // If this method fails nothing is written to *ppClassDefs or
  // pNumFetched.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - Either ppClassDefs or pNumFetched arg is NULL.
  //
  STDMETHOD(Next) (THIS_
    // number of ClassDefs requested
    /*[in]*/ aafUInt32  count,

    // array to receive elements
    /*[out, size_is(count), length_is(*pNumFetched)]*/ IAAFClassDef ** ppClassDefs,

    // number of actual Class Definition objects fetched into ppClassDefs array
    /*[out,ref]*/ aafUInt32 *  pNumFetched) PURE;


  //***********************************************************
  //
  // Skip()
  //
  // Instructs the enumerator to skip the next count elements in the
  // enumeration so that the next call to Next will not return those
  // elements.
  // 
  // Succeeds if all of the following are true:
  // - count is less than or equal to the number of remaining objects.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NO_MORE_OBJECTS
  //   - count exceeded number of remaining objects.
  //
  STDMETHOD(Skip) (THIS_
    // Number of elements to skip
    /*[in]*/ aafUInt32  count) PURE;


  //***********************************************************
  //
  // Reset()
  //
  // Instructs the enumerator to position itself at the beginning of
  // the list of elements.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  STDMETHOD(Reset) (THIS) PURE;


  //***********************************************************
  //
  // Clone()
  //
  // Creates another enumerator with the same state as the current
  // enumerator to iterate over the same list. This method makes it
  // possible to record a point in the enumeration sequence in order
  // to return to that point at a later time.
  //
  // Note: The caller must release this new enumerator separately from
  // the first enumerator.
  // 
  // Succeeds if all of the following are true:
  // - the ppEnum pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppEnum arg is NULL.
  //
  STDMETHOD(Clone) (THIS_
    // new enumeration
    /*[out,retval]*/ IEnumAAFClassDefs ** ppEnum) PURE;

  END_INTERFACE
};
#endif // __IEnumAAFClassDefs_INTERFACE_DEFINED__



// IEnumAAFCodecDefs

// ************************
//
// Interface IEnumAAFCodecDefs
//
// ************************




#ifndef __IEnumAAFCodecDefs_INTERFACE_DEFINED__
#define __IEnumAAFCodecDefs_INTERFACE_DEFINED__

EXTERN_C const IID IID_IEnumAAFCodecDefs;

#undef  INTERFACE
#define INTERFACE   IEnumAAFCodecDefs

DECLARE_INTERFACE_(IEnumAAFCodecDefs, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IEnumAAFCodecDefs methods *** */

  //***********************************************************
  //
  // NextOne()
  //
  // Enumerates to the next element in the enumerators list. The
  // caller is responsible for properly releasing the returned pointer
  // when it is no longer needed.
  // 
  // Succeeds if all of the following are true:
  // - the ppCodecDefs pointer is valid.
  // - there are Codec Definition objects remaining to be returned.
  // 
  // If this method fails nothing is written to *ppCodecDefs.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppCodecDefs arg is NULL.
  //
  // AAFRESULT_NO_MORE_OBJECTS
  //   - no Codec Definition objects remaining to be returned.
  //
  STDMETHOD(NextOne) (THIS_
    // The Next Codec Definition
    /*[out,retval]*/ IAAFCodecDef ** ppCodecDefs) PURE;


  //***********************************************************
  //
  // Next()
  //
  // Enumerates the next count elements (AAFCodecDef pointers) in the
  // enumerator's list, returning them in the given array along with
  // the actual number of enumerated elements in pNumFetched. The caller
  // is responsible for properly releasing the returned pointers.
  // 
  // Succeeds if all of the following are true:
  // - The ppCodecDefs pointer is valid.
  // - The pNumFetched pointer is valid. If count is 1, pNumFetched
  //   can be NULL.
  // - There are Codec Definition objects remaining to be returned.
  // 
  // If this method fails nothing is written to *ppCodecDefs or
  // pNumFetched.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - Either ppCodecDefs or pNumFetched arg is NULL.
  //
  STDMETHOD(Next) (THIS_
    // number of CodecDefs requested
    /*[in]*/ aafUInt32  count,

    // array to receive elements
    /*[out, size_is(count), length_is(*pNumFetched)]*/ IAAFCodecDef ** ppCodecDefs,

    // number of actual Codec Definition objects fetched into ppCodecDefs array
    /*[out,ref]*/ aafUInt32 *  pNumFetched) PURE;


  //***********************************************************
  //
  // Skip()
  //
  // Instructs the enumerator to skip the next count elements in the
  // enumeration so that the next call to Next will not return those
  // elements.
  // 
  // Succeeds if all of the following are true:
  // - count is less than or equal to the number of remaining objects.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NO_MORE_OBJECTS
  //   - count exceeded number of remaining objects.
  //
  STDMETHOD(Skip) (THIS_
    // Number of elements to skip
    /*[in]*/ aafUInt32  count) PURE;


  //***********************************************************
  //
  // Reset()
  //
  // Instructs the enumerator to position itself at the beginning of
  // the list of elements.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  STDMETHOD(Reset) (THIS) PURE;


  //***********************************************************
  //
  // Clone()
  //
  // Creates another enumerator with the same state as the current
  // enumerator to iterate over the same list. This method makes it
  // possible to record a point in the enumeration sequence in order
  // to return to that point at a later time.
  //
  // Note: The caller must release this new enumerator separately from
  // the first enumerator.
  // 
  // Succeeds if all of the following are true:
  // - the ppEnum pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppEnum arg is NULL.
  //
  STDMETHOD(Clone) (THIS_
    // new enumeration
    /*[out,retval]*/ IEnumAAFCodecDefs ** ppEnum) PURE;

  END_INTERFACE
};
#endif // __IEnumAAFCodecDefs_INTERFACE_DEFINED__



// IEnumAAFCodecFlavours

// ************************
//
// Interface IEnumAAFCodecFlavours
//
// ************************



#ifndef __IEnumAAFCodecFlavours_INTERFACE_DEFINED__
#define __IEnumAAFCodecFlavours_INTERFACE_DEFINED__

EXTERN_C const IID IID_IEnumAAFCodecFlavours;

#undef  INTERFACE
#define INTERFACE   IEnumAAFCodecFlavours

DECLARE_INTERFACE_(IEnumAAFCodecFlavours, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IEnumAAFCodecFlavours methods *** */

  //***********************************************************
  //
  // NextOne()
  //
  // Enumerates to the next element in the enumerators list. The
  // caller is responsible for passing in a pointer to an aafUID_t,
  // and retains control over the pointer.
  //
  // This is a just simplified version of the Next method. 
  //
  STDMETHOD(NextOne) (THIS_
    // The Next flavour code
    /*[out,retval]*/ aafUID_t *  pAAFCodecFlavour) PURE;


  //***********************************************************
  //
  // Next()
  //
  // Enumerates the next count elements (codec flavour IDs) in
  // the enumerator's list, returning them in the given array along
  // with the actual number of enumerated elements in pFetched. The
  // caller is responsible for passing in a pointer to an array of
  // aafUID_t, and retains control over the pointer.
  //
  STDMETHOD(Next) (THIS_
    // number of AAFPluggableDefs requested
    /*[in]*/ aafUInt32  count,

    // array to receive flavour codes
    /*[out, size_is(count), length_is(*pFetched)]*/ aafUID_t *  pAAFCodecFlavours,

    // number of actual flavour IDs fetched into pAAFCodecFlavours array
    /*[out,ref]*/ aafUInt32 *  pFetched) PURE;


  //***********************************************************
  //
  // Skip()
  //
  // Instructs the enumerator to skip the next count elements in the
  // enumeration so that the next call to EnumAAFCodecFlavours::Next
  // will not return those elements.
  //
  STDMETHOD(Skip) (THIS_
    // Number of elements to skip
    /*[in]*/ aafUInt32  count) PURE;


  //***********************************************************
  //
  // Reset()
  //
  // Instructs the enumerator to position itself at the beginning of
  // the list of elements.
  //
  // There is no guarantee that the same set of elements will be
  // enumerated on each pass through the list, nor will the elements
  // necessarily be enumerated in the same order. The exact behavior
  // depends on the collection being enumerated.
  STDMETHOD(Reset) (THIS) PURE;


  //***********************************************************
  //
  // Clone()
  //
  // Creates another EnumAAFCodecFlavours enumerator with the same
  // state as the current enumerator to iterate over the same
  // list.  This method makes it possible to record a point in the
  // enumeration sequence in order to return to that point at a later
  // time.
  // 
  // The caller must release this new enumerator separately from the
  // first enumerator.
  //
  STDMETHOD(Clone) (THIS_
    // new enumeration
    /*[out,retval]*/ IEnumAAFCodecFlavours ** ppEnum) PURE;

  END_INTERFACE
};
#endif // __IEnumAAFCodecFlavours_INTERFACE_DEFINED__



// IEnumAAFComponents

// ************************
//
// Interface IEnumAAFComponents
//
// ************************




#ifndef __IEnumAAFComponents_INTERFACE_DEFINED__
#define __IEnumAAFComponents_INTERFACE_DEFINED__

EXTERN_C const IID IID_IEnumAAFComponents;

#undef  INTERFACE
#define INTERFACE   IEnumAAFComponents

DECLARE_INTERFACE_(IEnumAAFComponents, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IEnumAAFComponents methods *** */

  //***********************************************************
  //
  // NextOne()
  //
  // Enumerates to the next element in the enumerators list. The
  // caller is responsible for properly releasing the returned pointer
  // when it is no longer needed.
  // 
  // Succeeds if all of the following are true:
  // - the ppComponent pointer is valid.
  // - there are Component objects remaining to be returned.
  // 
  // If this method fails nothing is written to *ppComponent.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppComponent is null.
  //
  // AAFRESULT_NO_MORE_OBJECTS
  //   - no Components remaining to be returned.
  //
  STDMETHOD(NextOne) (THIS_
    // The Next Component
    /*[out,retval]*/ IAAFComponent ** ppComponent) PURE;


  //***********************************************************
  //
  // Next()
  //
  // Enumerates the next count elements (AAFComponent pointers) in the
  // enumerator's list, returning them in the given array along with
  // the actual number of enumerated elements in pNumFetched. The caller
  // is responsible for properly releasing the returned pointers.
  // 
  // Succeeds if all of the following are true:
  // - The ppComponents pointer is valid.
  // - The pNumFetched pointer is valid. If count is 1, pNumFetched can be NULL.
  // - There are Component objects remaining to be returned.
  // 
  // If this method fails nothing is written to *ppComponents or
  // pNumFetched.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - either ppComponents or pNumFetched is null.
  //
  STDMETHOD(Next) (THIS_
    // number of components requested
    /*[in]*/ aafUInt32  count,

    // array to receive components
    /*[out, size_is(count), length_is(*pNumFetched)]*/ IAAFComponent ** ppComponents,

    // number of actual Components fetched into ppComponents array
    /*[out,ref]*/ aafUInt32 *  pNumFetched) PURE;


  //***********************************************************
  //
  // Skip()
  //
  // Instructs the enumerator to skip the next count elements in the
  // enumeration so that the next call to Next will not
  // return those elements.
  // 
  // Succeeds if all of the following are true:
  // - count is less than or equal to the number of remaining objects.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  //
  // AAFRESULT_SUCCESS
  //   - succeeded.
  //
  // AAFRESULT_NO_MORE_OBJECTS
  //   - count exceeded number of remaining objects.
  //
  STDMETHOD(Skip) (THIS_
    // Number of elements to skip
    /*[in]*/ aafUInt32  count) PURE;


  //***********************************************************
  //
  // Reset()
  //
  // Instructs the enumerator to position itself at the beginning of
  // the list of elements.
  // 
  // Always succeeds.
  // 
  // This method will return the following code:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  STDMETHOD(Reset) (THIS) PURE;


  //***********************************************************
  //
  // Clone()
  //
  // Creates another component enumerator with the same state as the current
  // enumerator to iterate over the same list. This method makes it
  // possible to record a point in the enumeration sequence in order
  // to return to that point at a later time.
  //
  // Note: The caller must release this new enumerator separately from
  // the first enumerator.
  // 
  // Succeeds if all of the following are true:
  // - the ppEnum pointer is valid.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppEnum is null.
  //
  STDMETHOD(Clone) (THIS_
    // new enumeration
    /*[out,retval]*/ IEnumAAFComponents ** ppEnum) PURE;

  END_INTERFACE
};
#endif // __IEnumAAFComponents_INTERFACE_DEFINED__



// IEnumAAFContainerDefs

// ************************
//
// Interface IEnumAAFContainerDefs
//
// ************************



#ifndef __IEnumAAFContainerDefs_INTERFACE_DEFINED__
#define __IEnumAAFContainerDefs_INTERFACE_DEFINED__

EXTERN_C const IID IID_IEnumAAFContainerDefs;

#undef  INTERFACE
#define INTERFACE   IEnumAAFContainerDefs

DECLARE_INTERFACE_(IEnumAAFContainerDefs, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IEnumAAFContainerDefs methods *** */

  //***********************************************************
  //
  // NextOne()
  //
  // Enumerates to the next element in the enumerators list. The
  // caller is responsible for properly releasing the returned pointer
  // when it is no longer needed.
  // 
  // Succeeds if all of the following are true:
  // - the ppContainerDefs pointer is valid.
  // - there are Container Definition objects remaining to be returned.
  // 
  // If this method fails nothing is written to *ppContainerDefs.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppContainerDefs arg is NULL.
  //
  // AAFRESULT_NO_MORE_OBJECTS
  //   - no Container Definition objects remaining to be returned.
  //
  STDMETHOD(NextOne) (THIS_
    // The Next Container Definition
    /*[out,retval]*/ IAAFContainerDef ** ppContainerDefs) PURE;


  //***********************************************************
  //
  // Next()
  //
  // Enumerates the next count elements (AAFContainerDef pointers) in the
  // enumerator's list, returning them in the given array along with
  // the actual number of enumerated elements in pNumFetched. The caller
  // is responsible for properly releasing the returned pointers.
  // 
  // Succeeds if all of the following are true:
  // - The ppContainerDefs pointer is valid.
  // - The pNumFetched pointer is valid. If count is 1, pNumFetched
  //   can be NULL.
  // - There are Container Definition objects remaining to be returned.
  // 
  // If this method fails nothing is written to *ppContainerDefs or
  // pNumFetched.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - Either ppContainerDefs or pNumFetched arg is NULL.
  //
  STDMETHOD(Next) (THIS_
    // number of ContainerDefs requested
    /*[in]*/ aafUInt32  count,

    // array to receive elements
    /*[out, size_is(count), length_is(*pNumFetched)]*/ IAAFContainerDef ** ppContainerDefs,

    // number of actual Container Definition objects fetched into ppContainerDefs array
    /*[out,ref]*/ aafUInt32 *  pNumFetched) PURE;


  //***********************************************************
  //
  // Skip()
  //
  // Instructs the enumerator to skip the next count elements in the
  // enumeration so that the next call to Next will not return those
  // elements.
  // 
  // Succeeds if all of the following are true:
  // - count is less than or equal to the number of remaining objects.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NO_MORE_OBJECTS
  //   - count exceeded number of remaining objects.
  //
  STDMETHOD(Skip) (THIS_
    // Number of elements to skip
    /*[in]*/ aafUInt32  count) PURE;


  //***********************************************************
  //
  // Reset()
  //
  // Instructs the enumerator to position itself at the beginning of
  // the list of elements.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  STDMETHOD(Reset) (THIS) PURE;


  //***********************************************************
  //
  // Clone()
  //
  // Creates another enumerator with the same state as the current
  // enumerator to iterate over the same list. This method makes it
  // possible to record a point in the enumeration sequence in order
  // to return to that point at a later time.
  //
  // Note: The caller must release this new enumerator separately from
  // the first enumerator.
  // 
  // Succeeds if all of the following are true:
  // - the ppEnum pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppEnum arg is NULL.
  //
  STDMETHOD(Clone) (THIS_
    // new enumeration
    /*[out,retval]*/ IEnumAAFContainerDefs ** ppEnum) PURE;

  END_INTERFACE
};
#endif // __IEnumAAFContainerDefs_INTERFACE_DEFINED__



// IEnumAAFControlPoints

// ************************
//
// Interface IEnumAAFControlPoints
//
// ************************



#ifndef __IEnumAAFControlPoints_INTERFACE_DEFINED__
#define __IEnumAAFControlPoints_INTERFACE_DEFINED__

EXTERN_C const IID IID_IEnumAAFControlPoints;

#undef  INTERFACE
#define INTERFACE   IEnumAAFControlPoints

DECLARE_INTERFACE_(IEnumAAFControlPoints, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IEnumAAFControlPoints methods *** */

  //***********************************************************
  //
  // NextOne()
  //
  // Enumerates to the next element in the enumerators list. The
  // caller is responsible for properly releasing the returned pointer
  // when it is no longer needed.
  // 
  // Succeeds if all of the following are true:
  // - the ppControlPoints pointer is valid.
  // - there are Control Point objects remaining to be returned.
  // 
  // If this method fails nothing is written to *ppControlPoints.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppControlPoints arg is NULL.
  //
  // AAFRESULT_NO_MORE_OBJECTS
  //   - no Control Point objects remaining to be returned.
  //
  STDMETHOD(NextOne) (THIS_
    // The Next Control Point
    /*[out,retval]*/ IAAFControlPoint ** ppControlPoints) PURE;


  //***********************************************************
  //
  // Next()
  //
  // Enumerates the next count elements (AAFControlPoint pointers) in the
  // enumerator's list, returning them in the given array along with
  // the actual number of enumerated elements in pNumFetched. The caller
  // is responsible for properly releasing the returned pointers.
  // 
  // Succeeds if all of the following are true:
  // - The ppControlPoints pointer is valid.
  // - The pNumFetched pointer is valid. If count is 1, pNumFetched
  //   can be NULL.
  // - There are Control Point objects remaining to be returned.
  // 
  // If this method fails nothing is written to *ppControlPoints or
  // pNumFetched.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - Either ppControlPoints or pNumFetched arg is NULL.
  //
  STDMETHOD(Next) (THIS_
    // number of ControlPoints requested
    /*[in]*/ aafUInt32  count,

    // array to receive elements
    /*[out, size_is(count), length_is(*pNumFetched)]*/ IAAFControlPoint ** ppControlPoints,

    // number of actual Control Point objects fetched into ppControlPoints array
    /*[out,ref]*/ aafUInt32 *  pNumFetched) PURE;


  //***********************************************************
  //
  // Skip()
  //
  // Instructs the enumerator to skip the next count elements in the
  // enumeration so that the next call to Next will not return those
  // elements.
  // 
  // Succeeds if all of the following are true:
  // - count is less than or equal to the number of remaining objects.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NO_MORE_OBJECTS
  //   - count exceeded number of remaining objects.
  //
  STDMETHOD(Skip) (THIS_
    // Number of elements to skip
    /*[in]*/ aafUInt32  count) PURE;


  //***********************************************************
  //
  // Reset()
  //
  // Instructs the enumerator to position itself at the beginning of
  // the list of elements.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  STDMETHOD(Reset) (THIS) PURE;


  //***********************************************************
  //
  // Clone()
  //
  // Creates another enumerator with the same state as the current
  // enumerator to iterate over the same list. This method makes it
  // possible to record a point in the enumeration sequence in order
  // to return to that point at a later time.
  //
  // Note: The caller must release this new enumerator separately from
  // the first enumerator.
  // 
  // Succeeds if all of the following are true:
  // - the ppEnum pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppEnum arg is NULL.
  //
  STDMETHOD(Clone) (THIS_
    // new enumeration
    /*[out,retval]*/ IEnumAAFControlPoints ** ppEnum) PURE;

  END_INTERFACE
};
#endif // __IEnumAAFControlPoints_INTERFACE_DEFINED__



// IEnumAAFDataDefs

// ************************
//
// Interface IEnumAAFDataDefs
//
// ************************



#ifndef __IEnumAAFDataDefs_INTERFACE_DEFINED__
#define __IEnumAAFDataDefs_INTERFACE_DEFINED__

EXTERN_C const IID IID_IEnumAAFDataDefs;

#undef  INTERFACE
#define INTERFACE   IEnumAAFDataDefs

DECLARE_INTERFACE_(IEnumAAFDataDefs, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IEnumAAFDataDefs methods *** */

  //***********************************************************
  //
  // NextOne()
  //
  // Enumerates to the next element in the enumerators list. The
  // caller is responsible for properly releasing the returned pointer
  // when it is no longer needed.
  // 
  // Succeeds if all of the following are true:
  // - the ppDataDefs pointer is valid.
  // - there are Data Definition objects remaining to be returned.
  // 
  // If this method fails nothing is written to *ppDataDefs.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppDataDefs arg is NULL.
  //
  // AAFRESULT_NO_MORE_OBJECTS
  //   - no Data Definition objects remaining to be returned.
  //
  STDMETHOD(NextOne) (THIS_
    // The Next Data Definition
    /*[out,retval]*/ IAAFDataDef ** ppDataDefs) PURE;


  //***********************************************************
  //
  // Next()
  //
  // Enumerates the next count elements (AAFDataDef pointers) in the
  // enumerator's list, returning them in the given array along with
  // the actual number of enumerated elements in pNumFetched. The caller
  // is responsible for properly releasing the returned pointers.
  // 
  // Succeeds if all of the following are true:
  // - The ppDataDefs pointer is valid.
  // - The pNumFetched pointer is valid. If count is 1, pNumFetched
  //   can be NULL.
  // - There are Data Definition objects remaining to be returned.
  // 
  // If this method fails nothing is written to *ppDataDefs or
  // pNumFetched.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - Either ppDataDefs or pNumFetched arg is NULL.
  //
  STDMETHOD(Next) (THIS_
    // number of DataDefs requested
    /*[in]*/ aafUInt32  count,

    // array to receive elements
    /*[out, size_is(count), length_is(*pNumFetched)]*/ IAAFDataDef ** ppDataDefs,

    // number of actual Data Definition objects fetched into ppDataDefs array
    /*[out,ref]*/ aafUInt32 *  pNumFetched) PURE;


  //***********************************************************
  //
  // Skip()
  //
  // Instructs the enumerator to skip the next count elements in the
  // enumeration so that the next call to Next will not return those
  // elements.
  // 
  // Succeeds if all of the following are true:
  // - count is less than or equal to the number of remaining objects.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NO_MORE_OBJECTS
  //   - count exceeded number of remaining objects.
  //
  STDMETHOD(Skip) (THIS_
    // Number of elements to skip
    /*[in]*/ aafUInt32  count) PURE;


  //***********************************************************
  //
  // Reset()
  //
  // Instructs the enumerator to position itself at the beginning of
  // the list of elements.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  STDMETHOD(Reset) (THIS) PURE;


  //***********************************************************
  //
  // Clone()
  //
  // Creates another enumerator with the same state as the current
  // enumerator to iterate over the same list. This method makes it
  // possible to record a point in the enumeration sequence in order
  // to return to that point at a later time.
  //
  // Note: The caller must release this new enumerator separately from
  // the first enumerator.
  // 
  // Succeeds if all of the following are true:
  // - the ppEnum pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppEnum arg is NULL.
  //
  STDMETHOD(Clone) (THIS_
    // new enumeration
    /*[out,retval]*/ IEnumAAFDataDefs ** ppEnum) PURE;

  END_INTERFACE
};
#endif // __IEnumAAFDataDefs_INTERFACE_DEFINED__



// IEnumAAFIdentifications

// ************************
//
// Interface IEnumAAFIdentifications
//
// ************************




#ifndef __IEnumAAFIdentifications_INTERFACE_DEFINED__
#define __IEnumAAFIdentifications_INTERFACE_DEFINED__

EXTERN_C const IID IID_IEnumAAFIdentifications;

#undef  INTERFACE
#define INTERFACE   IEnumAAFIdentifications

DECLARE_INTERFACE_(IEnumAAFIdentifications, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IEnumAAFIdentifications methods *** */

  //***********************************************************
  //
  // NextOne()
  //
  // Enumerates to the next element in the enumerators list. The
  // caller is responsible for properly releasing the returned pointer
  // when it is no longer needed. 
  // 
  // Succeeds if all of the following are true:
  // - the ppIdentification pointer is valid.
  // - there are Identification objects remaining to be returned.
  // 
  // If this method fails nothing is written to *ppIdentification.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppIdentification is null.
  //
  // AAFRESULT_NO_MORE_OBJECTS
  //   - no Identifications remaining to be returned.
  //
  STDMETHOD(NextOne) (THIS_
    // The Next Identification
    /*[out, retval]*/ IAAFIdentification ** ppIdentification) PURE;


  //***********************************************************
  //
  // Next()
  //
  // // Enumerates the next count elements (AAFIdentification pointers)
  // in the enumerator's list, returning them in the given array
  // along with the actual number of enumerated elements in
  // pNumFetched. The caller is responsible for properly releasing the
  // returned pointers when thery are no longer needed.
  // 
  // Succeeds if all of the following are true:
  // - the ppIdentifications pointer is valid.
  // - the pNumFetched pointer is valid.
  // - there are Identification objects remaining to be returned.
  // 
  // If this method fails nothing is written to *ppIdentifications or
  // pNumFetched.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - either ppIdentification or pNumFetched is null.
  //
  STDMETHOD(Next) (THIS_
    // number of identifications requested
    /*[in]*/ aafUInt32  count,

    // array to receive identification objects
    /*[out, size_is(count), length_is(*pNumFetched)]*/ IAAFIdentification ** ppIdentifications,

    // number of actual Identifications fetched into ppIdentifications array
    /*[out]*/ aafUInt32 *  pNumFetched) PURE;


  //***********************************************************
  //
  // Skip()
  //
  // // Instructs the enumerator to skip the next count elements in the
  // enumeration so that the next call to EnumAAFIdentifications::Next
  // will not return those elements.
  // 
  // Succeeds if all of the following are true:
  // - count is less than or equal to the number of remaining objects.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NO_MORE_OBJECTS
  //   - count exceeded number of remaining objects.
  //
  STDMETHOD(Skip) (THIS_
    // Number of elements to skip
    /*[in]*/ aafUInt32  count) PURE;


  //***********************************************************
  //
  // Reset()
  //
  // Instructs the enumerator to position itself at the beginning of
  // the list of elements.
  // 
  // Always succeeds.
  // 
  // This method will return the following code:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  STDMETHOD(Reset) (THIS) PURE;


  //***********************************************************
  //
  // Clone()
  //
  // // Creates another identification enumerator with the same state as
  // the current enumerator to iterate over the same list. This method
  // makes it possible to record a point in the enumeration sequence
  // in order to return to that point at a later time.
  //
  // Note: The caller must release this new enumerator separately from
  // the first enumerator.
  // 
  // Succeeds if all of the following are true:
  // - the ppEnum pointer is valid.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppEnum is null.
  //
  STDMETHOD(Clone) (THIS_
    // new enumeration
    /*[out, retval]*/ IEnumAAFIdentifications ** ppEnum) PURE;

  END_INTERFACE
};
#endif // __IEnumAAFIdentifications_INTERFACE_DEFINED__



// IEnumAAFInterpolationDefs

// ************************
//
// Interface IEnumAAFInterpolationDefs
//
// ************************



#ifndef __IEnumAAFInterpolationDefs_INTERFACE_DEFINED__
#define __IEnumAAFInterpolationDefs_INTERFACE_DEFINED__

EXTERN_C const IID IID_IEnumAAFInterpolationDefs;

#undef  INTERFACE
#define INTERFACE   IEnumAAFInterpolationDefs

DECLARE_INTERFACE_(IEnumAAFInterpolationDefs, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IEnumAAFInterpolationDefs methods *** */

  //***********************************************************
  //
  // NextOne()
  //
  // Enumerates to the next element in the enumerators list. The
  // caller is responsible for properly releasing the returned pointer
  // when it is no longer needed.
  // 
  // Succeeds if all of the following are true:
  // - the ppInterpolationDefs pointer is valid.
  // - there are Interpolation Definition objects remaining to be returned.
  // 
  // If this method fails nothing is written to *ppInterpolationDefs.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppInterpolationDefs arg is NULL.
  //
  // AAFRESULT_NO_MORE_OBJECTS
  //   - no Interpolation Definition objects remaining to be returned.
  //
  STDMETHOD(NextOne) (THIS_
    // The Next Interpolation Definition
    /*[out,retval]*/ IAAFInterpolationDef ** ppInterpolationDefs) PURE;


  //***********************************************************
  //
  // Next()
  //
  // Enumerates the next count elements (AAFInterpolationDef pointers) in the
  // enumerator's list, returning them in the given array along with
  // the actual number of enumerated elements in pNumFetched. The caller
  // is responsible for properly releasing the returned pointers.
  // 
  // Succeeds if all of the following are true:
  // - The ppInterpolationDefs pointer is valid.
  // - The pNumFetched pointer is valid. If count is 1, pNumFetched
  //   can be NULL.
  // - There are Interpolation Definition objects remaining to be returned.
  // 
  // If this method fails nothing is written to *ppInterpolationDefs or
  // pNumFetched.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - Either ppInterpolationDefs or pNumFetched arg is NULL.
  //
  STDMETHOD(Next) (THIS_
    // number of InterpolationDefs requested
    /*[in]*/ aafUInt32  count,

    // array to receive elements
    /*[out, size_is(count), length_is(*pNumFetched)]*/ IAAFInterpolationDef ** ppInterpolationDefs,

    // number of actual Interpolation Definition objects fetched into ppInterpolationDefs array
    /*[out,ref]*/ aafUInt32 *  pNumFetched) PURE;


  //***********************************************************
  //
  // Skip()
  //
  // Instructs the enumerator to skip the next count elements in the
  // enumeration so that the next call to Next will not return those
  // elements.
  // 
  // Succeeds if all of the following are true:
  // - count is less than or equal to the number of remaining objects.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NO_MORE_OBJECTS
  //   - count exceeded number of remaining objects.
  //
  STDMETHOD(Skip) (THIS_
    // Number of elements to skip
    /*[in]*/ aafUInt32  count) PURE;


  //***********************************************************
  //
  // Reset()
  //
  // Instructs the enumerator to position itself at the beginning of
  // the list of elements.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  STDMETHOD(Reset) (THIS) PURE;


  //***********************************************************
  //
  // Clone()
  //
  // Creates another enumerator with the same state as the current
  // enumerator to iterate over the same list. This method makes it
  // possible to record a point in the enumeration sequence in order
  // to return to that point at a later time.
  //
  // Note: The caller must release this new enumerator separately from
  // the first enumerator.
  // 
  // Succeeds if all of the following are true:
  // - the ppEnum pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppEnum arg is NULL.
  //
  STDMETHOD(Clone) (THIS_
    // new enumeration
    /*[out,retval]*/ IEnumAAFInterpolationDefs ** ppEnum) PURE;

  END_INTERFACE
};
#endif // __IEnumAAFInterpolationDefs_INTERFACE_DEFINED__



// IEnumAAFOperationDefs

// ************************
//
// Interface IEnumAAFOperationDefs
//
// ************************



#ifndef __IEnumAAFOperationDefs_INTERFACE_DEFINED__
#define __IEnumAAFOperationDefs_INTERFACE_DEFINED__

EXTERN_C const IID IID_IEnumAAFOperationDefs;

#undef  INTERFACE
#define INTERFACE   IEnumAAFOperationDefs

DECLARE_INTERFACE_(IEnumAAFOperationDefs, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IEnumAAFOperationDefs methods *** */

  //***********************************************************
  //
  // NextOne()
  //
  // Enumerates to the next element in the enumerators list. The
  // caller is responsible for properly releasing the returned pointer
  // when it is no longer needed.
  // 
  // Succeeds if all of the following are true:
  // - the ppOperationDefs pointer is valid.
  // - there are Operation Definition objects remaining to be returned.
  // 
  // If this method fails nothing is written to *ppOperationDefs.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppOperationDefs arg is NULL.
  //
  // AAFRESULT_NO_MORE_OBJECTS
  //   - no Operation Definition objects remaining to be returned.
  //
  STDMETHOD(NextOne) (THIS_
    // The Next Operation Definition
    /*[out,retval]*/ IAAFOperationDef ** ppOperationDefs) PURE;


  //***********************************************************
  //
  // Next()
  //
  // Enumerates the next count elements (AAFOperationDef pointers) in the
  // enumerator's list, returning them in the given array along with
  // the actual number of enumerated elements in pNumFetched. The caller
  // is responsible for properly releasing the returned pointers.
  // 
  // Succeeds if all of the following are true:
  // - The ppOperationDefs pointer is valid.
  // - The pNumFetched pointer is valid. If count is 1, pNumFetched
  //   can be NULL.
  // - There are Operation Definition objects remaining to be returned.
  // 
  // If this method fails nothing is written to *ppOperationDefs or
  // pNumFetched.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - Either ppOperationDefs or pNumFetched arg is NULL.
  //
  STDMETHOD(Next) (THIS_
    // number of OperationDefs requested
    /*[in]*/ aafUInt32  count,

    // array to receive elements
    /*[out, size_is(count), length_is(*pNumFetched)]*/ IAAFOperationDef ** ppOperationDefs,

    // number of actual Operation Definition objects fetched into ppOperationDefs array
    /*[out,ref]*/ aafUInt32 *  pNumFetched) PURE;


  //***********************************************************
  //
  // Skip()
  //
  // Instructs the enumerator to skip the next count elements in the
  // enumeration so that the next call to Next will not return those
  // elements.
  // 
  // Succeeds if all of the following are true:
  // - count is less than or equal to the number of remaining objects.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NO_MORE_OBJECTS
  //   - count exceeded number of remaining objects.
  //
  STDMETHOD(Skip) (THIS_
    // Number of elements to skip
    /*[in]*/ aafUInt32  count) PURE;


  //***********************************************************
  //
  // Reset()
  //
  // Instructs the enumerator to position itself at the beginning of
  // the list of elements.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  STDMETHOD(Reset) (THIS) PURE;


  //***********************************************************
  //
  // Clone()
  //
  // Creates another enumerator with the same state as the current
  // enumerator to iterate over the same list. This method makes it
  // possible to record a point in the enumeration sequence in order
  // to return to that point at a later time.
  //
  // Note: The caller must release this new enumerator separately from
  // the first enumerator.
  // 
  // Succeeds if all of the following are true:
  // - the ppEnum pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppEnum arg is NULL.
  //
  STDMETHOD(Clone) (THIS_
    // new enumeration
    /*[out,retval]*/ IEnumAAFOperationDefs ** ppEnum) PURE;

  END_INTERFACE
};
#endif // __IEnumAAFOperationDefs_INTERFACE_DEFINED__



// IEnumAAFEssenceData

// ************************
//
// Interface IEnumAAFEssenceData
//
// ************************







#ifndef __IEnumAAFEssenceData_INTERFACE_DEFINED__
#define __IEnumAAFEssenceData_INTERFACE_DEFINED__

EXTERN_C const IID IID_IEnumAAFEssenceData;

#undef  INTERFACE
#define INTERFACE   IEnumAAFEssenceData

DECLARE_INTERFACE_(IEnumAAFEssenceData, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IEnumAAFEssenceData methods *** */


  //***********************************************************
  //
  // NextOne()
  //
  // Enumerates to the next element in the enumerators list. The caller is responsible for 
  // properly releasing the returned pointer when it is no longer needed.
  // @comm This is a just simplified version of the Next method. 
  //
  STDMETHOD(NextOne) (THIS_
    // The Next EssenceData
    /*[out,retval]*/ IAAFEssenceData ** ppEssenceData) PURE;

  //***********************************************************
  //
  // Next()
  //
  // Enumerates the next count elements (AAFEssenceData pointers) in 
  // the enumerator's list, returning them in the given array along with the actual 
  // number of enumerated elements in pcFetched. The caller is responsible for 
  // properly releasing the returned pointers.
  //
  STDMETHOD(Next) (THIS_
    // number of essence data requested
    /*[in]*/ aafUInt32  count,

    // array to receive EssenceData
    /*[out, size_is(count), length_is(*pFetched)]*/ IAAFEssenceData ** ppEssenceData,

    // number of actual EssenceData fetched into ppEssenceData array
    /*[out,ref]*/ aafUInt32 *  pFetched) PURE;

  //***********************************************************
  //
  // Skip()
  //
  // Instructs the enumerator to skip the next count elements in the enumeration so that 
  // the next call to EnumAAFEssenceData::Next will not return 
  // those elements.
  //
  STDMETHOD(Skip) (THIS_
    // Number of elements to skip
    /*[in]*/ aafUInt32  count) PURE;

  //***********************************************************
  //
  // Reset()
  //
  // Instructs the enumerator to position itself at the beginning of the list of elements. 
  // @comm There is no guarantee that the same set of elements will be enumerated on 
  // each pass through the list, nor will the elements necessarily be enumerated in 
  // the same order. The exact behavior depends on the collection being enumerated.
  STDMETHOD(Reset) (THIS) PURE;

  //***********************************************************
  //
  // Clone()
  //
  // Creates another essence data enumerator with the same state as the current 
  // enumerator to iterate over the same list. This method makes it possible to 
  // record a point in the enumeration sequence in order to return to that point 
  // at a later time.
  // @comm The caller must release this new enumerator separately from the first enumerator.
  //
  STDMETHOD(Clone) (THIS_
    // new enumeration
    /*[out,retval]*/ IEnumAAFEssenceData ** ppEnum) PURE;


  END_INTERFACE
};
#endif // __IEnumAAFEssenceData_INTERFACE_DEFINED__



// IEnumAAFKLVData

// ************************
//
// Interface IEnumAAFKLVData
//
// ************************



#ifndef __IEnumAAFKLVData_INTERFACE_DEFINED__
#define __IEnumAAFKLVData_INTERFACE_DEFINED__

EXTERN_C const IID IID_IEnumAAFKLVData;

#undef  INTERFACE
#define INTERFACE   IEnumAAFKLVData

DECLARE_INTERFACE_(IEnumAAFKLVData, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IEnumAAFKLVData methods *** */

  //***********************************************************
  //
  // NextOne()
  //
  // Enumerates to the next element in the enumerators list. The
  // caller is responsible for properly releasing the returned pointer
  // when it is no longer needed.
  // 
  // Succeeds if all of the following are true:
  // - the ppKLVData pointer is valid.
  // - there are KLV Data objects remaining to be returned.
  // 
  // If this method fails nothing is written to *ppKLVData.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppKLVData arg is NULL.
  //
  // AAFRESULT_NO_MORE_OBJECTS
  //   - no KLV Data objects remaining to be returned.
  //
  STDMETHOD(NextOne) (THIS_
    // The Next KLV Data
    /*[out,retval]*/ IAAFKLVData ** ppKLVData) PURE;


  //***********************************************************
  //
  // Next()
  //
  // Enumerates the next count elements (AAFKLVData pointers) in the
  // enumerator's list, returning them in the given array along with
  // the actual number of enumerated elements in pNumFetched. The caller
  // is responsible for properly releasing the returned pointers.
  // 
  // Succeeds if all of the following are true:
  // - The ppKLVData pointer is valid.
  // - The pNumFetched pointer is valid. If count is 1, pNumFetched
  //   can be NULL.
  // - There are KLV Data objects remaining to be returned.
  // 
  // If this method fails nothing is written to *ppKLVData or
  // pNumFetched.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - Either ppKLVData or pNumFetched arg is NULL.
  //
  STDMETHOD(Next) (THIS_
    // number of KLVData requested
    /*[in]*/ aafUInt32  count,

    // array to receive elements
    /*[out, size_is(count), length_is(*pNumFetched)]*/ IAAFKLVData ** ppKLVData,

    // number of actual KLV Data objects fetched into ppKLVData array
    /*[out,ref]*/ aafUInt32 *  pNumFetched) PURE;


  //***********************************************************
  //
  // Skip()
  //
  // Instructs the enumerator to skip the next count elements in the
  // enumeration so that the next call to Next will not return those
  // elements.
  // 
  // Succeeds if all of the following are true:
  // - count is less than or equal to the number of remaining objects.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NO_MORE_OBJECTS
  //   - count exceeded number of remaining objects.
  //
  STDMETHOD(Skip) (THIS_
    // Number of elements to skip
    /*[in]*/ aafUInt32  count) PURE;


  //***********************************************************
  //
  // Reset()
  //
  // Instructs the enumerator to position itself at the beginning of
  // the list of elements.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  STDMETHOD(Reset) (THIS) PURE;


  //***********************************************************
  //
  // Clone()
  //
  // Creates another enumerator with the same state as the current
  // enumerator to iterate over the same list. This method makes it
  // possible to record a point in the enumeration sequence in order
  // to return to that point at a later time.
  //
  // Note: The caller must release this new enumerator separately from
  // the first enumerator.
  // 
  // Succeeds if all of the following are true:
  // - the ppEnum pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppEnum arg is NULL.
  //
  STDMETHOD(Clone) (THIS_
    // new enumeration
    /*[out,retval]*/ IEnumAAFKLVData ** ppEnum) PURE;

  END_INTERFACE
};
#endif // __IEnumAAFKLVData_INTERFACE_DEFINED__



// IEnumAAFLoadedPlugins

// ************************
//
// Interface IEnumAAFLoadedPlugins
//
// ************************







#ifndef __IEnumAAFLoadedPlugins_INTERFACE_DEFINED__
#define __IEnumAAFLoadedPlugins_INTERFACE_DEFINED__

EXTERN_C const IID IID_IEnumAAFLoadedPlugins;

#undef  INTERFACE
#define INTERFACE   IEnumAAFLoadedPlugins

DECLARE_INTERFACE_(IEnumAAFLoadedPlugins, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IEnumAAFLoadedPlugins methods *** */


  //***********************************************************
  //
  // NextOne()
  //
  // Enumerates to the next element in the enumerators list. The caller is responsible 
  // for properly releasing the returned pointer when it is no longer needed.
  // @comm This is a just simplified version of the Next method. 
  //
  STDMETHOD(NextOne) (THIS_
    // The Next AAFPluginID
    /*[out,retval]*/ aafUID_t*  ppAAFPluginID) PURE;

  //***********************************************************
  //
  // Next()
  //
  // Enumerates the next count elements (AAFPluginDesc pointers) in 
  // the enumerator's list, returning them in the given array along with the actual 
  // number of enumerated elements in pFetched. The caller is responsible for 
  // properly releasing the returned pointers.
  //
  STDMETHOD(Next) (THIS_
    // number of AAFPluginDef requested
    /*[in]*/ aafUInt32  count,

    // array to receive aafUID_t
    /*[out, size_is(count), length_is(*pFetched)]*/ aafUID_t*  pAAFPluginIDs,

    // number of actual AAFPluginDef fetched into ppAAFPluginDef array
    /*[out,ref]*/ aafUInt32 *  pFetched) PURE;

  //***********************************************************
  //
  // Skip()
  //
  // Instructs the enumerator to skip the next count elements in the enumeration so that 
  // the next call to EnumAAFLoadedPlugins::Next will not return 
  // those elements.
  //
  STDMETHOD(Skip) (THIS_
    // Number of elements to skip
    /*[in]*/ aafUInt32  count) PURE;

  //***********************************************************
  //
  // Reset()
  //
  // Instructs the enumerator to position itself at the beginning of the list of elements. 
  // @comm There is no guarantee that the same set of elements will be enumerated on 
  // each pass through the list, nor will the elements necessarily be enumerated in 
  // the same order. The exact behavior depends on the collection being enumerated.
  STDMETHOD(Reset) (THIS) PURE;

  //***********************************************************
  //
  // Clone()
  //
  // Creates another EnumAAFLoadedPlugins enumerator with the same state as the current 
  // enumerator to iterate over the same list. This method makes it possible to 
  // record a point in the enumeration sequence in order to return to that point 
  // at a later time.
  // @comm The caller must release this new enumerator separately from the first
  // enumerator.
  //
  STDMETHOD(Clone) (THIS_
    // new enumeration
    /*[out,retval]*/ IEnumAAFLoadedPlugins ** ppEnum) PURE;


  END_INTERFACE
};
#endif // __IEnumAAFLoadedPlugins_INTERFACE_DEFINED__



// IEnumAAFLocators

// ************************
//
// Interface IEnumAAFLocators
//
// ************************




#ifndef __IEnumAAFLocators_INTERFACE_DEFINED__
#define __IEnumAAFLocators_INTERFACE_DEFINED__

EXTERN_C const IID IID_IEnumAAFLocators;

#undef  INTERFACE
#define INTERFACE   IEnumAAFLocators

DECLARE_INTERFACE_(IEnumAAFLocators, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IEnumAAFLocators methods *** */

  //***********************************************************
  //
  // NextOne()
  //
  // Enumerates to the next element in the enumerators list. The
  // caller is responsible for properly releasing the returned pointer
  // when it is no longer needed.
  // 
  // Succeeds if all of the following are true:
  // - the ppLocator pointer is valid.
  // - there are Locator objects remaining to be returned.
  // 
  // If this method fails nothing is written to *ppLocator.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppLocator is null.
  //
  // AAFRESULT_NO_MORE_OBJECTS
  //   - no Locators remaining to be returned.
  //
  STDMETHOD(NextOne) (THIS_
    // The Next Locator
    /*[out,retval]*/ IAAFLocator ** ppLocator) PURE;


  //***********************************************************
  //
  // Next()
  //
  // Enumerates the next count elements (AAFLocator pointers) in 
  // the enumerator's list, returning them in the given array along
  // with the actual number of enumerated elements in pcFetched. The
  // caller is responsible for properly releasing the returned pointers.
  // 
  // Succeeds if all of the following are true:
  // - The ppLocators pointer is valid.
  // - The pNumFetched pointer is valid. If count is 1, pNumFetched can be NULL.
  // - There are Locator objects remaining to be returned.
  // 
  // If this method fails nothing is written to *ppLocators or
  // pNumFetched.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - either ppLocators or pNumFetched is null.
  //
  STDMETHOD(Next) (THIS_
    // number of locators requested
    /*[in]*/ aafUInt32  count,

    // array to receive locators
    /*[out, size_is(count), length_is(*pFetched)]*/ IAAFLocator ** ppLocators,

    // number of actual Locators fetched into ppLocators array
    /*[out,ref]*/ aafUInt32 *  pFetched) PURE;


  //***********************************************************
  //
  // Skip()
  //
  // Instructs the enumerator to skip the next count elements in the
  // enumeration so that the next call to EnumAAFLocators::Next will
  // not return those elements.
  // 
  // Succeeds if all of the following are true:
  // - count is less than or equal to the number of remaining objects.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  //
  // AAFRESULT_SUCCESS
  //   - succeeded.
  //
  // AAFRESULT_NO_MORE_OBJECTS
  //   - count exceeded number of remaining objects.
  //
  STDMETHOD(Skip) (THIS_
    // Number of elements to skip
    /*[in]*/ aafUInt32  count) PURE;


  //***********************************************************
  //
  // Reset()
  //
  // Instructs the enumerator to position itself at the beginning of
  // the list of elements.
  // 
  // Always succeeds.
  // 
  // This method will return the following code:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  STDMETHOD(Reset) (THIS) PURE;


  //***********************************************************
  //
  // Clone()
  //
  // Creates another locator enumerator with the same state as the
  // current enumerator to iterate over the same list. This method
  // makes it possible to record a point in the enumeration sequence
  // in order to return to that point at a later time.
  // Note: The caller must release this new enumerator separately from
  // the first enumerator.
  // 
  // Succeeds if all of the following are true:
  // - the ppEnum pointer is valid.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppEnum is null.
  //
  STDMETHOD(Clone) (THIS_
    // new enumeration
    /*[out,retval]*/ IEnumAAFLocators ** ppEnum) PURE;

  END_INTERFACE
};
#endif // __IEnumAAFLocators_INTERFACE_DEFINED__



// IEnumAAFMobSlots

// ************************
//
// Interface IEnumAAFMobSlots
//
// ************************




#ifndef __IEnumAAFMobSlots_INTERFACE_DEFINED__
#define __IEnumAAFMobSlots_INTERFACE_DEFINED__

EXTERN_C const IID IID_IEnumAAFMobSlots;

#undef  INTERFACE
#define INTERFACE   IEnumAAFMobSlots

DECLARE_INTERFACE_(IEnumAAFMobSlots, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IEnumAAFMobSlots methods *** */

  //***********************************************************
  //
  // NextOne()
  //
  // Enumerates to the next element in the enumerators list. The
  // caller is responsible for properly releasing the returned pointer
  // when it is no longer needed.
  // 
  // Succeeds if all of the following are true:
  // - the ppMobSlot pointer is valid.
  // - there are Mob Slot objects remaining to be returned.
  // 
  // If this method fails nothing is written to *ppMobSlot.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppMobSlot is null.
  //
  // AAFRESULT_NO_MORE_OBJECTS
  //   - Hit the end of the list of slots being enumerated over.
  //
  STDMETHOD(NextOne) (THIS_
    // The Next MobSlot
    /*[out,retval]*/ IAAFMobSlot ** ppMobSlot) PURE;


  //***********************************************************
  //
  // Next()
  //
  // Enumerates the next count elements (AAFMobSlot pointers) in 
  // the enumerator's list, returning them in the given array along
  // with the actual number of enumerated elements in pNumFetched. The
  // caller is responsible for properly releasing the returned pointers.
  // 
  // Succeeds if all of the following are true:
  // - the ppMobSlots pointer is valid.
  // - the pNumFetched pointer is valid.
  // - there are Mob Slot objects remaining to be returned.
  // 
  // If this method fails nothing is written to *ppMobSlots or
  // pNumFetched.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - either ppMob or pNumFetched is null.
  //
  // E_INVALIDARG
  //   - Hit the end of the list of slots being enumerated over.
  //
  STDMETHOD(Next) (THIS_
    // number of mob slots requested
    /*[in]*/ aafUInt32  count,

    // array to receive mob slots
    /*[out, size_is(count), length_is(*pNumFetched)]*/ IAAFMobSlot ** ppMobSlots,

    // number of actual MobSlots fetched into ppMobSlots array
    /*[out,ref]*/ aafUInt32 *  pNumFetched) PURE;


  //***********************************************************
  //
  // Skip()
  //
  // Instructs the enumerator to skip the next count elements in the
  // enumeration so that the next call to EnumAAFMobSlots::Next will
  // not return those elements.
  // 
  // Succeeds if all of the following are true:
  // - count is less than or equal to the number of remaining objects.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NO_MORE_OBJECTS
  //   - count exceeded number of remaining objects.
  //
  STDMETHOD(Skip) (THIS_
    // Number of elements to skip
    /*[in]*/ aafUInt32  count) PURE;


  //***********************************************************
  //
  // Reset()
  //
  // Instructs the enumerator to position itself at the beginning of
  // the list of elements.
  // 
  // Always succeeds.
  // 
  // This method will return the following code:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  STDMETHOD(Reset) (THIS) PURE;


  //***********************************************************
  //
  // Clone()
  //
  // Creates another mob slot enumerator with the same state as the
  // current enumerator to iterate over the same list. This method
  // makes it possible to record a point in the enumeration sequence
  // in order to return to that point at a later time.
  // 
  // Note: The caller must release this new enumerator separately from
  // the first enumerator.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppEnum is null.
  //
  STDMETHOD(Clone) (THIS_
    // new enumeration
    /*[out,retval]*/ IEnumAAFMobSlots ** ppEnum) PURE;

  END_INTERFACE
};
#endif // __IEnumAAFMobSlots_INTERFACE_DEFINED__



// IEnumAAFMobs

// ************************
//
// Interface IEnumAAFMobs
//
// ************************




#ifndef __IEnumAAFMobs_INTERFACE_DEFINED__
#define __IEnumAAFMobs_INTERFACE_DEFINED__

EXTERN_C const IID IID_IEnumAAFMobs;

#undef  INTERFACE
#define INTERFACE   IEnumAAFMobs

DECLARE_INTERFACE_(IEnumAAFMobs, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IEnumAAFMobs methods *** */

  //***********************************************************
  //
  // NextOne()
  //
  // Enumerates to the next element in the enumerators list. The
  // caller is responsible for properly releasing the returned pointer
  // when it is no longer needed.
  // 
  // Succeeds if all of the following are true:
  // - the ppMob pointer is valid.
  // - there are Mob objects remaining to be returned.
  // 
  // If this method fails nothing is written to *ppMob.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppMob is null.
  //
  // AAFRESULT_NO_MORE_OBJECTS
  //   - no Mobs remaining to be returned.
  //
  STDMETHOD(NextOne) (THIS_
    // The Next Mob
    /*[out, retval]*/ IAAFMob ** ppMob) PURE;


  //***********************************************************
  //
  // Next()
  //
  // Enumerates the next count elements (AAFMob pointers) in the
  // enumerator's list, returning them in the given array along with
  // the actual number of enumerated elements in pNumFetched. The caller
  // is responsible for properly releasing the returned pointers.
  // 
  // Succeeds if all of the following are true:
  // - the ppMobs pointer is valid.
  // - the pNumFetched pointer is valid.
  // - there are Mob objects remaining to be returned.
  // 
  // If this method fails nothing is written to *ppMobs or
  // pNumFetched.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - either ppMob or pNumFetched is null.
  //
  STDMETHOD(Next) (THIS_
    // number of mobs requested
    /*[in]*/ aafUInt32  count,

    // array to receive mobs
    /*[out, size_is(count), length_is(*pNumFetched)]*/ IAAFMob ** ppMobs,

    // number of actual Mobs fetched into ppMobs array
    /*[out]*/ aafUInt32 *  pNumFetched) PURE;


  //***********************************************************
  //
  // Skip()
  //
  // Instructs the enumerator to skip the next count elements in the
  // enumeration so that the next call to EnumAAFMobs::Next will not
  // return those elements.
  // 
  // Succeeds if all of the following are true:
  // - count is less than or equal to the number of remaining objects.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NO_MORE_OBJECTS
  //   - count exceeded number of remaining objects.
  //
  STDMETHOD(Skip) (THIS_
    // Number of elements to skip
    /*[in]*/ aafUInt32  count) PURE;


  //***********************************************************
  //
  // Reset()
  //
  // Instructs the enumerator to position itself at the beginning of
  // the list of elements.
  // 
  // Always succeeds.
  // 
  // This method will return the following code:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  STDMETHOD(Reset) (THIS) PURE;


  //***********************************************************
  //
  // Clone()
  //
  // Creates another mob enumerator with the same state as the current
  // enumerator to iterate over the same list. This method makes it
  // possible to record a point in the enumeration sequence in order
  // to return to that point at a later time.
  //
  // Note: The caller must release this new enumerator separately from
  // the first enumerator.
  // 
  // Succeeds if all of the following are true:
  // - the ppEnum pointer is valid.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppEnum is null.
  //
  STDMETHOD(Clone) (THIS_
    // new enumeration
    /*[out, retval]*/ IEnumAAFMobs ** ppEnum) PURE;

  END_INTERFACE
};
#endif // __IEnumAAFMobs_INTERFACE_DEFINED__



// IEnumAAFParameterDefs

// ************************
//
// Interface IEnumAAFParameterDefs
//
// ************************






#ifndef __IEnumAAFParameterDefs_INTERFACE_DEFINED__
#define __IEnumAAFParameterDefs_INTERFACE_DEFINED__

EXTERN_C const IID IID_IEnumAAFParameterDefs;

#undef  INTERFACE
#define INTERFACE   IEnumAAFParameterDefs

DECLARE_INTERFACE_(IEnumAAFParameterDefs, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IEnumAAFParameterDefs methods *** */


  //***********************************************************
  //
  // NextOne()
  //
  // Enumerates to the next element in the enumerators list. The
  // caller is responsible for properly releasing the returned pointer
  // when it is no longer needed.
  // 
  // Succeeds if all of the following are true:
  // - the ppParameterDef pointer is valid.
  // - there are ParameterDef objects remaining to be returned.
  // 
  // If this method fails nothing is written to *ppParameterDef.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppParameterDef is null.
  //
  // AAFRESULT_NO_MORE_OBJECTS
  //   - no ParameterDefs remaining to be returned.
  //
  STDMETHOD(NextOne) (THIS_
    // The Next ParameterDefinition
    /*[out,retval]*/ IAAFParameterDef ** ppParameterDef) PURE;

  //***********************************************************
  //
  // Next()
  //
  // Enumerates the next count elements (AAFParameterDef pointers) in the
  // enumerator's list, returning them in the given array along with
  // the actual number of enumerated elements in pNumFetched. The caller
  // is responsible for properly releasing the returned pointers.
  // 
  // Succeeds if all of the following are true:
  // - The ppParameterDefs pointer is valid.
  // - The pNumFetched pointer is valid. If count is 1, pNumFetched can be NULL.
  // - There are AAFParameterDef objects remaining to be returned.
  // 
  // If this method fails nothing is written to *ppComponents or
  // pNumFetched.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - either ppParameterDefs or pNumFetched is null.
  //
  STDMETHOD(Next) (THIS_
    // number of control code definitions requested
    /*[in]*/ aafUInt32  count,

    // array to receive control code definitions
    /*[out, size_is(count), length_is(*pFetched)]*/ IAAFParameterDef ** ppParameterDefs,

    // number of actual ParameterDefs fetched into ppParameterDefs array
    /*[out,ref]*/ aafUInt32 *  pFetched) PURE;

  //***********************************************************
  //
  // Skip()
  //
  // Instructs the enumerator to skip the next count elements in the
  // enumeration so that the next call to Next will not
  // return those elements.
  // 
  // Succeeds if all of the following are true:
  // - count is less than or equal to the number of remaining objects.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  //
  // AAFRESULT_SUCCESS
  //   - succeeded.
  //
  // AAFRESULT_NO_MORE_OBJECTS
  //   - count exceeded number of remaining objects.
  //
  STDMETHOD(Skip) (THIS_
    // Number of elements to skip
    /*[in]*/ aafUInt32  count) PURE;

  //***********************************************************
  //
  // Reset()
  //
  // Instructs the enumerator to position itself at the beginning of
  // the list of elements.
  // 
  // Always succeeds.
  // 
  // This method will return the following code:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  STDMETHOD(Reset) (THIS) PURE;
  // @comm There is no guarantee that the same set of elements will be enumerated on 
  // each pass through the list\, nor will the elements necessarily be enumerated in 
  // the same order. The exact behavior depends on the collection being enumerated.)

  //***********************************************************
  //
  // Clone()
  //
  // Creates another EnumAAFParameterDefs enumerator with the same state as the current
  // enumerator to iterate over the same list. This method makes it
  // possible to record a point in the enumeration sequence in order
  // to return to that point at a later time.
  //
  // Note: The caller must release this new enumerator separately from
  // the first enumerator.
  // 
  // Succeeds if all of the following are true:
  // - the ppEnum pointer is valid.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppEnum is null.
  //
  STDMETHOD(Clone) (THIS_
    // new enumeration
    /*[out,retval]*/ IEnumAAFParameterDefs ** ppEnum) PURE;


  END_INTERFACE
};
#endif // __IEnumAAFParameterDefs_INTERFACE_DEFINED__



// IEnumAAFParameters

// ************************
//
// Interface IEnumAAFParameters
//
// ************************




#ifndef __IEnumAAFParameters_INTERFACE_DEFINED__
#define __IEnumAAFParameters_INTERFACE_DEFINED__

EXTERN_C const IID IID_IEnumAAFParameters;

#undef  INTERFACE
#define INTERFACE   IEnumAAFParameters

DECLARE_INTERFACE_(IEnumAAFParameters, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IEnumAAFParameters methods *** */

  //***********************************************************
  //
  // NextOne()
  //
  // Enumerates to the next element in the enumerators list. The
  // caller is responsible for properly releasing the returned pointer
  // when it is no longer needed.
  // 
  // Succeeds if all of the following are true:
  // - the ppParameter pointer is valid.
  // - there are Parameter objects remaining to be returned.
  // 
  // If this method fails nothing is written to *ppParameter.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppParameter is null.
  //
  // AAFRESULT_NO_MORE_OBJECTS
  //   - no Parameters remaining to be returned.
  //
  STDMETHOD(NextOne) (THIS_
    // The Next Parameter
    /*[out,retval]*/ IAAFParameter ** ppParameter) PURE;

  //***********************************************************
  //
  // Next()
  //
  // Enumerates the next count elements (AAFParameter pointers) in
  // the enumerator's list, returning them in the given array along
  // with the actual number of enumerated elements in pNumFetched. The
  // caller is responsible for properly releasing the returned
  // pointers.
  // 
  // Succeeds if all of the following are true:
  // - The ppParameters pointer is valid.
  // - The pNumFetched pointer is valid. If count is 1, pNumFetched
  //   can be NULL.
  // - There are AAFParameter objects remaining to be returned.
  // 
  // If this method fails nothing is written to *ppComponents or
  // pNumFetched.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - either ppParameters or pNumFetched is null.
  //
  STDMETHOD(Next) (THIS_
    // number of parameter objects requested
    /*[in]*/ aafUInt32  count,

    // array to receive parameter objects
    /*[out, size_is(count), length_is(*pFetched)]*/ IAAFParameter ** ppParameters,

    // number of actual Parameters fetched into ppParameters array
    /*[out,ref]*/ aafUInt32 *  pFetched) PURE;


  //***********************************************************
  //
  // Skip()
  //
  // Instructs the enumerator to skip the next count elements in the
  // enumeration so that the next call to Next will not
  // return those elements.
  // 
  // Succeeds if all of the following are true:
  // - count is less than or equal to the number of remaining objects.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  //
  // AAFRESULT_SUCCESS
  //   - succeeded.
  //
  // AAFRESULT_NO_MORE_OBJECTS
  //   - count exceeded number of remaining objects.
  //
  STDMETHOD(Skip) (THIS_
    // Number of elements to skip
    /*[in]*/ aafUInt32  count) PURE;


  //***********************************************************
  //
  // Reset()
  //
  // Instructs the enumerator to position itself at the beginning of
  // the list of elements.
  // 
  // Always succeeds.
  // 
  // This method will return the following code:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // There is no guarantee that the same set of elements will be
  // enumerated on each pass through the list, nor will the elements
  // necessarily be enumerated in the same order. The exact behavior
  // depends on the collection being enumerated.
  STDMETHOD(Reset) (THIS) PURE;


  //***********************************************************
  //
  // Clone()
  //
  // Creates another EnumAAFParameters enumerator with the same state
  // as the current enumerator to iterate over the same list. This
  // method makes it possible to record a point in the enumeration
  // sequence in order to return to that point at a later time.
  //
  // Note: The caller must release this new enumerator separately from
  // the first enumerator.
  // 
  // Succeeds if all of the following are true:
  // - the ppEnum pointer is valid.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppEnum is null.
  //
  STDMETHOD(Clone) (THIS_
    // new enumeration
    /*[out,retval]*/ IEnumAAFParameters ** ppEnum) PURE;

  END_INTERFACE
};
#endif // __IEnumAAFParameters_INTERFACE_DEFINED__



// IEnumAAFProperties

// ************************
//
// Interface IEnumAAFProperties
//
// ************************




#ifndef __IEnumAAFProperties_INTERFACE_DEFINED__
#define __IEnumAAFProperties_INTERFACE_DEFINED__

EXTERN_C const IID IID_IEnumAAFProperties;

#undef  INTERFACE
#define INTERFACE   IEnumAAFProperties

DECLARE_INTERFACE_(IEnumAAFProperties, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IEnumAAFProperties methods *** */

  //***********************************************************
  //
  // NextOne()
  //
  // Enumerates to the next element in the enumerators list. The
  // caller is responsible for properly releasing the returned pointer
  // when it is no longer needed.
  // 
  // Succeeds if all of the following are true:
  // - the ppProperties pointer is valid.
  // - there are Property objects remaining to be returned.
  // 
  // If this method fails nothing is written to *ppProperties.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppProperties arg is NULL.
  //
  // AAFRESULT_NO_MORE_OBJECTS
  //   - no Property objects remaining to be returned.
  //
  STDMETHOD(NextOne) (THIS_
    // The Next Property
    /*[out,retval]*/ IAAFProperty ** ppProperties) PURE;


  //***********************************************************
  //
  // Next()
  //
  // Enumerates the next count elements (AAFProperty pointers) in the
  // enumerator's list, returning them in the given array along with
  // the actual number of enumerated elements in pNumFetched. The caller
  // is responsible for properly releasing the returned pointers.
  // 
  // Succeeds if all of the following are true:
  // - The ppProperties pointer is valid.
  // - The pNumFetched pointer is valid. If count is 1, pNumFetched
  //   can be NULL.
  // - There are Property objects remaining to be returned.
  // 
  // If this method fails nothing is written to *ppProperties or
  // pNumFetched.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - Either ppProperties or pNumFetched arg is NULL.
  //
  STDMETHOD(Next) (THIS_
    // number of Properties requested
    /*[in]*/ aafUInt32  count,

    // array to receive elements
    /*[out, size_is(count), length_is(*pNumFetched)]*/ IAAFProperty ** ppProperties,

    // number of actual Property objects fetched into ppProperties array
    /*[out,ref]*/ aafUInt32 *  pNumFetched) PURE;


  //***********************************************************
  //
  // Skip()
  //
  // Instructs the enumerator to skip the next count elements in the
  // enumeration so that the next call to Next will not return those
  // elements.
  // 
  // Succeeds if all of the following are true:
  // - count is less than or equal to the number of remaining objects.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NO_MORE_OBJECTS
  //   - count exceeded number of remaining objects.
  //
  STDMETHOD(Skip) (THIS_
    // Number of elements to skip
    /*[in]*/ aafUInt32  count) PURE;


  //***********************************************************
  //
  // Reset()
  //
  // Instructs the enumerator to position itself at the beginning of
  // the list of elements.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  STDMETHOD(Reset) (THIS) PURE;


  //***********************************************************
  //
  // Clone()
  //
  // Creates another enumerator with the same state as the current
  // enumerator to iterate over the same list. This method makes it
  // possible to record a point in the enumeration sequence in order
  // to return to that point at a later time.
  //
  // Note: The caller must release this new enumerator separately from
  // the first enumerator.
  // 
  // Succeeds if all of the following are true:
  // - the ppEnum pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppEnum arg is NULL.
  //
  STDMETHOD(Clone) (THIS_
    // new enumeration
    /*[out,retval]*/ IEnumAAFProperties ** ppEnum) PURE;

  END_INTERFACE
};
#endif // __IEnumAAFProperties_INTERFACE_DEFINED__



// IEnumAAFPropertyDefs

// ************************
//
// Interface IEnumAAFPropertyDefs
//
// ************************




#ifndef __IEnumAAFPropertyDefs_INTERFACE_DEFINED__
#define __IEnumAAFPropertyDefs_INTERFACE_DEFINED__

EXTERN_C const IID IID_IEnumAAFPropertyDefs;

#undef  INTERFACE
#define INTERFACE   IEnumAAFPropertyDefs

DECLARE_INTERFACE_(IEnumAAFPropertyDefs, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IEnumAAFPropertyDefs methods *** */

  //***********************************************************
  //
  // NextOne()
  //
  // Enumerates to the next element in the enumerators list. The
  // caller is responsible for properly releasing the returned pointer
  // when it is no longer needed.
  // 
  // Succeeds if all of the following are true:
  // - the ppPropertyDefs pointer is valid.
  // - there are Property Definition objects remaining to be returned.
  // 
  // If this method fails nothing is written to *ppPropertyDefs.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppPropertyDefs arg is NULL.
  //
  // AAFRESULT_NO_MORE_OBJECTS
  //   - no Property Definition objects remaining to be returned.
  //
  STDMETHOD(NextOne) (THIS_
    // The Next Property Definition
    /*[out,retval]*/ IAAFPropertyDef ** ppPropertyDefs) PURE;


  //***********************************************************
  //
  // Next()
  //
  // Enumerates the next count elements (AAFPropertyDef pointers) in the
  // enumerator's list, returning them in the given array along with
  // the actual number of enumerated elements in pNumFetched. The caller
  // is responsible for properly releasing the returned pointers.
  // 
  // Succeeds if all of the following are true:
  // - The ppPropertyDefs pointer is valid.
  // - The pNumFetched pointer is valid. If count is 1, pNumFetched
  //   can be NULL.
  // - There are Property Definition objects remaining to be returned.
  // 
  // If this method fails nothing is written to *ppPropertyDefs or
  // pNumFetched.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - Either ppPropertyDefs or pNumFetched arg is NULL.
  //
  STDMETHOD(Next) (THIS_
    // number of PropertyDefs requested
    /*[in]*/ aafUInt32  count,

    // array to receive elements
    /*[out, size_is(count), length_is(*pNumFetched)]*/ IAAFPropertyDef ** ppPropertyDefs,

    // number of actual Property Definition objects fetched into ppPropertyDefs array
    /*[out,ref]*/ aafUInt32 *  pNumFetched) PURE;


  //***********************************************************
  //
  // Skip()
  //
  // Instructs the enumerator to skip the next count elements in the
  // enumeration so that the next call to Next will not return those
  // elements.
  // 
  // Succeeds if all of the following are true:
  // - count is less than or equal to the number of remaining objects.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NO_MORE_OBJECTS
  //   - count exceeded number of remaining objects.
  //
  STDMETHOD(Skip) (THIS_
    // Number of elements to skip
    /*[in]*/ aafUInt32  count) PURE;


  //***********************************************************
  //
  // Reset()
  //
  // Instructs the enumerator to position itself at the beginning of
  // the list of elements.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  STDMETHOD(Reset) (THIS) PURE;


  //***********************************************************
  //
  // Clone()
  //
  // Creates another enumerator with the same state as the current
  // enumerator to iterate over the same list. This method makes it
  // possible to record a point in the enumeration sequence in order
  // to return to that point at a later time.
  //
  // Note: The caller must release this new enumerator separately from
  // the first enumerator.
  // 
  // Succeeds if all of the following are true:
  // - the ppEnum pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppEnum arg is NULL.
  //
  STDMETHOD(Clone) (THIS_
    // new enumeration
    /*[out,retval]*/ IEnumAAFPropertyDefs ** ppEnum) PURE;

  END_INTERFACE
};
#endif // __IEnumAAFPropertyDefs_INTERFACE_DEFINED__



// IEnumAAFPropertyValues

// ************************
//
// Interface IEnumAAFPropertyValues
//
// ************************




#ifndef __IEnumAAFPropertyValues_INTERFACE_DEFINED__
#define __IEnumAAFPropertyValues_INTERFACE_DEFINED__

EXTERN_C const IID IID_IEnumAAFPropertyValues;

#undef  INTERFACE
#define INTERFACE   IEnumAAFPropertyValues

DECLARE_INTERFACE_(IEnumAAFPropertyValues, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IEnumAAFPropertyValues methods *** */

  //***********************************************************
  //
  // NextOne()
  //
  // Enumerates to the next element in the enumerators list. The
  // caller is responsible for properly releasing the returned pointer
  // when it is no longer needed.
  // 
  // Succeeds if all of the following are true:
  // - the ppPropertyValue pointer is valid.
  // - there are Property Values remaining to be returned.
  // 
  // If this method fails nothing is written to *ppPropertyValue.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppPropertyValue is null.
  //
  // AAFRESULT_NO_MORE_OBJECTS
  //   - no Components remaining to be returned.
  //
  STDMETHOD(NextOne) (THIS_
    // The Next Property Value
    /*[out,retval]*/ IAAFPropertyValue ** ppPropertyValue) PURE;


  //***********************************************************
  //
  // Next()
  //
  // Enumerates the next count elements (AAFPropertyValue pointers)
  // in the enumerator's list, returning them in the given array
  // along with the actual number of enumerated elements in
  // pNumFetched. The caller is responsible for properly releasing the
  // returned pointers.
  // 
  // Succeeds if all of the following are true:
  // - The ppMobs pointer is valid.
  // - The pNumFetched pointer is valid. If count is 1, pNumFetched
  //   can be NULL. 
  // - There are Property Value objects remaining to be returned.
  // 
  // If this method fails nothing is written to *ppPropertyValues or
  // pNumFetched.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - either ppCompoents or pNumFetched is null.
  //
  STDMETHOD(Next) (THIS_
    // number of objects requested
    /*[in]*/ aafUInt32  count,

    // array to receive Property Values
    /*[out, size_is(count), length_is(*pFetched)]*/ IAAFPropertyValue ** ppPropertyValues,

    // number of actual Property Values fetched into ppPropertyValues
	// array
    /*[out,ref]*/ aafUInt32 *  pFetched) PURE;


  //***********************************************************
  //
  // Skip()
  //
  // Instructs the enumerator to skip the next count elements in the
  // enumeration so that the next call to Next will not
  // return those elements.
  // 
  // Succeeds if all of the following are true:
  // - count is less than or equal to the number of remaining objects.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  //
  // AAFRESULT_SUCCESS
  //   - succeeded.
  //
  // AAFRESULT_NO_MORE_OBJECTS
  //   - count exceeded number of remaining objects.
  //
  STDMETHOD(Skip) (THIS_
    // Number of elements to skip
    /*[in]*/ aafUInt32  count) PURE;


  //***********************************************************
  //
  // Reset()
  //
  // Instructs the enumerator to position itself at the beginning of
  // the list of elements.
  //
  // Always succeeds.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  //
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  STDMETHOD(Reset) (THIS) PURE;


  //***********************************************************
  //
  // Clone()
  //
  // Creates another Property Value enumerator with the same state as
  // the current enumerator to iterate over the same list. This method
  // makes it possible to record a point in the enumeration sequence
  // in order to return to that point at a later time.
  //
  // Note: The caller must release this new enumerator separately from
  // the first enumerator.
  // 
  // Succeeds if all of the following are true:
  // - the ppEnum pointer is valid.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppEnum is null.
  //
  STDMETHOD(Clone) (THIS_
    // new enumeration
    /*[out,retval]*/ IEnumAAFPropertyValues ** ppEnum) PURE;

  END_INTERFACE
};
#endif // __IEnumAAFPropertyValues_INTERFACE_DEFINED__



// IEnumAAFPluginDefs

// ************************
//
// Interface IEnumAAFPluginDefs
//
// ************************




#ifndef __IEnumAAFPluginDefs_INTERFACE_DEFINED__
#define __IEnumAAFPluginDefs_INTERFACE_DEFINED__

EXTERN_C const IID IID_IEnumAAFPluginDefs;

#undef  INTERFACE
#define INTERFACE   IEnumAAFPluginDefs

DECLARE_INTERFACE_(IEnumAAFPluginDefs, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IEnumAAFPluginDefs methods *** */

  //***********************************************************
  //
  // NextOne()
  //
  // Enumerates to the next element in the enumerators list. The
  // caller is responsible for properly releasing the returned pointer
  // when it is no longer needed.
  // 
  // Succeeds if all of the following are true:
  // - the ppPluginDefs pointer is valid.
  // - there are Plugin Definition objects remaining to be returned.
  // 
  // If this method fails nothing is written to *ppPluginDefs.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppPluginDefs arg is NULL.
  //
  // AAFRESULT_NO_MORE_OBJECTS
  //   - no Plugin Definition objects remaining to be returned.
  //
  STDMETHOD(NextOne) (THIS_
    // The Next Plugin Definition
    /*[out,retval]*/ IAAFPluginDef ** ppPluginDefs) PURE;


  //***********************************************************
  //
  // Next()
  //
  // Enumerates the next count elements (AAFPluginDef pointers) in the
  // enumerator's list, returning them in the given array along with
  // the actual number of enumerated elements in pNumFetched. The caller
  // is responsible for properly releasing the returned pointers.
  // 
  // Succeeds if all of the following are true:
  // - The ppPluginDefs pointer is valid.
  // - The pNumFetched pointer is valid. If count is 1, pNumFetched
  //   can be NULL.
  // - There are Plugin Definition objects remaining to be returned.
  // 
  // If this method fails nothing is written to *ppPluginDefs or
  // pNumFetched.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - Either ppPluginDefs or pNumFetched arg is NULL.
  //
  STDMETHOD(Next) (THIS_
    // number of PluginDefs requested
    /*[in]*/ aafUInt32  count,

    // array to receive elements
    /*[out, size_is(count), length_is(*pNumFetched)]*/ IAAFPluginDef ** ppPluginDefs,

    // number of actual Plugin Definition objects fetched into ppPluginDefs array
    /*[out,ref]*/ aafUInt32 *  pNumFetched) PURE;


  //***********************************************************
  //
  // Skip()
  //
  // Instructs the enumerator to skip the next count elements in the
  // enumeration so that the next call to Next will not return those
  // elements.
  // 
  // Succeeds if all of the following are true:
  // - count is less than or equal to the number of remaining objects.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NO_MORE_OBJECTS
  //   - count exceeded number of remaining objects.
  //
  STDMETHOD(Skip) (THIS_
    // Number of elements to skip
    /*[in]*/ aafUInt32  count) PURE;


  //***********************************************************
  //
  // Reset()
  //
  // Instructs the enumerator to position itself at the beginning of
  // the list of elements.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  STDMETHOD(Reset) (THIS) PURE;


  //***********************************************************
  //
  // Clone()
  //
  // Creates another enumerator with the same state as the current
  // enumerator to iterate over the same list. This method makes it
  // possible to record a point in the enumeration sequence in order
  // to return to that point at a later time.
  //
  // Note: The caller must release this new enumerator separately from
  // the first enumerator.
  // 
  // Succeeds if all of the following are true:
  // - the ppEnum pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppEnum arg is NULL.
  //
  STDMETHOD(Clone) (THIS_
    // new enumeration
    /*[out,retval]*/ IEnumAAFPluginDefs ** ppEnum) PURE;

  END_INTERFACE
};
#endif // __IEnumAAFPluginDefs_INTERFACE_DEFINED__



// IEnumAAFPluginLocators

// ************************
//
// Interface IEnumAAFPluginLocators
//
// ************************




#ifndef __IEnumAAFPluginLocators_INTERFACE_DEFINED__
#define __IEnumAAFPluginLocators_INTERFACE_DEFINED__

EXTERN_C const IID IID_IEnumAAFPluginLocators;

#undef  INTERFACE
#define INTERFACE   IEnumAAFPluginLocators

DECLARE_INTERFACE_(IEnumAAFPluginLocators, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IEnumAAFPluginLocators methods *** */

  //***********************************************************
  //
  // NextOne()
  //
  // Enumerates to the next element in the enumerators list. The
  // caller is responsible for properly releasing the returned pointer
  // when it is no longer needed.
  //
  STDMETHOD(NextOne) (THIS_
    // The Next AAFLocator
    /*[out,retval]*/ IAAFLocator ** ppAAFLocator) PURE;


  //***********************************************************
  //
  // Next()
  //
  // Enumerates the next count elements (AAFLocator pointers) in the
  // enumerator's list, returning them in the given array along with
  // the actual number of enumerated elements in pFetched. The caller
  // is responsible for properly releasing the returned pointers.
  //
  STDMETHOD(Next) (THIS_
    // number of AAFLocators requested
    /*[in]*/ aafUInt32  count,

    // array to receive AAFLocators
    /*[out, size_is(count), length_is(*pFetched)]*/ IAAFLocator ** ppAAFLocators,

    // number of actual AAFLocators fetched into ppAAFLocators array
    /*[out,ref]*/ aafUInt32 *  pFetched) PURE;


  //***********************************************************
  //
  // Skip()
  //
  // Instructs the enumerator to skip the next count elements in the
  // enumeration so that the next call to EnumAAFPluginLocators::Next
  // will not return  those elements.
  //
  STDMETHOD(Skip) (THIS_
    // Number of elements to skip
    /*[in]*/ aafUInt32  count) PURE;


  //***********************************************************
  //
  // Reset()
  //
  // Instructs the enumerator to position itself at the beginning of
  // the list of elements.
  //
  // There is no guarantee that the same set of elements will be
  // enumerated on each pass through the list, nor will the elements
  // necessarily be enumerated inthe same order. The exact behavior
  // depends on the collection being enumerated.
  STDMETHOD(Reset) (THIS) PURE;


  //***********************************************************
  //
  // Clone()
  //
  // Creates another AAFPluginLocators enumerator with the same state
  // as the current enumerator to iterate over the same list. This
  // method makes it possible to record a point in the enumeration
  // sequence in order to return to that point at a later time.
  //
  // The caller must release this new enumerator separately from the
  // first enumerator.
  //
  STDMETHOD(Clone) (THIS_
    // new enumeration
    /*[out,retval]*/ IEnumAAFPluginLocators ** ppEnum) PURE;

  END_INTERFACE
};
#endif // __IEnumAAFPluginLocators_INTERFACE_DEFINED__



// IEnumAAFSegments

// ************************
//
// Interface IEnumAAFSegments
//
// ************************



#ifndef __IEnumAAFSegments_INTERFACE_DEFINED__
#define __IEnumAAFSegments_INTERFACE_DEFINED__

EXTERN_C const IID IID_IEnumAAFSegments;

#undef  INTERFACE
#define INTERFACE   IEnumAAFSegments

DECLARE_INTERFACE_(IEnumAAFSegments, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IEnumAAFSegments methods *** */

  //***********************************************************
  //
  // NextOne()
  //
  // Enumerates to the next element in the enumerators list. The
  // caller is responsible for properly releasing the returned pointer
  // when it is no longer needed.
  // 
  // Succeeds if all of the following are true:
  // - the ppSegments pointer is valid.
  // - there are Segment objects remaining to be returned.
  // 
  // If this method fails nothing is written to *ppSegments.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppSegments arg is NULL.
  //
  // AAFRESULT_NO_MORE_OBJECTS
  //   - no Segment objects remaining to be returned.
  //
  STDMETHOD(NextOne) (THIS_
    // The Next Segment
    /*[out,retval]*/ IAAFSegment ** ppSegments) PURE;


  //***********************************************************
  //
  // Next()
  //
  // Enumerates the next count elements (AAFSegment pointers) in the
  // enumerator's list, returning them in the given array along with
  // the actual number of enumerated elements in pNumFetched. The caller
  // is responsible for properly releasing the returned pointers.
  // 
  // Succeeds if all of the following are true:
  // - The ppSegments pointer is valid.
  // - The pNumFetched pointer is valid. If count is 1, pNumFetched
  //   can be NULL.
  // - There are Segment objects remaining to be returned.
  // 
  // If this method fails nothing is written to *ppSegments or
  // pNumFetched.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - Either ppSegments or pNumFetched arg is NULL.
  //
  STDMETHOD(Next) (THIS_
    // number of Segments requested
    /*[in]*/ aafUInt32  count,

    // array to receive elements
    /*[out, size_is(count), length_is(*pNumFetched)]*/ IAAFSegment ** ppSegments,

    // number of actual Segment objects fetched into ppSegments array
    /*[out,ref]*/ aafUInt32 *  pNumFetched) PURE;


  //***********************************************************
  //
  // Skip()
  //
  // Instructs the enumerator to skip the next count elements in the
  // enumeration so that the next call to Next will not return those
  // elements.
  // 
  // Succeeds if all of the following are true:
  // - count is less than or equal to the number of remaining objects.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NO_MORE_OBJECTS
  //   - count exceeded number of remaining objects.
  //
  STDMETHOD(Skip) (THIS_
    // Number of elements to skip
    /*[in]*/ aafUInt32  count) PURE;


  //***********************************************************
  //
  // Reset()
  //
  // Instructs the enumerator to position itself at the beginning of
  // the list of elements.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  STDMETHOD(Reset) (THIS) PURE;


  //***********************************************************
  //
  // Clone()
  //
  // Creates another enumerator with the same state as the current
  // enumerator to iterate over the same list. This method makes it
  // possible to record a point in the enumeration sequence in order
  // to return to that point at a later time.
  //
  // Note: The caller must release this new enumerator separately from
  // the first enumerator.
  // 
  // Succeeds if all of the following are true:
  // - the ppEnum pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppEnum arg is NULL.
  //
  STDMETHOD(Clone) (THIS_
    // new enumeration
    /*[out,retval]*/ IEnumAAFSegments ** ppEnum) PURE;

  END_INTERFACE
};
#endif // __IEnumAAFSegments_INTERFACE_DEFINED__



// IEnumAAFTaggedValues

// ************************
//
// Interface IEnumAAFTaggedValues
//
// ************************



#ifndef __IEnumAAFTaggedValues_INTERFACE_DEFINED__
#define __IEnumAAFTaggedValues_INTERFACE_DEFINED__

EXTERN_C const IID IID_IEnumAAFTaggedValues;

#undef  INTERFACE
#define INTERFACE   IEnumAAFTaggedValues

DECLARE_INTERFACE_(IEnumAAFTaggedValues, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IEnumAAFTaggedValues methods *** */

  //***********************************************************
  //
  // NextOne()
  //
  // Enumerates to the next element in the enumerators list. The
  // caller is responsible for properly releasing the returned pointer
  // when it is no longer needed.
  // 
  // Succeeds if all of the following are true:
  // - the ppTaggedValues pointer is valid.
  // - there are Tagged Value objects remaining to be returned.
  // 
  // If this method fails nothing is written to *ppTaggedValues.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppTaggedValues arg is NULL.
  //
  // AAFRESULT_NO_MORE_OBJECTS
  //   - no Tagged Value objects remaining to be returned.
  //
  STDMETHOD(NextOne) (THIS_
    // The Next Tagged Value
    /*[out,retval]*/ IAAFTaggedValue ** ppTaggedValues) PURE;


  //***********************************************************
  //
  // Next()
  //
  // Enumerates the next count elements (AAFTaggedValue pointers) in the
  // enumerator's list, returning them in the given array along with
  // the actual number of enumerated elements in pNumFetched. The caller
  // is responsible for properly releasing the returned pointers.
  // 
  // Succeeds if all of the following are true:
  // - The ppTaggedValues pointer is valid.
  // - The pNumFetched pointer is valid. If count is 1, pNumFetched
  //   can be NULL.
  // - There are Tagged Value objects remaining to be returned.
  // 
  // If this method fails nothing is written to *ppTaggedValues or
  // pNumFetched.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - Either ppTaggedValues or pNumFetched arg is NULL.
  //
  STDMETHOD(Next) (THIS_
    // number of TaggedValues requested
    /*[in]*/ aafUInt32  count,

    // array to receive elements
    /*[out, size_is(count), length_is(*pNumFetched)]*/ IAAFTaggedValue ** ppTaggedValues,

    // number of actual Tagged Value objects fetched into ppTaggedValues array
    /*[out,ref]*/ aafUInt32 *  pNumFetched) PURE;


  //***********************************************************
  //
  // Skip()
  //
  // Instructs the enumerator to skip the next count elements in the
  // enumeration so that the next call to Next will not return those
  // elements.
  // 
  // Succeeds if all of the following are true:
  // - count is less than or equal to the number of remaining objects.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NO_MORE_OBJECTS
  //   - count exceeded number of remaining objects.
  //
  STDMETHOD(Skip) (THIS_
    // Number of elements to skip
    /*[in]*/ aafUInt32  count) PURE;


  //***********************************************************
  //
  // Reset()
  //
  // Instructs the enumerator to position itself at the beginning of
  // the list of elements.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  STDMETHOD(Reset) (THIS) PURE;


  //***********************************************************
  //
  // Clone()
  //
  // Creates another enumerator with the same state as the current
  // enumerator to iterate over the same list. This method makes it
  // possible to record a point in the enumeration sequence in order
  // to return to that point at a later time.
  //
  // Note: The caller must release this new enumerator separately from
  // the first enumerator.
  // 
  // Succeeds if all of the following are true:
  // - the ppEnum pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppEnum arg is NULL.
  //
  STDMETHOD(Clone) (THIS_
    // new enumeration
    /*[out,retval]*/ IEnumAAFTaggedValues ** ppEnum) PURE;

  END_INTERFACE
};
#endif // __IEnumAAFTaggedValues_INTERFACE_DEFINED__



// IEnumAAFTypeDefs

// ************************
//
// Interface IEnumAAFTypeDefs
//
// ************************



#ifndef __IEnumAAFTypeDefs_INTERFACE_DEFINED__
#define __IEnumAAFTypeDefs_INTERFACE_DEFINED__

EXTERN_C const IID IID_IEnumAAFTypeDefs;

#undef  INTERFACE
#define INTERFACE   IEnumAAFTypeDefs

DECLARE_INTERFACE_(IEnumAAFTypeDefs, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IEnumAAFTypeDefs methods *** */

  //***********************************************************
  //
  // NextOne()
  //
  // Enumerates to the next element in the enumerators list. The
  // caller is responsible for properly releasing the returned pointer
  // when it is no longer needed.
  // 
  // Succeeds if all of the following are true:
  // - the ppTypeDefs pointer is valid.
  // - there are Type Definition objects remaining to be returned.
  // 
  // If this method fails nothing is written to *ppTypeDefs.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppTypeDefs arg is NULL.
  //
  // AAFRESULT_NO_MORE_OBJECTS
  //   - no Type Definition objects remaining to be returned.
  //
  STDMETHOD(NextOne) (THIS_
    // The Next Type Definition
    /*[out,retval]*/ IAAFTypeDef ** ppTypeDefs) PURE;


  //***********************************************************
  //
  // Next()
  //
  // Enumerates the next count elements (AAFTypeDef pointers) in the
  // enumerator's list, returning them in the given array along with
  // the actual number of enumerated elements in pNumFetched. The caller
  // is responsible for properly releasing the returned pointers.
  // 
  // Succeeds if all of the following are true:
  // - The ppTypeDefs pointer is valid.
  // - The pNumFetched pointer is valid. If count is 1, pNumFetched
  //   can be NULL.
  // - There are Type Definition objects remaining to be returned.
  // 
  // If this method fails nothing is written to *ppTypeDefs or
  // pNumFetched.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - Either ppTypeDefs or pNumFetched arg is NULL.
  //
  STDMETHOD(Next) (THIS_
    // number of TypeDefs requested
    /*[in]*/ aafUInt32  count,

    // array to receive elements
    /*[out, size_is(count), length_is(*pNumFetched)]*/ IAAFTypeDef ** ppTypeDefs,

    // number of actual Type Definition objects fetched into ppTypeDefs array
    /*[out,ref]*/ aafUInt32 *  pNumFetched) PURE;


  //***********************************************************
  //
  // Skip()
  //
  // Instructs the enumerator to skip the next count elements in the
  // enumeration so that the next call to Next will not return those
  // elements.
  // 
  // Succeeds if all of the following are true:
  // - count is less than or equal to the number of remaining objects.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NO_MORE_OBJECTS
  //   - count exceeded number of remaining objects.
  //
  STDMETHOD(Skip) (THIS_
    // Number of elements to skip
    /*[in]*/ aafUInt32  count) PURE;


  //***********************************************************
  //
  // Reset()
  //
  // Instructs the enumerator to position itself at the beginning of
  // the list of elements.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  STDMETHOD(Reset) (THIS) PURE;


  //***********************************************************
  //
  // Clone()
  //
  // Creates another enumerator with the same state as the current
  // enumerator to iterate over the same list. This method makes it
  // possible to record a point in the enumeration sequence in order
  // to return to that point at a later time.
  //
  // Note: The caller must release this new enumerator separately from
  // the first enumerator.
  // 
  // Succeeds if all of the following are true:
  // - the ppEnum pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppEnum arg is NULL.
  //
  STDMETHOD(Clone) (THIS_
    // new enumeration
    /*[out,retval]*/ IEnumAAFTypeDefs ** ppEnum) PURE;

  END_INTERFACE
};
#endif // __IEnumAAFTypeDefs_INTERFACE_DEFINED__



// IAAFRawStorage

// ************************
//
// Interface IAAFRawStorage
//
// ************************



#ifndef __IAAFRawStorage_INTERFACE_DEFINED__
#define __IAAFRawStorage_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFRawStorage;

#undef  INTERFACE
#define INTERFACE   IAAFRawStorage

DECLARE_INTERFACE_(IAAFRawStorage, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFRawStorage methods *** */

  //***********************************************************
  //
  // IsReadable()
  //
  // Sets *pResult to true if this storage is readable; sets it to
  // false otherwise.
  //
  // Succeeds if:
  // - The pResult pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pResult arg is NULL.
  //
  STDMETHOD(IsReadable) (THIS_
    // set to true if readable
    /*[out]*/ aafBoolean_t *  pResult) PURE;


  //***********************************************************
  //
  // Read()
  //
  // Attempts to read bufsize bytes from this stream.  Places the data
  // into buf, and puts the actual number of bytes read into
  // *pNumRead.  If the end of the stream is encountered before
  // bufSize bytes can be read, the value written into *pNumRead may
  // be smaller than bufSize.
  //
  // This call will advance the current position by *pNumRead bytes.
  //
  // Succeeds if:
  // - The pNumBytes pointer is valid.
  // - This stream is open for read or read/write.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - buf or pNumRead arg is NULL.
  //
  // AAFRESULT_NOT_READABLE
  //   - This stream is not open for read or read/write.
  //
  STDMETHOD(Read) (THIS_
    // Buffer into which data is read
    /*[out, size_is(bufSize), length_is(*pNumRead)]*/ aafMemPtr_t  buf,

    // Size of buf in bytes
    /*[in]*/ aafUInt32  bufSize,

    // Number of bytes read
    /*[out]*/ aafUInt32 *  pNumRead) PURE;


  //***********************************************************
  //
  // IsWriteable()
  //
  // Sets *pResult to true if this storage is writeable; sets it to
  // false otherwise.
  //
  // Succeeds if:
  // - The pResult pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pResult arg is NULL.
  //
  STDMETHOD(IsWriteable) (THIS_
    // set to true if writeable
    /*[out]*/ aafBoolean_t *  pResult) PURE;


  //***********************************************************
  //
  // Write()
  //
  // Writes bufsize bytes into this stream.  Obtains the data
  // from buf.
  //
  // This call may fail if the stream has insufficient capacity to
  // complete the request.  If this storage supports the
  // IAAFRandomRawStorage interface, the client can call
  // IAAFRandomRawStorage::SetSize() to attempt to reserve capacity
  // in the stream; if the SetSize() call succeeds, subsequent
  // Write() calls within that capacity are guaranteed to succeed.
  //
  // This call will advance the current position by bufSize bytes.
  //
  // Succeeds if:
  // - This stream is open for write or read/write.
  // - Sufficient capacity exists in this stream to perform the
  //   write.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_WRITEABLE
  //   - This stream is not open for write or read/write.
  //
  // AAFRESULT_SMALLBUF
  //   - This stream has insufficient capacity to perform the write.
  //
  STDMETHOD(Write) (THIS_
    // Buffer from which data is written
    /*[in, size_is(bufSize)]*/ aafMemConstPtr_t  buf,

    // Number of bytes to write
    /*[in]*/ aafUInt32  bufSize,

    // Number of bytes written
    /*[out]*/ aafUInt32 *  pNumWritten) PURE;


  //***********************************************************
  //
  // Synchronize()
  //
  // Synchronizes any cached data with the underlying storage.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  STDMETHOD(Synchronize) (THIS) PURE;

  END_INTERFACE
};
#endif // __IAAFRawStorage_INTERFACE_DEFINED__



// IAAFRandomRawStorage

// ************************
//
// Interface IAAFRandomRawStorage
//
// ************************



#ifndef __IAAFRandomRawStorage_INTERFACE_DEFINED__
#define __IAAFRandomRawStorage_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFRandomRawStorage;

#undef  INTERFACE
#define INTERFACE   IAAFRandomRawStorage

DECLARE_INTERFACE_(IAAFRandomRawStorage, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFRandomRawStorage methods *** */

  //***********************************************************
  //
  // ReadAt()
  //
  // Attempts to read bufsize bytes from this storage.  Places the
  // data into buf, and puts the actual number of bytes read into
  // *pNumRead.  If the end of the storage is encountered before
  // bufSize bytes can be read, the value written into *pNumRead may
  // be smaller than bufSize.
  //
  // This call will advance the current position by *pNumRead bytes.
  //
  // Succeeds if:
  // - The pNumRead pointer is valid.
  // - This storage is open for read or read/write.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - buf or pNumRead arg is NULL.
  //
  // AAFRESULT_NOT_READABLE
  //   - This storage is not open for read or read/write.
  //
  STDMETHOD(ReadAt) (THIS_
    // position in this storage from which data is read
    /*[in]*/ aafUInt64  position,

    // Buffer into which data is read
    /*[out, size_is(bufSize), length_is(*pNumRead)]*/ aafMemPtr_t  buf,

    // Size of buf in bytes
    /*[in]*/ aafUInt32  bufSize,

    // Number of bytes read
    /*[out]*/ aafUInt32 *  pNumRead) PURE;


  //***********************************************************
  //
  // WriteAt()
  //
  // Writes bufsize bytes into this storage.  Obtains the data
  // from buf.
  //
  // This call may fail if the capacity of this storage cannot be
  // extended sufficiently to complete the request.  The client can
  // call SetSize() to attempt to reserve capacity for the storage;
  // if the SetSize() call succeeds, subsequent Write() calls
  // within requested that capacty are guaranteed to succeed.
  //
  // This call will advance the current position by bufSize bytes.
  //
  // Succeeds if:
  // - The pNumWritten pointer is valid.
  // - This storage is open for write or read/write.
  // - Sufficient capacity exists in this storage to perform the
  //   write.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pNumWritten arg is NULL.
  //
  // AAFRESULT_NOT_WRITEABLE
  //   - This storage is not open for write or read/write.
  //
  // AAFRESULT_OFFSET_SIZE
  //   - It is not possible to extend the allocated size of this
  //     storage.
  //
  STDMETHOD(WriteAt) (THIS_
    // position in this storage into which data is written
    /*[in]*/ aafUInt64  position,

    // Buffer from which data is written
    /*[in, size_is(bufSize)]*/ aafMemConstPtr_t  buf,

    // Number of bytes
    /*[in]*/ aafUInt32  bufSize,

    // Number of bytes written
    /*[out]*/ aafUInt32 *  pNumWritten) PURE;


  //***********************************************************
  //
  // GetSize()
  //
  // Returns the highest byte position in this storage which has been
  // written so far.
  //
  // Succeeds if:
  // - The pSize pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pSize arg is NULL.
  //
  STDMETHOD(GetSize) (THIS_
    // Number of bytes currently in this storage
    /*[out]*/ aafUInt64 *  pSize) PURE;


  //***********************************************************
  //
  // IsExtendable()
  //
  // Sets *pResult to true if the memory allocated to this storage can
  // be dynamically extened; sets it to false otherwise.
  //
  // Succeeds if:
  // - The pResult pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pResult arg is NULL.
  //
  STDMETHOD(IsExtendable) (THIS_
    // set to true if extendable
    /*[out]*/ aafBoolean_t *  pResult) PURE;


  //***********************************************************
  //
  // GetExtent()
  //
  // Returns the number of bytes currently allocated storage.
  //
  // Succeeds if:
  // - The pSize pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pExtent arg is NULL.
  //
  STDMETHOD(GetExtent) (THIS_
    // Number of bytes currently allocated for this storage
    /*[out]*/ aafUInt64 *  pExtent) PURE;


  //***********************************************************
  //
  // SetExtent()
  //
  // Requests the given capacity for this storage.  If successful,
  // subsequent calls to WriteAt() and IAAFRawStorage::Write()
  // within that capacity are guaranteed to succeed.
  //
  // Succeeds if:
  // - It is permissible to set the extent of this storage.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_OFFSET_SIZE
  //   - This storage has insufficient capacity to perform the write.
  //
  STDMETHOD(SetExtent) (THIS_
    // Number of bytes capacity requested for this storage
    /*[in]*/ aafUInt64  extent) PURE;

  END_INTERFACE
};
#endif // __IAAFRandomRawStorage_INTERFACE_DEFINED__



// IAAFGetFileBits

// ************************
//
// Interface IAAFGetFileBits
//
// ************************



#ifndef __IAAFGetFileBits_INTERFACE_DEFINED__
#define __IAAFGetFileBits_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFGetFileBits;

#undef  INTERFACE
#define INTERFACE   IAAFGetFileBits

DECLARE_INTERFACE_(IAAFGetFileBits, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFGetFileBits methods *** */

  //***********************************************************
  //
  // ReadAt()
  //
  // Attempts to read bufsize bytes from this stream at the given byte
  // offset.  Places the data into buf.  Any attempt to read beyond
  // the size of this file, as reported by GetSize(), will be
  // considered an error.
  //
  // A value of zero for position indicates the beginning of the
  // stream.
  //
  // Succeeds if:
  // - The pNumBytes pointer is valid.
  // - position + buSize is not larger than the size of this file, as
  //   reported by GetSize().
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - buf arg is NULL.
  //
  // AAFRESULT_OFFSET_SIZE
  //   - position + size is larger than the size of this file.
  //
  STDMETHOD(ReadAt) (THIS_
    // Buffer into which data is read
    /*[out, size_is(bufSize)]*/ aafMemPtr_t  buf,

    // Size of buf in bytes
    /*[in]*/ aafUInt32  bufSize,

    // The position in bytes at which to read
    /*[in]*/ aafUInt64  position) PURE;


  //***********************************************************
  //
  // GetSize()
  //
  // Returns the size of this file, in bytes, in *pSize.
  //
  // Succeeds if:
  // - The pSize pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pSize arg is NULL.
  //
  STDMETHOD(GetSize) (THIS_
    // The size of this file in bytes
    /*[out]*/ aafUInt64 *  pSize) PURE;

  END_INTERFACE
};
#endif // __IAAFGetFileBits_INTERFACE_DEFINED__



// IAAFSetFileBits

// ************************
//
// Interface IAAFSetFileBits
//
// ************************



#ifndef __IAAFSetFileBits_INTERFACE_DEFINED__
#define __IAAFSetFileBits_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFSetFileBits;

#undef  INTERFACE
#define INTERFACE   IAAFSetFileBits

DECLARE_INTERFACE_(IAAFSetFileBits, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFSetFileBits methods *** */

  //***********************************************************
  //
  // WriteAt()
  //
  // Writes bufsize bytes into this file at the given byte offset.
  // Obtains the data from buf.  A value of zero for position
  // indicates the beginning of the stream.
  //
  // Succeeds if sufficient space is available in the file to write
  // the given number of bytes at the given position.  It's possible
  // to guarantee that this method will succeed if SetSize() is first
  // called to reserve the required space.  If SetSize() is not first
  // called to reserve the space, this method will attempt to request
  // it, but this attempt may fail.
  //
  // Succeeds if:
  // - The buf argument is a valid pointer.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - buf arg is NULL.
  //
  // AAFRESULT_DATA_SIZE
  //   - The requested space is not available.
  //
  STDMETHOD(WriteAt) (THIS_
    // Buffer from which data is written
    /*[in, size_is(bufSize)]*/ aafMemPtr_t  buf,

    // Number of bytes
    /*[in]*/ aafUInt32  bufSize,

    // The position in bytes at which to read
    /*[in]*/ aafUInt64  position) PURE;


  //***********************************************************
  //
  // SetSize()
  //
  // Attempts to reserve size bytes of storage.
  //
  // Succeeds if:
  // - The requested space is available.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_DATA_SIZE
  //   - size bytes are not available.
  //
  STDMETHOD(SetSize) (THIS_
    // The requested file size
    /*[in]*/ aafUInt64  size) PURE;

  END_INTERFACE
};
#endif // __IAAFSetFileBits_INTERFACE_DEFINED__



// IAAFRandomFile

// ************************
//
// Interface IAAFRandomFile
//
// ************************





#ifndef __IAAFRandomFile_INTERFACE_DEFINED__
#define __IAAFRandomFile_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFRandomFile;

#undef  INTERFACE
#define INTERFACE   IAAFRandomFile

DECLARE_INTERFACE_(IAAFRandomFile, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFRandomFile methods *** */

  //***********************************************************
  //
  // GetFileBits()
  //
  // Since the purpose of this method is to obtain file data after a
  // file has been created, it will only succeed if this file has
  // already been Open()ed and then Close()d, or if it was never
  // opened with write access.
  // 
  // Succeeds if:
  // - The ppGetFileBits argument is valid
  // - This file has been opened for write or modify, and has been
  //   subsequently closed.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppGetFileBits arg is NULL.
  //
  // AAFRESULT_BADOPEN
  // - This file has never been opened
  //
  // AAFRESULT_NOT_WRITEABLE
  // - This file has never been opened for write or modify
  //
  // AAFRESULT_BADCLOSE
  // - This file has not been closed after being opened.
  //
  STDMETHOD(GetFileBits) (THIS_
    // The interface to the GetFileBits object
    /*[out]*/ IAAFGetFileBits ** ppGetFileBits) PURE;


  //***********************************************************
  //
  // Revert()
  //
  // Reverts this file to the previously-saved state.
    // NOTE! Stub only.   Implementation not yet added.
  //

  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  STDMETHOD(Revert) (THIS) PURE;


  //***********************************************************
  //
  // SaveAsFile()
  //
  // Associates this file with the storage specified in pDestFile.
  // Any objects contained in pDestFile will be lost.
  // 
  // Behaves in a manner similar to SaveCopyAs(), except that
  // SaveAs() will change this object to be associated with the new
  // file.
  // 
  // Special case: if f->SaveAs(f) is called, passing this as the
  // save-to argument, the operation will save everything including
  // things which have not changed.
    // NOTE! Stub only.   Implementation not yet added.
  //

  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  STDMETHOD(SaveAsFile) (THIS_
    // The destination file into which the contents of this file are to
    // be written.
    /*[in]*/ IAAFFile * pDestFile) PURE;


  //***********************************************************
  //
  // SetFileBits()
  //
  // Since the purpose of this method is to specify file data with
  // which a file is to be created, it will only succeed if this file
  // has not yet been Open()ed.
  //
  // Succeeds if:
  // - The ppSetFileBits argument is valid
  // - This file has not yet been opened.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppSetFileBits arg is NULL.
  //
  // AAFRESULT_BADOPEN
  // - This file has has already been opened
  //
  // AAFRESULT_NOT_READABLE
  // - This read or modify has not been specified for this file
  //
  STDMETHOD(SetFileBits) (THIS_
    // The interface to the SetFileBits object
    /*[out]*/ IAAFSetFileBits ** ppSetFileBits) PURE;

  END_INTERFACE
};
#endif // __IAAFRandomFile_INTERFACE_DEFINED__



// IAAFEndian

// ************************
//
// Interface IAAFEndian
//
// ************************

#ifndef __IAAFEndian_INTERFACE_DEFINED__
#define __IAAFEndian_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFEndian;

#undef  INTERFACE
#define INTERFACE   IAAFEndian

DECLARE_INTERFACE_(IAAFEndian, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFEndian methods *** */

  //***********************************************************
  //
  // GetStoredByteOrder()
  //
  // Returns the "Endian-ness" in which the current object was or will
  // be stored.  If this is a transient object (i.e., one which has
  // not been persisted) then it will return the native byte order of
  // the platform on which this is running.
  // 
  // Succeeds if all of the following are true:
  // - the pOrder pointer is valid.
  // 
  // If this method fails nothing is written to *pOrder.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pOrder is null.
  //
  STDMETHOD(GetStoredByteOrder) (THIS_
    // Pointer to place where byte order is to be put
    /*[out]*/ eAAFByteOrder_t *  pOrder) PURE;


  //***********************************************************
  //
  // GetNativeByteOrder()
  //
  // Returns the native "Endian-ness" of the platform on which this is
  // running.
  // 
  // Succeeds if all of the following are true:
  // - the pOrder pointer is valid.
  // 
  // If this method fails nothing is written to *pOrder.
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pOrder is null.
  //
  STDMETHOD(GetNativeByteOrder) (THIS_
    // Pointer to place where byte order is to be put
    /*[out]*/ eAAFByteOrder_t *  pOrder) PURE;

  END_INTERFACE
};
#endif // __IAAFEndian_INTERFACE_DEFINED__



// IAAFSearchSource

// ************************
//
// Interface IAAFSearchSource
//
// ************************

#ifndef __IAAFSearchSource_INTERFACE_DEFINED__
#define __IAAFSearchSource_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFSearchSource;

#undef  INTERFACE
#define INTERFACE   IAAFSearchSource

DECLARE_INTERFACE_(IAAFSearchSource, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFSearchSource methods *** */

  //***********************************************************
  //
  // SearchSource()
  //
  // This function returns the source information for a slot in a
  // Master Mob or Source Mob.  It follows the Source Clip references
  // in the specified slot until it encounters the kind of Mob
  // specified in the mobKind parameter.  This function cannot be used
  // on a Composition Mob and is not intended to be called
  // iteratively; use the MobOpenSearch, MobGetNextSource,
  // MobGetThisSource, and MobCloseSearch functions for those
  // purposes. 
  //
  // The returned component and find source info are AddRef()ed
  // before they are returned.
  //
  // Succeeds if all of the following are true:
  // - ppSourceInfo is non-NULL
  // - a Mob of the requested kind is found
  // 
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppCpnt is null.
  //
  // OM_ERR_INVALID_MOBTYPE
  //	- The enumerator is out of range (bad cast, or writing
  //      toolkit newer than reader)
  //
  // OM_ERR_TRAVERSAL_NOT_POSS
  //	- Can not find a mob of the given kind.
  //
  STDMETHOD(SearchSource) (THIS_
    // Slot ID
    /*[in]*/ aafSlotID_t  slotID,

    // Offset
    /*[in]*/ aafPosition_t  offset,

    // Mob Kind
    /*[in]*/ aafMobKind_t  mobKind,

    // Media Criteria
    /*[in]*/ aafMediaCriteria_t *  pMediaCrit,

    // Operation Choice
    /*[in]*/ aafOperationChoice_t *  pOperationChoice,

    // Source Information
    /*[out]*/ IAAFFindSourceInfo ** ppSourceInfo) PURE;

  END_INTERFACE
};
#endif // __IAAFSearchSource_INTERFACE_DEFINED__



// IAAFEssenceMultiAccess

// ************************
//
// Interface IAAFEssenceMultiAccess
//
// ************************








#ifndef __IAAFEssenceMultiAccess_INTERFACE_DEFINED__
#define __IAAFEssenceMultiAccess_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFEssenceMultiAccess;

#undef  INTERFACE
#define INTERFACE   IAAFEssenceMultiAccess

DECLARE_INTERFACE_(IAAFEssenceMultiAccess, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFEssenceMultiAccess methods *** */

  //***********************************************************
  //
  // WriteMultiSamples()
  //
  // Writes multiple channels worth of sample data to an interleaved
  // data stream in the natural order for the CODEC.
  //
  STDMETHOD(WriteMultiSamples) (THIS_
    // number of elements in the array of transfer operations
    /*[in]*/ aafUInt16  arrayElemCount,

    // points to an array of transfer parameters.  All fields in this
    // array except for bytesXferred must be set up before doing the
    // transfer.  Some of the fields in the xferArray structure are
    // status results like bytesXferred and samplesXferred.
    //
    // The multiXfer_t structure has the following fields, which
	// specify one channel of data: 
    //   essenceDef    [IN] -- The essence type definition
    //   physical      [IN] -- The physical input-output channel
    //   numSamples    [IN] -- The number of samples to transfer
    //   buflen        [IN] -- The size of the buffer
    //   buffer        [IN] -- The buffer for this
    /*[in,size_is(arrayElemCount)]*/ aafmMultiXfer_t *  xferArray,

    // put results into this array.  It has the following fields,
    // which return result for one channel of data:
    //   bytesXfered   [OUT] -- The total number of bytes transferred
    //   samplesXfered [OUT] -- The total number of samples transferred
    /*[out,size_is(arrayElemCount)]*/ aafmMultiResult_t *  resultArray) PURE;


  //***********************************************************
  //
  // ReadMultiSamples()
  //
  // Reads one or more channels from an interleaved data stream.
  // Possible Errors:
  //
  // Standard errors (see top of file).
  //   AAFRESULT_END_OF_ESSENCE -- Hit the end of the essence (like
  //                               EOF) while reading.
  //
  STDMETHOD(ReadMultiSamples) (THIS_
    // The size of the array for transfer operations.
    /*[in]*/ aafUInt16  elemCount,

    // Points to an array of transfer parameters.  All fields in this
    // array except for bytesXferred must be set up before doing the
	// transfer.  Some of the fields in the xferArray structure are
	// status results like bytesXferred and samplesXferred.
    //
    // The multiXfer_t structure has the following fields, which
	// specify one channel of data:
    // essenceDef  [IN] -- The essence type definition
    // physical    [IN] -- The physical input-output channel
    // numSamples  [IN] -- The number of samples to transfer
    // buflen      [IN] -- The size of the buffer
    // buffer      [IN] -- The buffer for this
    /*[in, size_is(elemCount)]*/ aafmMultiXfer_t *  xferArray,

    // Results go into this array.
    //
    // The aafmMultiResult_t structure has the following fields,
	// which return result for one channel of data: 
    // bytesXfered   [OUT] -- The total number of bytes transferred
    // samplesXfered [OUT] -- The total number of samples transferred
    /*[out, size_is(elemCount)]*/ aafmMultiResult_t *  resultArray) PURE;

  END_INTERFACE
};
#endif // __IAAFEssenceMultiAccess_INTERFACE_DEFINED__



// IAAFTypeDefVariableArrayEx

// ************************
//
// Interface IAAFTypeDefVariableArrayEx
//
// ************************





#ifndef __IAAFTypeDefVariableArrayEx_INTERFACE_DEFINED__
#define __IAAFTypeDefVariableArrayEx_INTERFACE_DEFINED__

EXTERN_C const IID IID_IAAFTypeDefVariableArrayEx;


#undef  INTERFACE
#define INTERFACE   IAAFTypeDefVariableArrayEx

DECLARE_INTERFACE_(IAAFTypeDefVariableArrayEx, IUnknown)
{
  BEGIN_INTERFACE

  /* *** IUnknown methods *** */
  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
  STDMETHOD_(ULONG,Release) (THIS) PURE;

  /* *** IAAFTypeDefVariableArrayEx methods *** */



  //***********************************************************
  //
  // PrependElement()
  //
  // Prepends an element to the end of the array, setting it to the
  // value given in pMemberPropVal.
  //
  // Succeeds if:
  // - Initialize() has already been called on this object.
  // - pInPropVal pointer is valid.
  // - pMemberPropVal pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - either pInPropVal or pMemberPropVal arg is NULL.
  //
  STDMETHOD(PrependElement) (THIS_
    // property value corresponding to array to which element is prepended
    /*[in]*/ IAAFPropertyValue * pInPropVal,

    // value to be prepended to this array
    /*[in]*/ IAAFPropertyValue * pMemberPropVal) PURE;




  //***********************************************************
  //
  // RemoveElement()
  //
  // Remove an element from the Array, given an index.
  // Index is zero-based,
  // and must be less than the value returned by GetCount().
  // 
  // Succeeds if:
  // - Initialize() has already been called on this object.
  // - the index exists in this array type def.
  // - The pInPropVal pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - pInPropVal arg is NULL.
  //
  // AAFRESULT_BADINDEX
  //   - The given index is out of range for this array type def.
  //
  STDMETHOD(RemoveElement) (THIS_
    // property value corresponding to array
    /*[in]*/ IAAFPropertyValue * pInPropVal,

    // zero-based index into elements in this array type
    /*[in]*/ aafUInt32  index) PURE;




  //***********************************************************
  //
  // InsertElement()
  //
  // Inserts the value of the single, indicated element of the fixed
  // array contained in pInPropVal, to the value contained in
  // pMemberPropVal.  Index is zero-based, and must be less than the
  // value returned by GetCount().  Property value must be of the
  // same type as returned by GetType().
  // 
  // Succeeds if:
  // - Initialize() has already been called on this object.
  // - the index exists in this array type def.
  // - The pInPropVal pointer is valid.
  // - The ppOutPropVal pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_NULL_PARAM
  //   - either pInPropVal or ppOutPropVal arg is NULL.
  //
  // AAFRESULT_BADINDEX
  //   - The given index is out of range for this array type def.
  //
  STDMETHOD(InsertElement) (THIS_
    // property value corresponding to array
    /*[in]*/ IAAFPropertyValue * pInPropVal,

    // zero-based index into elements in this array type
    /*[in]*/ aafUInt32  index,

    // value to be inserted into this array
    /*[in]*/ IAAFPropertyValue * pMemberPropVal) PURE;





  END_INTERFACE
};
#endif // __IAAFTypeDefVariableArrayEx_INTERFACE_DEFINED__











  //***********************************************************
  // Functions used to dynamically load and unload the AAF dll
  // without statically linking to the dll's export library.
  // To use these functions link to the stub library aaf.lib
  // (or aafd.lib for the debugging version). 
  // If the client is statically linking to the AAF dll's export
  // library then the following functions will always succeed:
  //***********************************************************

  //***********************************************************
  //
  // AAFLoad()
  //
  // Attempts to load the given implementation of AAF into
  // the processes address space. Only one implementation
  // of AAF can be active. Note: once AAFUnload has been
  // called all
  // 
  STDAPI AAFLoad (
    // Pointer to the name of AAF dll to load.
    // If this pointer is NULL the function will attempt to load the
    // default AAF dll.
    /*[in]*/ const char *  dllname);


  //***********************************************************
  //
  // AAFUnload()
  //
  // Attempts to unload the current AAF dll loaded with a
  // previous call to AAFLoad.
  // 
  STDAPI AAFUnload ();


  //***********************************************************
  // Factory functions for AAF files:.
  //***********************************************************

  //***********************************************************
  //
  // AAFFileOpenExistingRead()
  //
  // Creates an object associated with with an existing filesystem
  // file that contains data which is only to be read.  Does the
  // following:
  // - Opens the existing named file in the filesystem for reading.
  // - Associates an object with that filesystem file.
  // - Places the object into the Open-read-only state.
  // - This AAFFile object then can be used as the root of the
  //   containment tree representing all AAF objects contained within
  //   the file.
  //
  // Succeeds if:
  // - The pFileName argument is valid.
  // - Only valid flags have been specified.
  // - A valid combination of flags has been specified.
  // - The named file exists in the filesystem.
  // - The named filesystem file is readable.
  // - The named file represents itself as a valid AAF file.  Even if
  //   this succeeds, it is not guaranteed that the named file is in
  //   fact a valid AAF file.
  //
  // This function will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - the pFileName pointer arg is NULL.
  //
  // AAFRESULT_BAD_FLAGS
  //   - one or more illegal flags were specified.
  //
  // AAFRESULT_BAD_FLAG_COMBINATION
  //   - illegal combination of otherwise valid flags was specified.
  //
  // AAFRESULT_FILE_NOT_FOUND
  //   - The named file does not exist in the filesystem.
  //
  // AAFRESULT_NOT_READABLE
  //   - The named file cannot be read.
  //
  // AAFRESULT_NOT_AAF_FILE
  //   - The named file does not claim to be a valid AAF file.
  // 
  STDAPI AAFFileOpenExistingRead (
    // Null-terminated string containing name of filesystem file to be
    // opened for reading.  Filename must be in a form that would be
    // acceptable to StgOpenStorage() for this platform.
    /*[in, string]*/ aafCharacter_constptr  pFileName,

    // File open mode flags.  May be any of the following ORed
    // together.  All other bits must be set to zero.
    //  - kAAFFileModeUnbuffered - to indicate buffered mode.  Default
    //    is buffered.
    /*[in]*/ aafUInt32  modeFlags,

    // Pointer to buffer to receive pointer to new file.
    /*[out]*/ IAAFFile ** ppFile);


  //***********************************************************
  //
  // AAFFileOpenExistingModify()
  //
  // Creates an object associated with with an existing
  // filesystem file that contains data which is to be read and
  // written.  Associates the given identification with it.
  // Does the following:
  // - Opens the existing named file in the filesystem for reading and
  //   writing.
  // - Associates an object with that filesystem file.
  // - Places the object into the Open-read-write  state.
  // - This AAFFile object then can be used as the root of the
  //   containment tree representing all AAF objects contained within
  //   the file.
  //
  // Succeeds if:
  // - This object is currently Closed.
  // - The pFileName argument is valid.
  // - The pIdent argument is valid.
  // - Only valid flags have been specified.
  // - A valid combination of flags has been specified.
  // - The named file exists in the filesystem.
  // - The named filesystem file is readable.
  // - The named filesystem file is writable.
  // - The named file represents itself as a valid AAF file.  Even if
  //   this succeeds, it is not guaranteed that the named file is in
  //   fact a valid AAF file.
  //
  // This function will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - either pFileName or pIdent pointer argument is NULL.
  //
  // AAFRESULT_BAD_FLAGS
  //   - one or more illegal flags were specified.
  //
  // AAFRESULT_BAD_FLAG_COMBINATION
  //   - illegal combination of otherwise valid flags was specified.
  //
  // AAFRESULT_FILE_NOT_FOUND
  //   - The named file does not exist in the filesystem.
  //
  // AAFRESULT_NOT_READABLE
  //   - The named file cannot be read.
  //
  // AAFRESULT_NOT_WRITEABLE
  //   - The named file cannot be written.
  //
  // AAFRESULT_NOTAAFFILE
  //   - The named file is not a valid AAF file.
  // 
  STDAPI AAFFileOpenExistingModify (
    // Null-terminated string containing name of filesystem file to be
    // opened for modification.  Filename must be in a form that would
    // be acceptable to StgOpenStorage() for this platform.
    /*[in, string]*/ aafCharacter_constptr  pFileName,

    // File open mode flags.  May be any of the following ORed together.
    // All other bits must be set to zero.
    //  - kAAFFileModeUnbuffered - to indicate unbuffered mode.
    //    Default is buffered.
    //  - kAAFFileModeRevertable - to indicate that Revert is possible
    //    on this file (for all changes except those to essence).
    /*[in]*/ aafUInt32  modeFlags,

    // Identification of the application which is modifying this file.
    /*[in]*/ aafProductIdentification_t *  pIdent,

    // Pointer to buffer to receive pointer to new file.
    /*[out]*/ IAAFFile ** ppFile);


  //***********************************************************
  //
  // AAFFileOpenNewModify()
  //
  // Creates an object associated with with a new
  // filesystem file that contains data which is to be read and
  // written.  Associates the given identification with it.
  // Does the following:
  // - Creates a new file in the filesystem with the given name.
  // - Opens the filesystem file for reading and writing.
  // - Associates this object with that filesystem file.
  // - Places this object into the Open state.
  // - This AAFFile object then can be used as the root of the
  //   containment tree representing all AAF objects contained within
  //   the file.
  //
  // Succeeds if:
  // - The pFileName argument is valid.
  // - The pIdent argument is valid.
  // - Only valid flags have been specified.
  // - A valid combination of flags has been specified.
  // - The named file does not exists in the filesystem.
  // - There is sufficient space in the filesystem to create the file.
  //
  // This function will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - either pFileName or pIdent pointer argument is NULL.
  //
  // AAFRESULT_BAD_FLAGS
  //   - one or more illegal flags were specified.
  //
  // AAFRESULT_BAD_FLAG_COMBINATION
  //   - illegal combination of otherwise valid flags was specified.
  //
  // AAFRESULT_FILE_EXISTS
  //   - The named file already exists in the filesystem.
  //
  // AAFRESULT_INSUFFICIENT_SPACE
  //   - There is insufficient space in the filesystem to create this
  //     file.
  // 
  STDAPI AAFFileOpenNewModify (
    // Null-terminated string containing name of filesystem file to be
    // opened for modification.  Filename must be in a form that would
    // be acceptable to StgOpenStorage() for this platform.
    /*[in, string]*/ aafCharacter_constptr  pFileName,

    // File open mode flags.  May be any of the following ORed together.
    // All other bits must be set to zero.
    //  - kAAFFileModeUnbuffered - to indicate unbuffered mode.
    //    Default is buffered.
    //  - kAAFFileModeRevertable - to indicate that Revert is possible
    //    on this file (for all changes except those to essence).
    /*[in]*/ aafUInt32  modeFlags,

    // Identification of the application which is creating this file.
    /*[in]*/ aafProductIdentification_t *  pIdent,

    // Pointer to buffer to receive pointer to new file.
    /*[out]*/ IAAFFile ** ppFile);


  //***********************************************************
  //
  // AAFFileOpenTransient()
  //
  // Creates an object associated with with a transient file,
  // meaning that it is not associated with any filesystem file but
  // may still be used to contain AAF objects as if it was associated
  // with a filesystem file.  Associates the given identification with
  // this file.
  //
  // Transient files are never considered Revertable.
  //
  // NOTE! Stub only.   Implementation not yet added.
  //
  // Succeeds if:
  // - This object has already been Initialize()d.
  // - The pIdent argument is valid.
  // - This object is currently closed.
  //
  // This function will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NOT_INITIALIZED
  //   - This object has not yet had Initialize() called on it.
  //
  // AAFRESULT_ALREADY_OPEN
  //   - This object is already open.
  //
  // AAFRESULT_NULL_PARAM
  //   - the pIdent pointer argument is NULL.
  // 
  STDAPI AAFFileOpenTransient (
    // Identification which is to be associated with this file.
    /*[in]*/ aafProductIdentification_t *  pIdent,

    // Pointer to buffer to receive pointer to new file.
    /*[out]*/ IAAFFile ** ppFile);


  //***********************************************************
  //
  // AAFFileIsAAFFile()
  //
  // Is the named file an AAF file ?
  //
  // Note that the function result is returned via the pFileIsAAFFile argument.
  // If this function succeeds it returns AAFRESULT_SUCCESS even if the named
  // file is not an AAF file.
  //
  // This function will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - at least one of the pointer arguments is NULL.
  //
  // AAFRESULT_FILE_NOT_FOUND
  //   - the file named by pFileName cannot be found.
  // 
  STDAPI AAFFileIsAAFFile (
    // Null-terminated string containing name of filesystem file.
    /*[in, string]*/ aafCharacter_constptr  pFileName,

    // Pointer to an AUID indicating the file kind
    /*[out]*/ aafUID_t *  pAAFFileKind,

    // Returns AAFTrue if the given file is an AAF file, returns AAFFalse otherwise.
    /*[out,retval]*/ aafBool *  pFileIsAAFFile);


  //***********************************************************
  //
  // AAFGetPluginManager()
  //
  // Returns an interface of the plugin manager, which is used to
  // select plugins for exporting.
  // 
  STDAPI AAFGetPluginManager (
    // Pointer to the interface of the plugin manager.
    /*[out]*/ IAAFPluginManager ** ppPluginManager);


  //***********************************************************
  //
  // AAFCreateRawStorageMemory()
  //
  // Create a raw storage providing a built-in implementation of
  // IAAFRawStorage on memory.
  //
  // This is considered a value-added function since clients could
  // actually create their own.
  //
  // Succeeds if:
  // - The ppNewRawStorage pointer is valid.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - ppNewRawStorage arg is NULL.
  // 
  STDAPI AAFCreateRawStorageMemory (
    // Governs whether stream may be read from and/or written
    // to.
    /*[in]*/ aafFileAccess_t  access,

    // Newly created storage
    /*[out]*/ IAAFRawStorage ** ppNewRawStorage);


  //***********************************************************
  //
  // AAFCreateRawStorageDisk()
  //
  // Create a raw storage providing a built-in implementation of
  // IAAFRawStorage on a file on disk.
  //
  // Note that it is illegal to specify existence and access as "New"
  // "Read".
  //
  // This is considered a value-added function since clients could
  // actually create their own.
  //
  // Succeeds if:
  // - The pFilename pointer is valid.
  // - The ppNewRawStorage pointer is valid.
  // - If the open mode is one of read, write, or modify.
  // - If the file existence is one of new or existing.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pFilename or ppNewRawStorage arg is NULL.
  //
  // AAFRESULT_WRONG_OPENMODE
  // - If none of read, modify, or write are specified as open
  //   mode, or if neither new or existing is specified for the
  //   existence.
  // 
  STDAPI AAFCreateRawStorageDisk (
    // Name of file to be associated with this storage
    /*[in]*/ aafCharacter_constptr  pFilename,

    // Governs whether storage is on pre-existing data, or is
    //  newly created.
    /*[in]*/ aafFileExistence_t  existence,

    // Governs whether stream may be read from and/or written
    //  to.
    /*[in]*/ aafFileAccess_t  access,

    // Newly created storage
    /*[out]*/ IAAFRawStorage ** ppNewRawStorage);


  //***********************************************************
  //
  // AAFCreateAAFFileOnRawStorage()
  //
  // Given an IAAFRawStorage, create an IAAFFile.  If pRawStorage is
  // actually an IAAFRandomRawStorage, the created file will be an
  // IAAFRandomFile.
  //
  // Note that AAF files based on Binary Structured Storage will
  // require the underlying IAAFRawStorage to be at least readable,
  // even in the case of write-only AAF files.
  //
  // Note also that only the following combinations of access and
  // existence are legal:
  //
  // existence   access   Legal?
  // ---------   ------   ------
  // existing    read     yes
  // existing    write    no
  // existing    modify   yes
  //   new       read     no
  //   new       write    yes
  //   new       modify   yes
  //
  // This method will succeed if the following are true:
  // - The pRawStorage pointer is valid.
  // - The ppNewFile pointer is valid.
  // - The accessibility of the specified raw storage matches that of
  //   the desired AAF File; additionally, if the file kind is
  //   Structured Storage Binary, the raw storage is also required to
  //   be at least readable. 
  // - A legal combination of existence and access flags is given.
  //
  // This method will return the following codes.  If more than one of
  // the listed errors is in effect, it will return the first one
  // encountered in the order given below:
  // 
  // AAFRESULT_SUCCESS
  //   - succeeded.  (This is the only code indicating success.)
  //
  // AAFRESULT_NULL_PARAM
  //   - pRawStorage or ppNewFile arg is NULL.
  //
  // AAFRESULT_NOT_READABLE
  // - The access parameter specifies readability or if this file is
  //   Binary Structured Storage, but the specified raw storage is
  //   not readable.
  //
  // AAFRESULT_NOT_WRITEABLE
  // - The access parameter specifies writeability but the specified
  //   raw storage is not writeable.
  //
  // AAFRESULT_NULL_PARAM
  // - existence is new, and pFileKind is NULL.
  //
  // AAFRESULT_INVALID_PARAM
  // - The access or existence parameters are not set to a legal
  //   combination of values.
  // 
  STDAPI AAFCreateAAFFileOnRawStorage (
    // storage to be associated with this file
    /*[in]*/ IAAFRawStorage *  pRawStorage,

    // Governs whether storage is on pre-existing data, or is
    //  newly created.
    /*[in]*/ aafFileExistence_t  existence,

    // Governs whether stream may be read from and/or written
    //  to.
    /*[in]*/ aafFileAccess_t  access,

    // kind of file to be created; only used for new files
    /*[in]*/ aafUID_constptr  pFileKind,

    // File mode flags
    /*[in]*/ aafUInt32  modeFlags,

    // Identification to be associated with this file; only
    //  used for new files
    /*[in]*/ aafProductIdentification_constptr  pIdent,

    // newly-created file
    /*[out]*/ IAAFFile ** ppNewFile);


#endif // __AAF_h__
